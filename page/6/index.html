<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhouyifan.net","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
<meta property="og:type" content="website">
<meta property="og:title" content="周弈帆的博客">
<meta property="og:url" content="https://zhouyifan.net/page/6/index.html">
<meta property="og:site_name" content="周弈帆的博客">
<meta property="og:description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zhou Yifan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zhouyifan.net/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>周弈帆的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">周弈帆的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/07/04/DLS-note-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/04/DLS-note-9/" class="post-title-link" itemprop="url">吴恩达《深度学习专项》笔记（九）：错误分析、数据集匹配、多任务学习、端到端学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-04 17:14:51" itemprop="dateCreated datePublished" datetime="2022-07-04T17:14:51+08:00">2022-07-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="学习提示"><a href="#学习提示" class="headerlink" title="学习提示"></a>学习提示</h1><p>这周要学习四项内容：错误分析、使用不匹配的数据、完成多个任务的学习、端到端学习。</p>
<p>其中，前两项内容是对上一周内容的扩展。学完这些知识后，我们能更好地决定下一步的改进计划。通过处理分布不匹配的数据，我们能够学会如何诊断一种新的问题：数据不匹配问题。之后，我们使用错误分析技术，找到模型具体的错误样例，进一步改进模型。</p>
<p>后两项内容分别是两项深度学习的应用技巧。我们会学习迁移学习、多任务学习这两种处理多个学习任务的方法。我们还会学习如何用深度学习把问题一步到位地解决，而不是分好几个步骤。</p>
<h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h2><h3 id="分析具体错误"><a href="#分析具体错误" class="headerlink" title="分析具体错误"></a>分析具体错误</h3><p>当我们想提升模型的准确率时，一种做法是统计模型输出错误的样例，看看哪类数据更容易让模型出错。</p>
<p>比如，在提升一个小猫分类器的准确率时，我们可以去看看分类器最容易把其他哪种动物错分类成小猫。经过调查后，我们可能会发现一些小狗长得很像小猫，分类器在这些小狗图片上的表现不佳：</p>
<p><img src="/2022/07/04/DLS-note-9/1.jpg" alt></p>
<p>这时，我们可以考虑去提升模型在小狗图片上的表现。</p>
<p>但是，在决定朝着某个方向改进模型之前，我们应该先做一个数据分析，看看这样的改进究竟有没有意义。我们可以去统计100张分类错误的<strong>开发集</strong>图片，看看这些图片里有多少张是小狗。如果小狗图片的数量很小，比如说只有5张，那么无论我们再怎么提升模型辨别小狗的能力，我们顶多把10%的错误率降到9.5%，提升微乎其微；但如果错分为小狗图片的数量很多，比如有50张，那么我们最优情况下可以把错误率从10%降到5%，这个提升就很显著了。</p>
<p>更系统地，我们可以建立一套同时分析多个改进方向的数据分析方法。比如说，在小猫的错误样例中，一些输入样本是很像小猫的小狗，一些输入样本是其他大型猫科动物，一些输入样本过于模糊。我们可以挑一些错误的样例，分别去记录这些错误样例的出现情况：</p>
<p><img src="/2022/07/04/DLS-note-9/2.jpg" alt></p>
<p>在这个表格中，我们可以记录每张分类错误的图片是由哪一种错误引起的，并留下一些备注。</p>
<p>调研已有问题的同时，我们还可以顺便去发现一些新的问题。比如我们可能会发现某些错分类的图片加了滤镜。发现这个新问题后，我们可以去表格中新建“滤镜”这一列。</p>
<p>手动分析完所有样例后，我们统计每种错误的百分比，看看改进哪种问题的价值更大。</p>
<h3 id="清理标错的数据"><a href="#清理标错的数据" class="headerlink" title="清理标错的数据"></a>清理标错的数据</h3><p>在有监督学习中，标注数据往往是人工完成的，数据的标签有误也是情理之中的事。那么，如果数据中有标错的数据，它们会对模型的表现有什么影响呢？</p>
<p>首先，来看训练集有误的影响。事实上，深度学习算法对<strong>随机错误</strong>的容忍度很高。如果有少量样本是不小心标错的，那么它们对训练结果几乎没有影响。但是，如果数据中有<strong>系统性错误</strong>，比如白色的小狗全部被标成了小猫，那问题就大了，因为模型也会学到数据集中这种错误的规律。</p>
<p>接着，我们来看开发集有误的影响。为了确认标错数据的影响，我们应该用刚刚的表格统计法，顺便调查一下标错数据的比例：</p>
<p><img src="/2022/07/04/DLS-note-9/3.jpg" alt></p>
<p>在开发集误差不同时，标错数据产生的影响也不同。假设我们分别有一个开发集误差为10%的分类器和一个误差为2%的分类器：</p>
<p><img src="/2022/07/04/DLS-note-9/4.jpg" alt></p>
<p>对于第一个分类器，总体占比0.6%的错标数据相对于10%的开发集错误率几乎可以忽略。但是，对于第二个误差为2%的分类器，0.6%的错标数据就显得占比很大了。在这种情况下，假如有同一个模型有两个权重记录点，一个误差为2.1%，一个误差为1.9%。由于误差的存在，我们不好说第二个记录点就优于第一个记录点。回想一下，开发集本来的目的就是帮助我们选择一个在开发集上表现更好的模型。分辨不出更好的模型，开发集就失效了。因此，我们必须要去纠正一下这些开发集中的错标数据。</p>
<p>在纠正错标数据时，我们要注意以下几点：</p>
<ul>
<li>由于开发集和测试集应来自同一个分布，纠正数据的过程应该在开发集和测试集上同步进行。</li>
<li>不仅要检查算法输出错误的样本中的错标样本，还要考虑那些标注错误却输出正确的样本。</li>
<li>不一定要去训练集上纠正错标样本，因为训练集和开发集/测试集可以来自不同的分布。</li>
</ul>
<p>吴恩达老师建议道，尽管很多人会因为检查数据这件事很琐碎而不愿意去一个一个检查算法输出错误的样本，但他还是鼓励大家这样做。他在自己领导的深度学习项目中，经常亲自去检查错误样本。检查错误样本往往能够确认算法之后的改进方向，在这件事上花时间绝对是值得的。</p>
<h3 id="快速构建第一个系统，再迭代更新"><a href="#快速构建第一个系统，再迭代更新" class="headerlink" title="快速构建第一个系统，再迭代更新"></a>快速构建第一个系统，再迭代更新</h3><p>在面对一个全新的深度学习问题时，我们不应该一上来就花很多时间去开发一个复杂的系统，而是应该按照下面的步骤尽快开始迭代：</p>
<ul>
<li>快速建立开发集、测试集和评估指标以树立一个目标。</li>
<li>快速构建一个初始的系统。</li>
<li>使用偏差和方差分析、错误分析来获取后续任务的优先级。</li>
</ul>
<p>简而言之，就是：快速构建第一个系统，再迭代更新。</p>
<p>当然，如果你在这个问题上已经很有经验了，或者这个问题已经有很多的科研文献，那么一上来就使用一套较为复杂却十分成熟的系统也是可以的。</p>
<blockquote>
<p>这种快速迭代的思想同样适用于人生中的其他任务。比如，软件开发中，敏捷开发指的就是快速开发出原型，再逐步迭代。同样，我们在计划做一件事时，不必事先就想得面面俱到，可以尽快下手，再逐渐去改良做法。</p>
</blockquote>
<h2 id="不匹配的训练集与开发-测试集"><a href="#不匹配的训练集与开发-测试集" class="headerlink" title="不匹配的训练集与开发/测试集"></a>不匹配的训练集与开发/测试集</h2><h3 id="在不同分布上训练与测试"><a href="#在不同分布上训练与测试" class="headerlink" title="在不同分布上训练与测试"></a>在不同分布上训练与测试</h3><p>到目前为止，我们已经多次学习过，开发集和测试集的分布必须一致，但是它们与训练集的分布不一定要一致。让我们来看一个实际的例子：</p>
<p>假设我们要开发一个小猫分类的手机程序。我们有两批数据，第一批是从网站上爬取的高清图片，共200,000张；第二批是使用手机摄像头拍摄上传的图片，有10,000张。最终，用户在使用我们的手机程序时，也是要通过拍照上传。</p>
<p><img src="/2022/07/04/DLS-note-9/5.jpg" alt></p>
<p>现在，有一个问题：该如何划分训练集、测试集、开发集呢？</p>
<p>一种方法是把所有数据混在一起，得到210,000张图片。之后，按照某种比例划分三个集合，比如按照205,000/2,500/2,500的比例划分训练/测试/开发集。</p>
<p>这种方法有一个问题：我们的开发集和测试集中有很多高清图片。但是，用户最终上传的图片可能都不是高清图片，而是模糊的收集摄像图片。在开发集和测试集中混入更简单的高清图片会让评估结果偏好，不能反映模型在实际应用中的真正表现。</p>
<p>另一种方法是只用手机拍摄的图片作为开发集和测试集。我们可以从手机拍摄的图片里选5,000张放进训练集里，剩下各放2,500张到开发/训练集里。这样的话，开发集和测试集就能更好地反映模型在我们所期望的指标上的表现了。</p>
<p>总结来说，如果我们有来自不同分布的数据，我们应该谨慎地划分训练集与开发/测试集，尽可能让开发/测试集只包含我们期待的分布中的数据，哪怕这样做会让训练集和开发/测试集的分布不一致。</p>
<h3 id="不同数据分布下的偏差与方差问题"><a href="#不同数据分布下的偏差与方差问题" class="headerlink" title="不同数据分布下的偏差与方差问题"></a>不同数据分布下的偏差与方差问题</h3><p>在之前的学习中，我们一直把机器学习模型的改进问题分为偏差问题和方差问题两种。而在使用不匹配的数据分布后，我们会引入一个新的分布不匹配问题。</p>
<p>还是在刚刚提到的小猫分类模型中，我们用第二种方法设置了分布不一致的训练集和开发/训练集。假设我们得到了1%的训练误差和10%的开发误差。但是，我们使用了不同分布的数据，开发/测试集的数据可能比训练数据要难得多。我们难以分辨更高的开发误差是过拟合导致的，还是开发集比训练集难度更高导致的。</p>
<p>为了区分这两种问题，我们需要划分出一个只评估一种问题的新数据集——训练开发集(Training-dev set)。训练开发集的用法和我们之前用的开发集类似，但是其数据分布和训练集一致，而不参与训练。通过比较模型在训练集和训练开发集上的准确度，我们就能单独评估模型的方差，进而拆分过拟合问题和数据不匹配问题了。</p>
<p>加入了这个数据集后，让我们对几个示例进行改进问题分析。</p>
<p>假设人类在小猫分类上的失误率是0%。现在，有以下几个不同准确率的模型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>误差/样本</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>训练误差</td>
<td>1%</td>
<td>1</td>
<td>10%</td>
<td>10%</td>
</tr>
<tr>
<td>训练开发误差</td>
<td>9%</td>
<td>1.5%</td>
<td>11%</td>
<td>11%</td>
</tr>
<tr>
<td>开发误差</td>
<td>10%</td>
<td>10</td>
<td>12%</td>
<td>20%</td>
</tr>
<tr>
<td>问题诊断</td>
<td>高方差</td>
<td>数据不匹配</td>
<td>高偏差</td>
<td>高偏差、数据不匹配</td>
</tr>
</tbody>
</table>
</div>
<p>也就是说，在多出了数据不匹配问题后，我们可以通过加入一个训练开发集来区分不同的问题。</p>
<p>当然，数据不匹配不一定会加大误差。如果开发/测试集上的数据更加简单，模型有可能取得比训练集还低的误差。</p>
<p>结合上周的知识，总结一下，考虑数据不匹配问题后，我们应该建立如下的表格：</p>
<p><img src="/2022/07/04/DLS-note-9/6.jpg" alt></p>
<p>首先，我们要知道训练集上人类的表现，以此为贝叶斯误差的一个估计。之后，我们要测训练误差和训练开发误差。训练误差和人类表现之间的差距为可规避偏差，训练开发误差和训练误差之间的差距为方差。最后，我们计算开发/测试集误差，这个误差和训练开发误差之间的差距为数据不匹配造成的差距。</p>
<p>一般来说，只把上述内容填入表格即可明确当前模型存在的问题。不过，如果我们能够获取开发/测试数据分布上的人类误差和训练误差，把上表填满，我们就能获取更多的启发。比如上表中，如果我们发现在开发/测试数据上人类的表现也是6%，这就说明开发/测试数据对于人类来说比较难，但是对模型来说比较简单。</p>
<h2 id="完成多个任务"><a href="#完成多个任务" class="headerlink" title="完成多个任务"></a>完成多个任务</h2><h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><p>深度学习的一大强大之处，就是一个深度学习模型在某任务中学习到的知识，能够在另一项任务中使用。比如在计算机视觉中，目标检测等更难的任务会把图像分类任务的模型作为其模型组成的一部分。这种技术叫做<strong>迁移学习</strong>。</p>
<p>假如我们有一个通用图像识别的数据集和一个医学图像识别数据集，我们可以先训好一个通用的图像识别模型，再对模型做一些调整，换医学图像数据上去再训练出一个医学图像识别模型。</p>
<p><img src="/2022/07/04/DLS-note-9/7.jpg" alt></p>
<p>具体来说，以上图中展示的情况为例，我们可以在训练完通用图像识别模型后，删掉最后一个输出层，初始化一个符合医学图像识别任务要求的输出层。之后，我们使用医学图像来训练。在这个过程中，如果新数据较少，我们既可以只训练最后的输出层，而保持其他层参数不变；如果新数据够多，我们可以让所有参数都参与训练。</p>
<p>这里还要介绍两个重要的深度学习名词。如果换新数据后要训练所有参数，则换数据前的训练过程称为<strong>预训练(pre-training)</strong> ，换数据后的训练过程称为<strong>微调(fine-tuning)</strong> 。</p>
<p>在上面的例子中，我们只是删掉了一个输出层，加了一个输出层。实际上，删哪些层换哪些层都没有一定的标准。如果任务变得更难了，我们可以删一个输出层，再加几个隐藏层和一个输出层。</p>
<p>迁移学习最常见的场合，是我们想完成训练数据较少的B任务，却在相似的A任务中有大量的训练数据。这时，我们就可以先学A任务，再迁移到B任务上。如果A、B任务的数据量差不多，那迁移学习就没什么意义了，因为同样是一份数据，对于B任务来说，一份B任务的数据肯定比一份A任务的数据要有用得多。</p>
<p>另外，迁移学习之所以能有效，是因为神经网络的浅层总能学到一些和任务无关，而之和数据相关的知识。因此，A任务和B任务要有一样的输入，且A任务的浅层特征能够帮助到任务B。</p>
<h3 id="多任务学习"><a href="#多任务学习" class="headerlink" title="多任务学习"></a>多任务学习</h3><p>在刚刚学的迁移学习中，模型会先学任务A，再学任务B。而在另一个面向多个任务的学习方法中，模型可以并行地学习多个任务。这种学习方法叫做<strong>多任务学习</strong>。</p>
<p>还是来先看一个例子。在开发无人驾驶车时，算法要分别识别出一张图片中是否有人行道、汽车、停止路牌、红绿灯……。识别每一种物体是否存在，都是一个二分类问题。使用多任务学习，我们可以让一个模型同时处理多个任务，即把模型的输出堆叠起来：</p>
<blockquote>
<p>这里，一定要区分多个二分类问题和多分类问题。多分类中，一个物体只可能属于多个类别中的一种；而多个二分类问题中，图片可以被同时归为多个类别。</p>
</blockquote>
<p><img src="/2022/07/04/DLS-note-9/8.jpg" alt></p>
<p>使用多任务学习时，除了输出数据格式需要改变，网络结构和损失函数也需要改变。多个二分类任务的网络结构和多分类的类似，都要在最后一层输出多个结果；而误差和多分类的不一样，不使用softmax，而是使用多个sigmoid求和（每个sigmoid对应一个二分类任务）。</p>
<p><img src="/2022/07/04/DLS-note-9/9.jpg" alt></p>
<p>此外，多个二分类任务和多分类任务还有一个不同。在执行多分类学习时，由于所有任务都用统一的数据，数据的标注可能有缺失。比如某几张图片可能没有标出红绿灯，另外几张图片又没有标出人行道。在多任务学习中，我们是允许数据中出现“模糊不清”的现象的，可以把没有标注的数据标成”?”。这样，碰到标注是”?”的数据时，我们就不对这一项进行损失函数的计算。</p>
<p>和迁移学习一样，多任务学习在使用上有一些要求。</p>
<p>首先，所有任务都必须受益于相同的浅层特征。这是显而易见的。</p>
<p>其次，每类任务的数据集都要差不多大。在迁移学习中，我们有比较大的数据集A和比较小的数据集B。而在迁移学习中，假如我们有100项任务，每种数据有1000条数据。对于每一项任务来说，其他99项任务的99000条数据就像数据集A一样，自己的1000条数据就像数据集B一样。</p>
<p>最后，经研究，只有当神经网络模型足够大时，使用多任务学习才至少不比分别学习每个任务差。</p>
<p>在实践中，迁移学习比多任务学习常见得多。</p>
<h2 id="端到端深度学习"><a href="#端到端深度学习" class="headerlink" title="端到端深度学习"></a>端到端深度学习</h2><p>深度学习的另一大强大之处，就是<strong>端到端(end-to-end)学习</strong>。这项技术可以让搭建学习算法简单很多。让我们先看看端到端学习具体是指什么。</p>
<p>不使用深度学习的话，一项任务可能会被拆成多个子步骤。比如在NLP（自然语言处理）中，为了让电脑看懂人类的语言，传统方法会先提取语言中的词语，再根据语法组织起词语，最后再做进一步的处理。而在端到端学习中，深度学习可能一步就把任务完成了。比如说机器翻译这项NLP任务，用深度学习的话，输入是某语言的句子，输出就是另一个语言的句子，中间不需要有其他任何步骤。</p>
<p>相较于多步骤的方法，端到端学习的方法需要更多的数据。仅在数据足够的情况下，端到端学习才是有效的。下面，我们来看一个反例。</p>
<p>在人脸识别任务中，输入是一张图片，输出是图片中人脸的身份。这里有一个问题：识别人脸之前，算法需要先定位人脸的位置。如果使用端到端学习的话，学习算法要花很长时间才能学会找到人脸并识别人脸的身份。</p>
<p>相比之下，我们可以把这个人物拆成两个阶段：第一阶段，算法的输入是图片，输出是一个框，框出了人脸所在位置；第二阶段，输入是框里的人脸，输出是人脸的身份。学习算法可以轻松地完成这两个子问题，这种非端到端的方法反而更加通用。</p>
<p><img src="/2022/07/04/DLS-note-9/10.jpg" alt></p>
<p>总结一下，非端到端学习想要优于端到端学习，必须满足两个条件：每个子任务都比较简单；每个子任务的数据很多，而整个任务的数据很少。</p>
<p>那么，具体哪些情况下该用端到端学习，哪些情况下不用呢？我们来看看端到端学习的优缺点：</p>
<p>优点：</p>
<ul>
<li>让数据说话。相较于手工设计的某些步骤，端到端学习能够从海量数据中发现于更适合计算机理解的统计规律。</li>
<li>减少手工设计的工作量，让设计者少花点精力。</li>
</ul>
<p>缺点：</p>
<ul>
<li>可能需要大量的数据。</li>
<li>排除了可能有用的手工设计的东西。比如人脸识别中，显然，找出人脸是一个绕不过去的子步骤。</li>
</ul>
<p>归根结底，还是数据量决定了是否使用端到端学习。在复杂的任务中，要达成端到端需要非常非常多的数据，在不能够获取足够数据之前，还是使用多阶段的方法好；而对于简单的任务，可能要求的数据不多，直接用端到端学习就能很好地完成任务了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这周的知识点如下：</p>
<ul>
<li>错误分析<ul>
<li>用表格做错误分析</li>
<li>统计错标数据</li>
</ul>
</li>
<li>数据不匹配<ul>
<li>何时使用数据分布不同的训练集和开发/测试集</li>
<li>训练开发集</li>
<li>如何诊断数据不匹配问题</li>
</ul>
</li>
<li>完成多个任务<ul>
<li>迁移学习的定义与常见做法</li>
<li>预训练、微调</li>
<li>多任务学习的定义</li>
<li>多个二分类任务</li>
<li>迁移学习与多任务学习的优劣、使用场景</li>
</ul>
</li>
<li>端到端深度学习<ul>
<li>认识端到端学习的例子</li>
<li>何时使用端到端学习</li>
</ul>
</li>
</ul>
<p>和上周一样，这周的知识都是一些只需要了解的概念，没有什么很复杂的公式。大家可以较为轻松地看完这周的内容。</p>
<p>另外，这周也没有官方的编程作业。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/07/03/DLS-note-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/03/DLS-note-8/" class="post-title-link" itemprop="url">吴恩达《深度学习专项》笔记（八）：如何降低误差以达成优化目标</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-03 17:14:58" itemprop="dateCreated datePublished" datetime="2022-07-03T17:14:58+08:00">2022-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>经过了之前的学习，我们学会了许多改进深度学习模型的方法，比如：</p>
<ul>
<li>收集更多数据</li>
<li>收集更多样化的数据</li>
<li>延长训练时间</li>
<li>用高级梯度下降算法</li>
<li>缩小/扩大网络</li>
<li>使用正则化</li>
<li>……</li>
</ul>
<p>这么多方法，如果只是一个一个试过去，开发效率就太低了。在未来的两周，我们会学习一些改进机器学习的策略。这些策略会给我们一些启发性的指导，让我们在改进模型时更明确下一步该做什么。</p>
<h1 id="学习提示"><a href="#学习提示" class="headerlink" title="学习提示"></a>学习提示</h1><p>这周课没有太多的新内容，主要是拓展了第二门课第一周有关偏差与方差分析的内容。学完了这周的课后，大家会进一步了解如何在一个全新的机器学习任务上设置目标，并通过误差分析等技术逐步靠近目标。</p>
<h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="正交化"><a href="#正交化" class="headerlink" title="正交化"></a>正交化</h2><p>如何从众多的改进方案中选择出优先级较高的呢？让我们先看看生活中一些其他事情的例子：</p>
<p><img src="/2022/07/03/DLS-note-8/1.jpg" alt></p>
<p>首先，是调整老式电视机的例子。老式电视机的画面不一定恰好能端端正正地填满屏幕，需要人为地调整画面的位置。一般这些电视机都有很多按钮，每个按钮各负责一项调整功能，比如调整上下位置、左右位置、缩放、旋转等。每个按钮之间的功能互不干扰。</p>
<p>另外，还有一个开汽车的例子。汽车最少有三种操作：转方向盘、加速、减速。只需要组合这三种操作，我们就能让汽车沿着某一路线跑起来。而如果汽车只有两个可以左右调整的按钮，一个按钮控制0.3倍的角度和-0.8倍的速度，另一个按钮控制2倍的角度和0.9倍的速度，那司机控制汽车时肯定会倍感吃力。</p>
<p>以上两个例子显示了<strong>正交化</strong>的好处。正交可以指数学里两条直线垂直，这里指的是两个调整方向互不干扰。通过调整正交的参数，我们可以把事物的“坐标分量”逐个调整到我们期待的“位置”。</p>
<p>类似地，在改进机器学习项目时，也可以使用正交化。</p>
<p><img src="/2022/07/03/DLS-note-8/2.jpg" alt></p>
<p>在机器学习项目中，大概有4个“坐标分量”需要调整：拟合训练集、拟合开发集、拟合测试集、提升实际应用中的表现。对于这每一项目标，我们都应该使用相互正交的策略去调整，比如：</p>
<ul>
<li>拟合训练集 - 用更大的网络</li>
<li>拟合开发集 - 正则化</li>
<li>拟合测试集 - 用更大的开发集</li>
<li>提升实际应用中的表现 - 更换损失函数</li>
</ul>
<p>值得一提的是，提前停止是一个即会影响训练误差，又会影响开发误差的方法。这个方法不满足正交化的要求，使用此方法时需要多多注意。</p>
<h2 id="设置目标"><a href="#设置目标" class="headerlink" title="设置目标"></a>设置目标</h2><h3 id="单一指标"><a href="#单一指标" class="headerlink" title="单一指标"></a>单一指标</h3><p>在分类任务中，一般有下面这两种评价指标：</p>
<ul>
<li>精确率（precision, 又称查准率）：所有识别为猫的图片中，究竟有多少确实是猫？</li>
<li>召回率（recall, 又称查全率）：所有猫的图片中，有多少猫被正确识别了？</li>
</ul>
<blockquote>
<p>注意，我们之前代码实战中用的准确率(accuracy)和精确率(precision)不是一个指标。</p>
</blockquote>
<p>现在，假设有两个模型，它们在开发集上的评估结果如下：</p>
<ul>
<li>模型1：精确率95%，召回率90%。</li>
<li>模型2：精确率98%，召回率85%。</li>
</ul>
<p>二者在精确率和召回率上各有优劣，该怎么从中选一个更好的模型出来呢？</p>
<p>设置目标的一个原则是：只使用单一实数作为评价标准。因此，我们要想办法用一个指标把这两个指标都考虑进来。比如使用F1-score，它的公式如下：</p>
<script type="math/tex; mode=display">
F_1score = \frac{2}{\frac{1}{P}+\frac{1}{R}}</script><p>再看一个例子。假如我们开发好了几个算法，我们要用来自不同国家的数据去测试它们。不同算法在不同国家的数据上表现较好。为了快速选取一个最好的算法，我们可以去计算每个算法的表现平均值。</p>
<p><img src="/2022/07/03/DLS-note-8/3.jpg" alt></p>
<p>有了单一评价标准，我们就可以快速比较各个模型在开发集上的表现，并选择一个更好的模型。这样，我们开发的迭代速度也变快了。</p>
<h3 id="满足指标与优化指标"><a href="#满足指标与优化指标" class="headerlink" title="满足指标与优化指标"></a>满足指标与优化指标</h3><p>在有多个评价指标时，不是总能挑选出一个最恰当的综合指标的。比如评价某算法时既要考虑到准确率，又要考虑到运行时间。用一个综合指标来组合它们显然不太现实。这时，我们可以把指标分成<strong>满足指标</strong>和<strong>优化指标</strong>。</p>
<p>比如说，我们有这样几个算法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类器</th>
<th>准确率</th>
<th>运行时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>90%</td>
<td>80ms</td>
</tr>
<tr>
<td>B</td>
<td>92%</td>
<td>95ms</td>
</tr>
<tr>
<td>C</td>
<td>95%</td>
<td>1500ms</td>
</tr>
</tbody>
</table>
</div>
<p>算法C是挺好的，但是它相较A,B实在跑的太慢了。因此，我们可以设置以下的评价标准：</p>
<p><strong>满足</strong>运行时间≤100ms的前提下，<strong>最大化</strong>准确率。</p>
<p>这个标准既保证了运行时间不会太长，又能选出准确率较高的算法。按照这个标准，B应该是最优的分类器。</p>
<p>在这个例子中，准确率就是优化指标，运行时间就是满足指标。</p>
<p>这种新的选取指标的方法应该和之前提到的单一指标原则结合起来。准确来说，应该只有一个优化指标，外加若干个满足指标。</p>
<h3 id="训练-开发-测试的分布"><a href="#训练-开发-测试的分布" class="headerlink" title="训练/开发/测试的分布"></a>训练/开发/测试的分布</h3><p>开发集和评价指标，共同决定了我们的优化目标。因此，我们应该谨慎地选择各数据集的数据分布，防止优化目标跑偏。</p>
<p>举个例子，假如我们收集了来自不同地区的数据，有亚洲、欧洲……。假如我们令亚洲的数据为开发集，欧洲的数据为测试集，我们就可能会训练出一个在开发集上表现优秀，却在测试集上表现糟糕的模型。正确的做法是，我们把来自不同地区的数据打乱，把数据随机分成开发集和测试集。</p>
<p>还有一个改编自真实故事的例子。一个团队想开发根据某人的邮政编码预测他同意贷款的概率的算法。他们以中等收入地区的邮政编码为开发集，却以低收入地区的邮政编码为测试集。显然，在这两个地区的人同意贷款的概率会差很多。最后，这个团队花了3个月优化了算法在开发集上的表现，却发现模型在测试集上表现奇差，不得以推倒重来。</p>
<p>也就是说，我们应该让训练集和测试集能够反映我们将来实际应用时的数据，并且训练集和测试集都得来自同一个分布。设置开发集和评估指标，就像立了一个靶子一样。训练，就是让射出的箭更靠靶心。而测试集，应该反映我们期望箭射到的位置。我们既要知道箭应该射在哪里，还要把靶子摆对。</p>
<h3 id="开发集和测试集的大小"><a href="#开发集和测试集的大小" class="headerlink" title="开发集和测试集的大小"></a>开发集和测试集的大小</h3><blockquote>
<p>这些知识在第二周已经学过了，这里再强调一次。</p>
</blockquote>
<p>数据量小的时候（比如说数量级在万以下），我们可以按6:2:2的比例划分训练/开发/测试集。但数据量大的时候，就不用考虑比例了，按固定大小选择差不多大小的开发集和测试集即可。</p>
<p>那么，测试集要多大才够呢？从统计学的眼光来看，把测试集当成实际应用数据中的一个采样结果的话，我们应该保证测试集有很高的置信度能反映模型在实际应用中的综合表现。当然，对于简单的数据分布，我们可以用统计学知识严谨地算出置信度。而对于人工智能任务中用到的海量数据，数学工具就难以派上用场了。我们只能根据经验选择一个足够大的测试集。比如有百万级数据的话，一万个测试样本就够了。</p>
<h3 id="何时更换开发-测试集与评价指标"><a href="#何时更换开发-测试集与评价指标" class="headerlink" title="何时更换开发/测试集与评价指标"></a>何时更换开发/测试集与评价指标</h3><p>在算法投入应用后，我们可能会发现新的评价角度。比如对于小猫分类模型，我们本来只期望它能正确识别小猫。可是，随着使用应用的人变多，我们发现有的用户会上传色情图片。这时，我们不仅希望模型能只找出小猫，还要能过滤掉色情图片。</p>
<p>这样，我们就引入了一个新的评价指标。这样，之前辨认小猫能力强的模型，可能会在辨认色情图片上较差。</p>
<p>为了考虑这个新的评价指标，我们可以修改误差函数，用更高的权重加大色情图片分类错误的惩罚。</p>
<p>总结来说，当我们发现使用当前指标得出来的最优模型，与考虑到某些新因素后得到的最优模型不同时，我们就应该更换开发/测试集与评价指标了。</p>
<h2 id="与人类级表现比较"><a href="#与人类级表现比较" class="headerlink" title="与人类级表现比较"></a>与人类级表现比较</h2><h3 id="为什么是人类级表现"><a href="#为什么是人类级表现" class="headerlink" title="为什么是人类级表现"></a>为什么是人类级表现</h3><p>我们经常能看到AI与人类比较的新闻：什么AlphaGo在围棋上战胜人类了，什么在ImageNet上AI的分类准确率超过了人类啊，等等。除了博眼球的新闻外，业内同样也会时常将机器学习模型和人类比较。这是为什么呢？</p>
<p>在许多任务中，人类的表现都非常出色。当AI超过了人类后，往往也达到了这类问题的最优精度。在机器学习模型超过人类前，与人类比较有以下好处：</p>
<ol>
<li>获取人类标注的数据。</li>
<li>从手动误差分析中获得启发：为什么人就能做对？</li>
<li>更好地分析偏差与方差。</li>
</ol>
<p>其中，第1条是显然的，第2条会在下周介绍。接下来，我们看看第3条是怎么回事。</p>
<h3 id="可规避偏差"><a href="#可规避偏差" class="headerlink" title="可规避偏差"></a>可规避偏差</h3><blockquote>
<p>这个知识之前也学过了一点。</p>
</blockquote>
<p>如果一个模型的训练误差是8%，开发误差是10%，我们不一定说模型就存在这个偏差问题。有可能模型在训练集上已经几乎达到了最优的表现;</p>
<p><img src="/2022/07/03/DLS-note-8/4.jpg" alt></p>
<p>在判断一件事时，有可能因为信息的缺乏，最优的准确率也达不到100%，总会存在一些误差。这样的最小的误差叫做贝叶斯误差。人类的表现，通常可以用作贝叶斯误差的一个估计。</p>
<p>在刚才那个例子中，如果人类误差是1%，那么模型的训练误差还有7%的提升空间；而如果人类误差是7.5%，那说不定模型的训练误差只有0.5%的提升空间了。对于前者，我们应该关注偏差；关于后者，我们应该关注方差。这里讲到的7%, 0.5%的提升空间，可以称作<strong>可规避偏差</strong>。</p>
<h3 id="理解人类级表现"><a href="#理解人类级表现" class="headerlink" title="理解人类级表现"></a>理解人类级表现</h3><p>假如让人类来完成医学图片分类任务，人们得到了以下的分类误差：</p>
<p><img src="/2022/07/03/DLS-note-8/5.jpg" alt></p>
<p>从一个普通人，到一群有经验的医生，误差逐渐降低。那么，哪个误差算是人类级表现呢？</p>
<p>回顾上一节的内容，人类误差是贝叶斯误差的一个估计。因此，人类最优的表现，才应该被视作是人类误差。</p>
<p>当然，获取人类级表现的目的还是为了做偏差和方差分析。如果当前的训练误差是5%，那不管人类误差是1%，0.7%，还是5%，都差不多。而如果训练误差到了1%，甚至更低，那就要仔细地获取人类误差了。</p>
<h3 id="提升模型表现"><a href="#提升模型表现" class="headerlink" title="提升模型表现"></a>提升模型表现</h3><p>最后，再一次回顾一下如何减少偏差和方差。</p>
<p>机器学习有两大假设：模型能够很好地拟合训练集、模型能够泛化到开发/测试集上。它们分别对应偏差问题和方差问题。</p>
<p>训练误差和人类级表现之间的差是可规避偏差，开发集和训练集之间的差是方差。</p>
<p>训练更大的模型、训练更久/用更好的优化算法能够解决偏差问题。</p>
<p>使用更多数据、正则化能解决方差问题。</p>
<p>用更好的架构、超参数能同时解决这两个问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这节课涉及的新知识很少，大家就权当是复习了一下之前的知识。这节课大概学了这些东西：</p>
<ul>
<li>正交化</li>
<li>目标<ul>
<li>单一指标</li>
<li>满足指标与优化指标</li>
</ul>
</li>
<li>开发集与测试集<ul>
<li>分布</li>
<li>大小</li>
</ul>
</li>
<li>人类级表现<ul>
<li>贝叶斯误差</li>
<li>可规避偏差</li>
<li>提升模型表现的思路</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/07/02/20220702-gap-year/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/02/20220702-gap-year/" class="post-title-link" itemprop="url">风雨之巅尽是晴 | 985 CS 本科毕业放弃保研 gap 一年有感</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-02 19:47:57" itemprop="dateCreated datePublished" datetime="2022-07-02T19:47:57+08:00">2022-07-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%B0%88/" itemprop="url" rel="index"><span itemprop="name">杂谈</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%B0%88/%E6%95%A3%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">散文</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​<br>只有保研生参加的说明会结束后，大家都围着辅导员，焦急而欣喜地确认着自己的前程。待人群散开后，我走到辅导员身边，询问放弃保研的流程。</p>
<p>“只要写一张确认放弃保研的保证书即可。”</p>
<p>拿出先前准备好的纸笔，我流畅地写了几行字，提交了本专业唯一一份保研放弃书。</p>
<hr>
<p>2022年6月，没有季节之分的新加坡，却到了毒蚊肆虐的高峰期。我不幸感染病毒，前往南洋理工大学的校医院就诊。</p>
<p>诊断结束后，医生关切地说道：“你这几天就不要去听课了。我给你开假条。”</p>
<p>我笑道：“我是员工，不是学生。”</p>
<p>是啊，不论穿着、相貌、言行多像一名学生，现在的我，确确实实是一名员工。</p>
<p>离开诊所，望了望晴朗的天空，我忽然意识到，夏天来了。</p>
<p>如果是在国内的话，已经是夏天了吧？</p>
<p>应该是这样没错。去年的这个时候，学校里可热了。</p>
<p>全体学生聚在操场上的那一天，阳光正盛……</p>
<hr>
<p>去年，我还是学生。</p>
<p>糊里糊涂地完成了毕业设计，通过了答辩，时间已经悄悄来到了六月。</p>
<p>这一天，太阳不遗余力地展示起了夏天的风采。火辣辣的阳光直射在北京理工大学中关村校区的操场上，我穿着严实的学士服，感到异常闷热。我一会儿调整着学士帽的角度以遮挡阳光，一会儿又摘下帽子当扇子扇风。</p>
<p>不一会儿，主持人宣布了毕业典礼的开始。在酷热的今天，哪怕是一向讨厌集会的我，也静了下来，默默地听着演讲。</p>
<p>主持人开始念起各专业毕业学生的名单了。理论上，名单是包含了每一位同学的名字的。可为了节约时间，主持人念完前几位学生的名字后，就会以“等人”来略过后面的名字。</p>
<p>一个个陌生的名字，就像一声声倒计时。我深深地感受到了毕业离校的临近。</p>
<p>有的人保研成功，已经去实验室待了几个月。</p>
<p>有的人面试成功，正在做正式入职的准备。</p>
<p>有的人考研成功，和未来的导师刚打完招呼。</p>
<p>可我呢？</p>
<p>我该去哪呢？</p>
<p>造成现在的局面，真的都是我自己的错吗？</p>
<hr>
<p>不，我很早就想好自己的出路了。</p>
<p>早在大一，我就做好了出国留学的打算。</p>
<p>托福与GRE，硕士与博士。这些信息都我来说就如常识一般。</p>
<p>“先尝试科研，适合就读博士，不适合就读硕士。”</p>
<p>这是在综合了无数份信息后，得到的平均答案。</p>
<p>“大三开始在做科研，暑假去参加暑研。托福考试只有两年的有效期，也只能大三之后考。”</p>
<p>这也是平均而言的结论。</p>
<p>既然大家这么说，我也就这么做吧。</p>
<p>在快乐的算法竞赛中，我度过了大学的前两年。</p>
<hr>
<p>大三到了，该做留学的准备了。</p>
<p>刚从竞赛暑期集训中缓过来的我，错过了，或者说压根就没注意过某个学校官方的大三暑研项目。“错过就错过吧，反正大家的暑研都是自己找的。到寒假了再找吧。”我勉强安慰着迷茫的自己。</p>
<p>按照计划，我去找了本校的老师做科研，提前看一看自己是否适合做研究。老师本来说让一个博士生带我做点项目，后来渐渐就没了音讯。大三课业繁重，又有最后半年竞赛要打，我也无暇顾及科研的事情了。</p>
<p>熬过上半学期，在留学上毫无进展的我，开始回家过寒假。我计划一边套磁（方言，意为“套近乎”，特指在申请出国留学时，提前给导师发邮件推荐自己）暑研，一边开始语言考试的准备，希望能在下半学期考完语言考试。</p>
<p>突如其来的一场疫情，打乱了我的计划。</p>
<p>当然，之前那个官方暑研项目也泡汤了。我只能以此来安慰自己。</p>
<p>为了让自己看上去在做一些什么，每天一个人在楼下上完网课后，我总会去套磁一个教授。</p>
<p>之所以每天只向一个教授发邮件，是因为我害怕发邮件这件事。</p>
<p>点开学校主页，找到教授的研究方向，在一堆陌生的名词中拎出一两个，组织成一封“我对你的研究感兴趣，请让我参与暑研”的邮件。这一过程对我来说，是一件很惶恐而绝望的事情。</p>
<p>每看完一个教授的简历后，我就隐隐感到自己的背景是绝不可能申请上他的暑研的。可是，正如坠落山崖的人总想抓住什么一样，我还是不得不把邮件发出去。每发出一封邮件，我就像了了一桩大事一般，如释重负。可是，每发出一封邮件，我又能意识到，又少了一个可以套磁的教授，无教授可找的绝望又离我近了一分。</p>
<p>就这样，为了消化套磁每天带来的压力，我只敢一天发一封邮件。</p>
<p>每天向不同的人告白，告白前就已经意识到了失败。可是，还是要为明天的告白做准备。大概就是这样痛苦的感觉吧。</p>
<p>虽然我还没有可以自由选择方向的资格，但我只想做图形学的研究。可是，我之前几乎没有任何相关科研经历，也没有任何人脉。纯粹做图形学的教授也越来越少。想找到暑研的难度是极大的。</p>
<p>我的心情很矛盾。一方面，我为做图形学的教授很少，没有套磁目标而担忧；另一方面，我又为做图形学的教授很少，可以过滤掉一批做其他方向的教授以逃避发邮件而感到释怀。或许，我所谓“热爱图形学”只是一块遮羞布而已。我害怕前途未卜的未来，我害怕在黑暗中迷失，但我又害怕迈出脚步。我选择图形学，或许只是图形学的教授很少，套磁失败起来很快而已。套磁完所有只做图形学的教授，失败了，我就可以以“我已经努力过了”来安慰自己。、</p>
<p>事实也确实如我所预料得一样，只有一个教授回了我邮件——一封找了一个温柔而拙劣的理由把我拒绝的邮件。我再也不用去套磁了，再也不用忍受发邮件的煎熬了。可是，我所担心的没有去处的未来，正在向我一步一步逼近。</p>
<hr>
<p>大三下学期，我以“优等生”的姿态活着。</p>
<p>即使是网课，我也认真听着老师的讲解，认真完成着大作业。课余时间，我还继续在本校老师那做一点“科研”。</p>
<p>但是，我在留学上没有任何进展。</p>
<p>以“大三的作业太多”、“回学校后一切就能好起来”为借口，我暂时忘掉了留学这件事，舒服地过了几个月。</p>
<p>2020年年中，特朗普的一纸10043总统令，禁止某些中国高校的学生去美国留学，粉碎了无数学子的留学梦。历史的尘埃，恰恰就砸在了我们学校上。</p>
<p>听到这个消息，我的第一反应不是愤慨，不是焦虑，而是释怀：这下好了，大家都去不了美国了。</p>
<p>虽然我之前一直只打算申请美国的学校，但这个令我规划彻底失效的消息却使我获得了某种程度上的解脱。</p>
<p>是真的解脱了吗？还只是受到巨大打击之后的应激反应呢？</p>
<p>我不知道。</p>
<p>我只知道我必须要做一点什么，一定要迈出脚步。</p>
<p>我不想被无路可走的黑暗吞没。</p>
<p>有人说，这个留学禁令只会持续一年，明年的留学生肯定不受影响。我根本来不及仔细思考，立刻把这个判断奉为真理，继续之前的留学准备。</p>
<hr>
<p>我一直都在做一点什么。</p>
<p>没有暑研，我就在学期结束后立刻返校，捣鼓我那怎么都没有成果的“科研”。</p>
<p>正式开学后，我立刻开启了托福的准备。</p>
<p>我一直都在做一点什么。</p>
<p>但我真的什么都不想做。</p>
<p>但凡做起和留学相关的事，我就感到无比煎熬。开始做了一会儿后，巨大的负担就压在了我的心上。没办法，我必须要逃避。我的炉石传说酒馆战棋打到了一万多分。</p>
<p>但我还是觉得该做一些什么。</p>
<p>我勉强考出了过线的GRE，快要过线的托福。</p>
<p>我参与了本校教授和国外教授的合作科研项目。两位美国老教授高风亮节，视如己出，言传身教，令我彻底下定决心去读博士。他们虽然颇有名誉，但和我不是一个专业，在留学上给不了我功利性的帮助。即使如此，我依然非常感激他们。</p>
<p>我急匆匆地做好了材料准备，提交了数个学校的博士申请。</p>
<p>12月中旬，我提交完了所有美国学校的申请。</p>
<p>一切都结束了。</p>
<p>我不用再做一些什么了吧？</p>
<hr>
<p>只申请美国，只申请图形学，只申请博士。</p>
<p>我恐怕根本不是奔着成功留学去的，只是想做什么就做了什么而已。所谓“眼高手低”，大抵如此吧。</p>
<p>我是真的眼高手低吗？</p>
<p>聪明绝顶的我怎么可能没有对自己的一个客观认识。我知道，申请成功的概率微乎其微；我知道，六月之后即迎来“失学”的未来；我知道，我害怕失败，害怕无路可走的绝望。</p>
<p>但是，我更清楚我想要什么，不想要什么。</p>
<p>成功，不是美国顶尖学校的博士录取通知书，不是4.0的绩点，不是110分以上的托福分数，不是330分以上的GRE分数，不是光鲜亮丽的获奖记录，不是琳琅满目的论文发表记录。</p>
<p>成功，不是奖学金获得记录，不是年级第一的成绩，不是饱满的社会工作经历，不是“努力”、“感人”的苦学经历。当然，也不是我唯一能展示出来的，ACM金牌的获得记录。</p>
<p>成功，不是金钱，不是地位，不是权力，不是名誉，不是异性缘，不是房子，不是车子，不是你在哪国生活，不是你的照片多好看，不是你展示出来自己的生活过得有多好。</p>
<p>成功，是：我觉得成功，就是成功。</p>
<p>我觉得，只有做自己喜欢的事情，在自己喜欢的领域做出了令自己满意的成就，才叫成功。</p>
<p>打了三年左右的竞赛，大奖我拿的确实不多。但是，在这段时间里，我过得很开心。我触摸到了灵魂的兴奋点，初次体会到了人生的意义。</p>
<p>我害怕。</p>
<p>我害怕未来。</p>
<p>我害怕上不了学的未来。</p>
<p>我害怕申请失败上不了学的未来。</p>
<p>我害怕因为套磁不够积极导致申请失败上不了学的未来。</p>
<p>我害怕因为方向选得不够多套磁不够积极导致申请失败上不了学的未来。</p>
<p>因此，</p>
<p>我放弃。</p>
<p>我放弃思考。</p>
<p>我放弃人生规划的思考。</p>
<p>我放弃留学相关人生规划的思考。</p>
<p>我放弃寻找更合适的国内研究项目人生规划的思考。</p>
<p>我放弃套磁更多方向的教授寻找更合适的国内研究项目人生规划的思考。</p>
<p>但是，</p>
<p>我坚持。</p>
<p>我坚持底线。</p>
<p>我坚持人生价值的底线。</p>
<p>我坚持不随留学结果变动的人生价值的底线。</p>
<p>我坚持不肯妥协不随留学结果变动的人生价值的底线。</p>
<p>我坚持不肯妥协不随留学结果变动只为自己开心的人生价值的底线。</p>
<p>最终，我任性而顽固地在焦虑中失败了。不过，我也很庆幸，不管我的感受有多么糟糕，我在潜意识里依旧坚持了自己的底线。我没有为了留学而留学，也丝毫没有怀疑过自己对人生目标的判断。</p>
<hr>
<p>后来，我依然焦急地寻找着出路。</p>
<p>我知道自己为逃避选择而产生的任性是很不合理的。赶在截止日期之前，我去尝试申请了其他国家的学校，尝试申请了可以转成博士的研究型硕士。结果，时间已晚，剩余的机会并不多，我也没有申请成功。</p>
<p>我已经在积累压力和释放压力中循环多次了。写套磁信时积累压力，发邮件时释放压力；申请学校时积累压力，申请季结束后释放压力；等结果时积累压力，收到拒信时释放压力。这就像一个溺水的人，反复挣扎出水面，难得呼吸到一两口新鲜空气一样。那么，收到最后一封拒信时，就是我最后一次能够离开水面了。</p>
<p>但是，我依然没有放弃“生的希望”。或许在很早之前，我就已经在心里默认自己会踏上这条退路了。</p>
<p>这条退路就是gap，去实验室先当科研助理，积累背景，再去申请博士。</p>
<p>gap是一个从国外传来的词，表示毕业后不去上学，而是去玩个一两年。用中文来说的话，gap year可以翻译成“间隔年”。到了国内留学圈，gap的意思就变了。毕业之后，不管你是不是在享受没有学业的人生，只要你没有上学，就可以称为gap。当科研助理，是一种最常见的gap方式。</p>
<p>从大一就开始看留学经验分享的我，很早就知道了gap的存在。通过分析他人的gap经验，我也欣然接受了gap，做好了心理准备。或许我在留学季的种种挣扎，不过是自我欺骗而已。我内心早就放弃了本科直接申请博士。由于有这个底牌的存在，我可以索性破罐子破摔，只去追求小概率的自己想要的结果。</p>
<p>虽说是早就做好了心理准备，但被压力挤得喘不过气的我，还是慢慢吞吞而消极地进行着gap的计划。我本来做好了去一家公司的准备，就没有去找第二个选择了。可是，毕业前我想了解入职事项时，却发现我莫名其妙地被鸽了。</p>
<p>毕业典礼即将到来，我选择享受最后一刻的本科时光，搁置了gap的事。</p>
<p>本科毕业后，作为无业游民的我回到了家里，立刻开始了科研助理的套磁。</p>
<p>和之前的暑研套磁一样，申请科研助理也要用同样的方式发邮件申请岗位。一想起暑研，整个留学过程给我带来的压力的总和就扑面而来。同样，我的心理承受能力只允许我一天只发一两封邮件。</p>
<p>待在家里天天吃干饭，我肯定会被无尽的压力给冲垮。恰巧同学邀请我去毕业旅行，我欣然答应。不知怎地，我就是有一种能在旅游中申请成功的自信。</p>
<p>由于美国的学校都去不了了，现在我只能从其他国家入手。这次，我不再头铁了，从对ACM竞赛认可度最高的华人圈开始申请。同时，由于做图形学的人太少了，我决定扩大范围，也申请计算机视觉方向的研究。计算机视觉我也不讨厌，我会让自己尽快喜欢上这个领域，并且尽可能选择和图形学相关的细分方向。</p>
<p>我认真套了几个香港的教授，杳无音讯。我又看到南洋理工大学在招聘平台上正式招募科研助理，就顺手投了一份简历。正当我为没收到任何回信，准备进一步扩大方向的选择范围时，我申请得最不认真的南洋理工大学竟然向我发出了面试邀请。</p>
<p>说是面试，但这毕竟不是庄重的博士申请。能给科研助理的申请发面试机会，基本上就是决定要你了。我本来还准备了英文ppt和英文演讲腹稿，谁知面试开始后，老师亲切地对我说可以说中文。谈起选择我的理由时，老师说，像我这样有扎实的底层编程基础的人不多，而且我的博客写得很好。在轻松的氛围中，我们聊了聊我过去的经历，敲定了科研助理一事。由于疫情，新加坡签证管得严，我要等半年才能拿到签证。老师帮我先安排了一个和他的实验室有合作的国内工作岗位，就当是为之后的学习打基础。</p>
<p>没想到，这一次，如我所愿地，我在旅行中完成了套磁、科研助理面试、国内工作岗位面试。旅行的时间不短，在享受完旅行后没在家躺几天，我就得动身前往上海办入职了。</p>
<hr>
<p>七月底，我去上海人工智能实验室的OpenMMLab以全职员工的身份“实习”。也就是说，工资按正式员工的发，但是和实习生一样不待很长时间。大概六个月后，签证就会办好。</p>
<p>总算，我也是从学校迈向社会了。很幸运，OpenMMLab是混沌社会中的一块净土。OpenMMLab主要做的是开源项目，不以业务为导向，没有什么KPI的压力。同时，由于大组刚刚成立不久，同事的素质都很高。全职员工大多是名校硕士，实习生中有名校本科生，也有在读博士的科研大佬。</p>
<p>站在徐汇西岸智塔的高层，俯视着蓝天下的黄浦江，我有一种说不出来的畅快。这样开阔的风景，是矮小的校园里所见不到的。从这里望出去，哪怕是上海交通大学，也不过我眼睛里的一点而已。</p>
<p>公司里见到的，都是年轻的面孔。于其说是同事，倒是更像大学里的同学。可是，多数同事都已经工作多年，早已褪去了学生的稚嫩。从他们口中，听到的更多是人情冷暖。房子、车子、伴侣……尽是些我插不上嘴的话题。</p>
<p>作为工资可观，又随时准备走人的单身程序员，我的日子倒是逍遥得很。可是，同事们比我有更多的可待之物。即使公司的工作环境比其他许多地方都要舒适，他们依然觉得上班养家是一件很不容易的事情。从他们身上，我看到了自己可能的一个未来：我就这样一辈子生活在上海，结婚生子，悠闲度日……</p>
<p>然而，现在安逸的生活让我忘记了本科申请时的所有烦恼。我以前所未有的高效率生活着，对未来的人生也有了更多的期冀。既然看到了校园内看不到的风景，那就要树立本科时想不到的理想。</p>
<hr>
<p>说是全国最大的开源算法体系，也不过如此嘛。</p>
<p>不然，为什么重构代码库的事情，会让工作时间不过四个月的我来承担呢？</p>
<p>刚到公司时，我确实是懵懵懂懂的。我配开发环境配了一两天，给我开通企业微信又花了一周多，好不容易才安顿下来。</p>
<p>第一次小组会，我是以一个听众的身份参加的。ONNX Runtime、TensorRT、ncnn……这些犹如外星语的名词一个一个蹦出，令唯一一个听众感到战战兢兢：“这么多复杂的技术，我能学得过来吗？”</p>
<p>我们小组负责模型部署代码库的开发。学了一段时间的相关知识后，我发现，模型部署，可是光鲜的“算法”项目中最脏最累的活。对内，我们要对接数个计算机视觉的开源库；对外，我们又要使用数个运行深度学习模型的推理引擎。其他各个代码库之间不一致的地方，就要靠我们来硬生生地焊接起来。</p>
<p>这么琐碎的工作，自然也容易出现纰漏。正在学习我们的代码库时，我发现了一个bug。正好，我决定修复这个bug，作为我对我们组的第一份贡献。</p>
<p>提交代码，必须要使用到代码管理工具。本科时，我只会用傻瓜式的图形界面来使用Git这项代码管理工具。我们是做开源项目的，自然要把代码放到基于Git技术的GitHub开源代码平台上。由于经验不足，我只能在实践中慢慢学习Git的用法。</p>
<p>和组里的同时讨教过后，我修完了bug，并在自己电脑上完成了代码管理。之后，只剩下把代码提交到小组的代码平台，并把我写的那部分代码合入到整个代码库里了。我接下来的操作会改动代码库，一旦出了纰漏，肯定会引起很严重的后果。因此，我小心翼翼地进行着提交代码的操作。</p>
<p>提交完成后，代码库网站上突然出现了一个大大的红叉。这可把我吓坏了。我连忙向同事求救，一面拜托他们快点撤销掉我的操作，一面询问着正确的操作方法。还好，我错误的操作没有什么破坏性。原来，在使用Git和GitHub时，我不能直接向主代码库提交代码，而是应该先向自己克隆出的代码库提交代码。只要按照正确的步骤，重新操作一次就好了。</p>
<p>有惊无险地，我的第一份代码总算合入了整个项目中。虽然代码上的改动只有四五行，但我还是很骄傲地在下次组会上汇报了我的成就。小组领导也在会议记录上欣然记录下了我的这项产出，与其他人涉及上百行代码修改的成果一起。</p>
<p>提交完第一次代码之后，原先像城堡一样复杂的开源代码，在我眼里就成了一排排的破房子。我们的工作，不过是立几根杆子撑住快要倒塌的房子，又去旁边的土地上新建几座房子而已。</p>
<p>从提交几行代码修复小bug，到对接一个视觉算法库，我的贡献度逐渐向其他同事靠拢。几个月后，把略有难度的重构任务交给我，也算是自然而然的事。</p>
<p>为了完成重构，不阻碍他人的工作进度，我高压工作了几天。不过，我倒是不怎么感到疲惫——</p>
<p>我们的代码库要开源了。</p>
<hr>
<p>2021年的平安夜，上海下着小雨。街头的树上挂着灯饰，点亮了黑夜，也点亮了路旁的积水。街道仿佛笼罩在一片白雪之中，就和人们印象中的圣诞节一样。</p>
<p>到处都是圣诞节的氛围。我从公司楼下的商场走出，一路上看到了不少情侣。恰逢本周最后一个工作日，大家都早早地下班过节。不知怎地，在这种氛围的感染下，我望着天空，感到一丝惆怅。</p>
<p>大概是因为，下周一，我们的项目就要开源了吧。</p>
<p>虽说我们的项目叫做“开源项目”，但是在代码功能尚未齐全的早期，项目是在私有账号下闭源开发的。在基本功能差不多完备了后，大组领导会择一良辰吉日，隆重向世人宣布开源。最后一次开源评审的通过、宣传视频终稿的提交、暂停开发工作后无聊而紧张的查缺补漏……一切都预示着项目开源的到来。</p>
<p>周一的晚上，一切准备就绪。小组的各位都聚在同一台电脑前。</p>
<p>这些代码是属于谁的呢？</p>
<p>作为员工，这些代码应该是属于公司的吧。</p>
<p>作为开源项目，这些代码又应该属于整个开源社区的吧。</p>
<p>但是，此时此刻，这些代码就是只属于我们的作品。</p>
<p>按下确认开源代码库的按钮后，大家纷纷鼓起了掌。</p>
<p>随后，大家不约而同地转发了我们代码库开源的宣传文章。</p>
<p>我想，现在，其他几位同事的感受，应该和我是一样的。</p>
<p>过了几天，仗着OpenMMLab的名气，我们的代码库登上了GitHub Trending榜第一。</p>
<p>之后，我们的身份从纯粹的开发者，变成了时而回答社区问题的客服人员。</p>
<p>再之后，就过年了。</p>
<p>过年回来，没待两周，我就收到了新加坡签证通过的消息。我很快办好了离职。</p>
<p>虽说是离职了，但我也没能立刻就离开上海。我心安理得地放了一周的假，像相恋多年和平分手却又一时不习惯分离的情侣一样，天天在公司里吃了一顿又一顿的散伙饭。</p>
<p>在香港转机时，我们需要在机场就地过夜。</p>
<p>在明亮的大厅里，我睡不着，又想起了同样明亮的那个夜晚。</p>
<p>原来，令我惆怅的，是一月份的到来。从一月往前数六个月，就是由热转凉的七月啊。</p>
<hr>
<p>到了新加坡后，我很快就熟悉了学校里的生活。</p>
<p>去食堂点菜，刚掏出员工卡时，总有店家会向我确认道：“付款方式是学生卡吧？”我也总是点头默认。</p>
<p>被别人当成学生时，我总会很开心。 或许，我一直向往“学生”般天真烂漫、无拘无束的生活吧。</p>
<p>很幸运，现在，我正享受着这种生活。</p>
<p>我当了十六年学生，一直对众人口中所谓的“学习”嗤之以鼻。没想到，我却在不是学生的今天，体会到了真正的学习：没有家长，没有作业，没有考试，我可以出于热爱，为了自己而学习。在导师的计划下，除了完成实验室的项目外，我的主要任务就是从头认真学一遍深度学习，为以后的科研打下基础。</p>
<p>做着喜欢的事情，朝着理想一步一步迈进，这是我梦寐以求的生活。</p>
<p>没有学业的约束，没有最晚起床时间，能整天都抱着电脑。</p>
<p>其实，我现在有的条件，去年大四时也有。</p>
<p>这一年来，究竟是哪改变了呢？</p>
<p>我想，应该是心境吧。</p>
<hr>
<p>去年，我一直带着“前途未卜”这项异常状态。</p>
<p>虽说是一直有这么个东西压在心上，可从客观上来看，我大四一年的生活都没受到任何影响。该考试考试，该写论文写论文，该毕业毕业。一切都正常地进行着。</p>
<p>可是，毕业，对没有去处的我来说就像是世界末日一样。仿佛一毕业，一盆水就浇到了我人生的水彩画上，我拥有的一切都将褪色，消逝。我根本不敢考虑之后的事情。</p>
<p>我的感受，完全是自己创造出来的。我惧怕未来，所以给自己创造了一个险恶的心理环境。虽然我想挣扎着逃出，可每一项努力的失败，又在我心中下起了一阵阵暴雨。我在自己给自己设下的绝境中，无法自拔。</p>
<p>我口口声声说着自己不忌惮世俗的眼光，可到头来还是难以免俗。分数、论文数量、录取学校，这些东西都成我心中挥之不去的阴影。</p>
<p>我所谓做好了gap的准备，不过是自欺欺人。连现在的东西都不肯割舍，连未来的方向都不敢主动去寻找。我只是一直在被外界推着前进，而难以自己迈出脚步。</p>
<p>阻碍我的，是我自己的心境。</p>
<p>可是，当时的我真的就有能力去改变自己的心境吗？</p>
<p>做不到的。</p>
<p>当时的我，只能看到那些东西。</p>
<p>从学校到公司不过一个多月，我的心情就大有转变。显然，并不是我聪明了多少，或是坚强了多少。一切，都只是环境变了。</p>
<p>找到出路，不过是让我能够从泥潭中走出。而在半年的实习经验，则洗净了我身上的泥。</p>
<p>人的思考方式不可能在短期改变，能够快速改变的，只有身处的环境。环境的改变，有时更能让人产生思考、心境上的转变。</p>
<p>正是因为见到了从未见过的东西，我才能认识到之前的浅薄。如果当年在学校时，我能够多找一些有相同境遇的人交流，或是提前去社会里看看，又或是暂别学校好好清醒几天，说不定早就能够走出心理上的牢笼。</p>
<p>心境决定了感觉上的好恶，环境又很大程度上影响了心境。</p>
<p>面对心里的险境，一方面要看开一点，在更广的时间和空间上看待目前的处境；另一方面，不必去苛责自己，说不定换一个环境，一切都会好起来。</p>
<p>这世上所有与内心的苦难所斗争的人啊：</p>
<p>你们千万不要气馁。</p>
<p>人的一生，必然是伴随苦难的。小时候，有做不完的假期作业，父母老师的责骂，吓人的期末考试；长大了，有千军万马过独木桥的高考、考研，有毕业后逃不开的就业；再往后，还可能有破产、众叛亲离、疾病缠身。</p>
<p>苦难压得人喘不过气，让人想要逃避。</p>
<p>可是，逃避又有什么错呢？</p>
<p>遭遇苦难，必然是在追求自我超越的路途之中的。敢于去挑战困难，本来就不是一件容易的事。</p>
<p>那么，短暂的逃避，也不过是出于自我保护，为了让干涸的心灵多浸润几滴甘露而已。</p>
<p>真正的勇士，从来都不是一帆风顺的人。有拼搏，有苦难，有逃避，有自责，有前进。这样的人，才称得上是勇敢的。</p>
<p>我想，笼中之鸟，也梦想过展翅翱翔；井底之蛙，也畅想过圆形以外的世界。不论现状多么糟糕，不论视野多么受限，大家都不会放弃对美好的期盼。这时，不妨转换一下环境，调整自己的心境。说不定现在看来天都快塌下来的事情，在未来只是一桩笑谈。</p>
<p>未来，随着我能做到的越来越多，肯定会经历更大的挫折，面对更难的挑战。我也不能保证自己就不会再次陷入心情的低谷中。但是，无论何时，我都会坚持自己的追求。不论是从主观上改变对困难本身的看法，还是改变客观的环境让自己冷静下来，我会用种种手段来摆脱困境。因此，在未来，只会留下更多我战胜困难的事迹。</p>
<hr>
<p>保研说明会是在大四开学不久后召开的。当时，我连语言考试都没有准备好。说明会一结束，我就回去练听力了。如果能让现在的我给当时的自己带一句话，我会说：</p>
<p>池中寄卧又何妨，风雨之巅尽是晴。</p>
<h1 id="我的评论"><a href="#我的评论" class="headerlink" title="我的评论"></a>我的评论</h1><p>我本来是打算取得了某些成就后，再认真总结留学的心得的。恰逢上个月CSDN办了一场征文活动（活动的质量烂得一塌糊涂），我就随手写了一篇人生感想。等我以后确实有成就了，再写一篇有关CS PhD留学的思路指南。</p>
<p>这篇文章的质量很一般。用词还需要多加考究，事情完全贴合实际而少了一些阅读上的趣味，并且很多文字我是以演讲者的视角写的，念起来通顺但不严格符合语法。文章分了几次写完，行文中有不连贯之处。说理时略显僵硬，明明有很多方面的感想，却只能勉强揉成一团表达出来。倒是叙事结构上稍有构想，略微超出了我的平均写作水平。</p>
<p>但是，这篇文章最重要的，是文章内容中传递出来的“我”的心理活动，以及文字写作中传递出来的我的心理活动。这些感受都是很真切的。我觉得这是本文最宝贵的地方。</p>
<p>顺带一提，我是不怎么读书的，文学积累严重不足。为了写本文最后的诗句，我还特意去查一下格律，确保平仄没有写错。这两句话质量如何，我现在评价不了。但还是一样，它们蕴含了我的志气。</p>
<p>写这篇文章，我的主要目的是吹牛，试图收割流量。另外，我也很想把我的经历分享给更多的人。一方面，我知道大部分人都会经历和我类似的境遇，都会体会到孤立无援的感觉，相信这篇文章能给人启发；另一方面，我认为世界上广泛流传的价值观全是错的，我必须去宣传一些能让大家变得更好的思考方式。</p>
<p>希望大家读后能有所收获。</p>
<p>​</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/07/01/20220625-stylegan-introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/01/20220625-stylegan-introduction/" class="post-title-link" itemprop="url">用18支画笔作画的AI ~ StyleGAN特点浅析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-01 21:30:13" itemprop="dateCreated datePublished" datetime="2022-07-01T21:30:13+08:00">2022-07-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">记录</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%B0%E5%BD%95/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文阅读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>GAN（生成对抗网络）是一种能够自动生成内容的神经网络模型。近年来，许多图像生成的研究都基于GAN。</p>
<p>以人脸生成任务为例，一类常见图像GAN的原理如下：模型先要学会辨别一张图像是不是人脸。之后，模型会把一个个高维实数向量表示的“身份证号”映射成一幅幅图像，并根据辨别人脸的知识学习如何让图像长得更像人脸。最终，学习结束后，每一个“身份证号”都会映射到一张逼真的人脸上。只需要给模型一个随机的高维向量，模型就会生成一张人脸。</p>
<p>但是，使用这类图像GAN时，我们不能对图像生成的过程加以干预。也就是说，我们不知道神经网络是怎么把一个个向量映射成一张张栩栩如生的人脸的，而只能将其视作一个黑盒。因此，这些GAN只能用来随机地画出几张漂亮的画，搞搞大新闻，难以产生更加实际的应用。</p>
<p>对此，英伟达提出了可控的图像生成网络StyleGAN，引发了无数研究者的关注。在这个模型生成完一幅图像后，我们可以对图片进行由粗至精共18种微调：同样以人脸生成为例，我们既可以调整性别、年龄这种更宏观的属性，也能调整肤色、发色这种更具体的属性。下图是论文中展示的结果：</p>
<p><img src="/2022/07/01/20220625-stylegan-introduction/1.jpg" alt></p>
<p>最左侧一列是生成的图集A，最上方一行是生成的图集B。前三行、中间两行、最后一行分别是把图集B图像的高级、中级、低级属性混合进图集A图像得到的结果。</p>
<p>可以看出，混入高级属性，人脸的肤色得以保留，而五官、性别等特征被修改了；混入中级属性，人脸的性别、年龄得以保留，而脸部的轮廓被修改了；混入低级属性，人脸的样子几乎不变，而发色、肤色被修改了。StyleGAN确实能神奇地修改生成图像的各类属性。</p>
<p>那么，StyleGAN是如何用这18支“画笔”作画的呢？StyleGAN还有哪些出色的特性呢？我们能用StyleGAN开发出怎样的应用呢？在这篇文章里，让我们来认识一下StyleGAN的主要特点，并快速地用开源项目运行一下StyleGAN。</p>
<blockquote>
<p>本文不会对StyleGAN的原理进行详细的解读。在后续文章中，我会系统地讲解StyleGAN的论文及开源实现的使用方法。</p>
</blockquote>
<h1 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h1><h2 id="控制图像的风格"><a href="#控制图像的风格" class="headerlink" title="控制图像的风格"></a>控制图像的风格</h2><p>StyleGAN的名字里有一个”style”，该单词是“风格”的意思。这个单词在图像领域有一个特别的含义：一项神经网络风格迁移（Neural Style Transfer）的研究曾指出，图像可以看成是内容与风格的结合。即使是同一幅风景，不同艺术家也会画出不同风格的作品：</p>
<p><img src="/2022/07/01/20220625-stylegan-introduction/2.jpg" alt></p>
<blockquote>
<p>如果对神经网络风格迁移的经典论文感兴趣，欢迎阅读我之前写的<a href="https://zhouyifan.net/2022/06/01/20220531-styletransfer/">解读文章</a>。</p>
</blockquote>
<p>在那项研究中，人们发现，在由很多卷积层堆成的卷积神经网络中，越浅的层能表示越实际的风格，越深的层能表示越抽象的风格。受此启发，StyleGAN也使用了卷积神经网络来生成图像，并把“控制信号”放在了每个卷积层后。这样，只要调整“控制信号”，就能改变图像的风格了。StyleGAN的生成网络的部分结构如下：</p>
<p><img src="/2022/07/01/20220625-stylegan-introduction/3-2.jpg" alt></p>
<p>在这个网络中，”Const 4x4x512”表示一个恒定的数据块，该数据块的分辨率是4x4。网络会通过一系列操作，把这个数据块逐渐放大成一幅1024x1024的图像。”AdaIN”是一种运算，该运算受到表示风格的“控制信号”A的影响。”Conv 3x3”是普通的3x3卷积层。”Upsample”表示图像上采样2倍。</p>
<p>把图像从4x4翻倍放大至1024x1024，要翻倍8次，一共涉及9个模块的运算（一个模块就是图中的一个灰框）。而每个模块里又有2个AdaIN，所以，一共有18个调整图像风格的“控制信号”。这就是为什么我们可以说AI在用18支画笔作画。</p>
<p>那么，如何像开头所展示得一样，混合不同人脸的风格呢？这就要详细介绍一下“控制信号”的由来了。前面也提过，通常图像GAN需要输入一个高维实数向量，模型会根据这个向量来生成图像。在StyleGAN中，“控制信号”就来自于这个高维向量。默认情况下，所有“控制信号”都来自同一个高维向量。而如果令某些层的“控制信号”来自于另一个高维向量，就能产生<strong>风格混合</strong>的效果。前面提到把图像B的低级、高级特征混入图像A，其实就是用图像B代替图像A在网络的浅层、深层的“控制信号”。</p>
<p>为什么调整不同层的风格能够对图像产生不同程度的改变呢？可以这样想象：浅层的数据分辨率较低，只能记录图像的年龄、姿态这种更宏观的信息；而随着数据的分辨率不断放大，深层的数据已经逐渐记录下了人脸的形状，只剩下肤色、发色这种更具体的信息可供更改了。</p>
<p>实际上，从开头展示出来的图片中能够看出，风格混合并不是真的混合了图像的绘画风格，而是混合了图像的各种属性。出于对之前「神经风格迁移」论文中“风格”一词的统一描述，StyleGAN的论文沿用了“风格”一词。</p>
<p>除此之外，StyleGAN还有哪些特性呢？让我们看下去。</p>
<h2 id="随机调整图像细节"><a href="#随机调整图像细节" class="headerlink" title="随机调整图像细节"></a>随机调整图像细节</h2><p>在让计算机生成图像时，除了要求图像足够像某种事物外，最好还要能够随机改变图像的细节。比如对于一幅人脸照片来说，如果几束头发的位置发生了偏移，我们还是会认为这是原来那张照片。因此，我们希望生成出来的人脸在头发上的细节可以随机一点。</p>
<p>在传统的图像生成方法中，研究者总是得构造出一些巧妙的参数，通过随机改变这些参数让图像在内容大致不变的前提下调整细节。构造这些参数的过程是非常困难的。而对于StyleGAN来说，它的结构特别适合插入能够修改图像细节的<strong>噪声</strong>，让我们看一看StyleGAN生成网络完整的结构图：</p>
<p><img src="/2022/07/01/20220625-stylegan-introduction/3.jpg" alt></p>
<p>其实，在输入层或者卷积层后，还有一个与噪声B的加法操作。其中，B通常是从标准正态分布中随机生成的。对于同一个高维向量生成出的图像，改变噪声B会修改图像的细节：</p>
<p><img src="/2022/07/01/20220625-stylegan-introduction/4.jpg" alt></p>
<p>如图所示，改变噪声会改变头发的细节。实际上，噪声几乎不会影响整幅图片的观感，而只会改变头发、胡须、衣领等小细节。</p>
<p>通过改变噪声，我们能够从一幅照片的多个版本中找出一个细节最好的。此外，通过连续改变噪声，我们能够让图像发生连续的变化。这一特性很适合制作简单的2D动画。</p>
<h2 id="靠近平均图像"><a href="#靠近平均图像" class="headerlink" title="靠近平均图像"></a>靠近平均图像</h2><p>StyleGAN还有一个很好玩的应用：让生成的某张脸更加靠近大众脸。这一功能是怎么实现的呢？</p>
<p>对数字求平均值，得到的是所有数字的平均水平；对坐标求平均值，得到是一个平均位置。可是，该怎么对照片求平均值呢？如果只是把所有照片的像素值加到一起，再求平均值，肯定只会得到一幅乱糟糟的图像。而StyleGAN则提供了一种求平均图像的方法。</p>
<p>前面提过，GAN是靠一个高维向量表示的“身份证号”来生成图像的。StyleGAN通过一些映射操作，让高维向量的距离与生成出来的图片的相似度相关。也就是说，越近的向量，生成出来的图片就越像。因此，我们可以求出一堆向量的平均值，从而得到一幅平均图像。</p>
<p>有了平均图像，接下来就是如何让另一幅图像更靠近平均图像了。和前面一样的道理，相似的向量能生成相似的图像，那么两个向量的平均值，就能几乎均等地表示两幅图的特性。理想情况下，如果一个向量表示“白发萝莉”，另一个向量表示“黑发熟女”，那么它们的平均向量应该表示“银发少女”。当然，如果不使用平均值，而是使用其他和为1的加权方式，就能让中间的图像更靠近另外某幅图像了。这一操作叫做图像插值。</p>
<p>有了平均图像，有了图像插值方法，就可以一幅图像更靠近平均图像了。下面是几个插值示例图，其中$\psi$表示原图像的加权权重：</p>
<p><img src="/2022/07/01/20220625-stylegan-introduction/5.jpg" alt></p>
<p>$\psi=1$表示随机生成的原图像，$\psi=0$就是平均图像，$\psi&lt;0$表示图像往平均图像“相反”的方向移动得到的图像。</p>
<p>可以看出，随着人像不断靠近平均，甚至往反的方向移动，人像的整体内容都在平滑地改变。比较有趣的是，当人像反向后，人物的性别都反过来了。</p>
<p>从这个例子能看出，StyleGAN使用的输入向量隐含了语义上的信息。通过对输入向量进行简单的数学操作，就能让生成出来的图像朝有意义的方向改变。</p>
<h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>通过认识StyleGAN的网络结构，我们了解了StyleGAN的两大输入：表示风格的高维向量与随机扰动图像的噪声。通过修改这些输入，图像会发生不同程度的改变。</p>
<p>基于这些基本操作，我们可以开发出许多图像编辑应用，比如风格混合、简单动画、图像插值、语义反向等。正是因为这些五花八门的图像编辑效果，许多研究者都尝试对StyleGAN的功能进行改进与拓展，发表了很多有趣的科研工作。</p>
<p>令一方面，由于GAN的生成内容取决于训练数据。如果我们用人脸以外的图片作为训练集，就可以让AI画出其他物体来，比如动漫头像、小猫、汽车、酒店房间。这样，就可以开发出人脸编辑之外的应用了。</p>
<p>如果你想直观地体会StyleGAN的效果，可以查看StyleGAN作者发布的视频（在外网）。</p>
<p>如果你想立刻跑一跑StyleGAN，别走开。在附录中，我会介绍如何利用开源项目快速运行StyleGAN。</p>
<p>这篇文章只是对StyleGAN非常粗浅的一个介绍。如果你想认真研究StyleGAN，欢迎阅读我之后发布的StyleGAN论文精读。</p>
<h1 id="快速运行StyleGAN"><a href="#快速运行StyleGAN" class="headerlink" title="快速运行StyleGAN"></a>快速运行StyleGAN</h1><p><a target="_blank" rel="noopener" href="https://github.com/open-mmlab">OpenMMLab</a>的<a target="_blank" rel="noopener" href="https://github.com/open-mmlab/mmgeneration">MMGeneration</a>用PyTorch实现了StyleGAN并提供了模型权重文件。让我们看看该怎样快速运行StyleGAN。</p>
<blockquote>
<p>我使用的MMGen版本是0.7.1</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>访问<a target="_blank" rel="noopener" href="https://mmgeneration.readthedocs.io/en/latest/get_started.html">官方文档</a>，按照教程装好mmgen。</p>
<p>安装大致分以下几步：</p>
<ol>
<li>装PyTorch。</li>
<li>装mmcv。</li>
<li>装mmgen。</li>
</ol>
<h2 id="下模型权重文件"><a href="#下模型权重文件" class="headerlink" title="下模型权重文件"></a>下模型权重文件</h2><p>在<a target="_blank" rel="noopener" href="https://github.com/open-mmlab/mmgeneration/tree/master/configs/styleganv1">这个网站</a>里找到模型的下载链接。</p>
<p><img src="/2022/07/01/20220625-stylegan-introduction/6.jpg" alt></p>
<p>模型名称中最后的数字表示生成图像的分辨率。按照需要，点击某个模型后面的”model”，下载权重文件。</p>
<p>权重文件下载好了后，推荐放到代码仓库的<code>checkpoints</code>目录下。</p>
<h2 id="运行模型"><a href="#运行模型" class="headerlink" title="运行模型"></a>运行模型</h2><p>在某目录下（比如代码仓库的<code>work_dirs</code>目录下）新建并编写Python文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mmgen.apis <span class="keyword">import</span> init_model, sample_unconditional_model</span><br><span class="line"><span class="keyword">import</span> mmcv</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> utils</span><br><span class="line"></span><br><span class="line">config_file = <span class="string">&quot;configs/styleganv1/styleganv1_ffhq_1024_g8_25Mimg.py&quot;</span></span><br><span class="line">checkpoint_file = <span class="string">&quot;checkpoints/styleganv1_ffhq_1024_g8_25Mimg_20210407_161627-850a7234.pth&quot;</span></span><br><span class="line">device = <span class="string">&quot;cuda:0&quot;</span></span><br><span class="line"></span><br><span class="line">model = init_model(config_file, checkpoint_file, device)</span><br><span class="line">results = sample_unconditional_model(model, <span class="number">16</span>)</span><br><span class="line">results = (results[:, [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]] + <span class="number">1.</span>) / <span class="number">2.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># save images</span></span><br><span class="line">mmcv.mkdir_or_exist(<span class="string">&#x27;work_dirs/styleganv1&#x27;</span>)</span><br><span class="line">utils.save_image(results, <span class="string">&#x27;work_dirs/styleganv1/output.png&#x27;</span>, nrow=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>稍微解释一下这段代码。<code>init_model</code>用于新建一个模型，该函数有三个参数：配置文件<code>config_file</code>、权重文件<code>checkpoint_file</code>、运行设备<code>device</code>。配置文件放在仓库的<code>configs/styleganv1</code>目录下，根据刚刚下载的权重文件，选择配套的配置文件，修改<code>config_file</code>即可。<code>checkpoint_file</code>要填写刚刚下载好的权重文件的路径。<code>device</code>是运行的设备，有GPU的话写<code>cuda:0</code>即可。</p>
<p><code>sample_unconditional_model</code>用于随机生成一些向量，并用这些向量来生成图片。该函数第一个参数是模型，第二个参数是生成图像的数量。</p>
<p>图像生成完毕后，数据范围是<code>(-1, 1)</code>，我们要把它转换成数据范围是<code>(0, 1)</code>的图像。同时，为了兼容输出图像的API，我们还要把颜色通道反向。</p>
<p>最后，调用创建文件夹和保存图片的API，把所有输出图片以网格形式保存到某个文件中。</p>
<p>执行这个Python脚本后，我们就能得到分布在4x4网格中的16幅人脸图像了。我得到的一个结果是：</p>
<p><img src="/2022/07/01/20220625-stylegan-introduction/6.png" alt></p>
<p>注意！虽然大部分情况下生成器的表现都挺不错，但它偶尔会生成一些很吓人的图像（比如右上角那张史莱姆人）。大家看输出结果前一定要做好心理准备！</p>
<hr>
<p>这段代码仅仅展示了StyleGAN生成图像的基本功能。在后续的论文解读文章中，我还会继续介绍如何利用mmgen实现StyleGAN的各种花式应用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/07/01/20220701-pytorchinstall2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/01/20220701-pytorchinstall2/" class="post-title-link" itemprop="url">Windows/Linux安装PyTorch并实现多分类任务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-01 11:56:55" itemprop="dateCreated datePublished" datetime="2022-07-01T11:56:55+08:00">2022-07-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>姊妹篇：<a href="https://zhouyifan.net/2022/06/27/DLS-note-7-2/。">https://zhouyifan.net/2022/06/27/DLS-note-7-2/。</a></p>
<h1 id="安装PyTorch"><a href="#安装PyTorch" class="headerlink" title="安装PyTorch"></a>安装PyTorch</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>配编程环境考察的是利用搜索引擎的能力。在配环境时，应该多参考几篇文章。有英文阅读能力的应该去参考官方给的配置教程。出了问题把问题的出错信息放到搜索引擎上去查。一般多踩几次坑，多花点时间，环境总能配好。</p>
<p>本文只能给出一个大概率可行的指导，不能覆盖所有情况。如果在执行本文的安装步骤时出了问题，请灵活使用搜索引擎。</p>
<p>配置深度学习编程框架时，强烈推荐配置GPU版本。本文会介绍PyTorch GPU版本的配置。如果只想用CPU版本的话，跳过“CUDA与cuDNN”一节即可。</p>
<p>本文会同时介绍Windows和Linux下的安装方法。二者操作有区别的地方本文会特别强调，若没有强调则默认二者处理方法一致。</p>
<h2 id="CUDA与cuDNN"><a href="#CUDA与cuDNN" class="headerlink" title="CUDA与cuDNN"></a>CUDA与cuDNN</h2><p>CUDA是NVIDIA显卡的GPU编程语言。cuDNN是基于CUDA编写的GPU深度学习编程库。在使用深度学习编程框架时，我们一般都要装好CUDA和cuDNN。</p>
<p>这个安装步骤主要分三步：</p>
<ol>
<li>装显卡驱动</li>
<li>装CUDA</li>
<li>装cuDNN</li>
</ol>
<p>其中，显卡驱动一般不需要手动安装，尤其是在自带了NVIDIA显卡的Windows电脑上。</p>
<h3 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h3><p>用<code>nvidia-smi</code>查看电脑的CUDA驱动最高支持版本。下图标出了命令运行成功后该信息所在位置：</p>
<p><img src="/2022/07/01/20220701-pytorchinstall2/DLS-note-7-2/2.jpg" alt></p>
<p>如果命令能成功运行，记住这个信息。</p>
<p>如果这个命令失败了，就说明电脑需要重新安装显卡驱动。现在（2022年）CUDA的主流版本都是11.x，如果你发现驱动支持的最高版本偏低，也可以按照下面的步骤重新安装显卡驱动。</p>
<p>访问NVIDIA驱动官网：<a target="_blank" rel="noopener" href="https://www.nvidia.cn/geforce/drivers/">https://www.nvidia.cn/geforce/drivers/</a>  。在网站上，输入显卡型号和操作系统等信息，即可找到对应的驱动安装程序。</p>
<p>对于Windows，下载的是一个有GUI的安装器；对于Linux，下载的是一个shell脚本。如果你用的是Linux服务器，没有图形接口，可以先复制好下载链接，之后用<code>wget</code>下载脚本。</p>
<p>之后，运行安装器，按照指引即可完成驱动的安装。</p>
<p>注意，如果是带图形界面的Linux系统，可能要关闭图像界面再安装驱动。比如对于Ubuntu，一般要关闭nouveau再重启。请参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59618999">https://zhuanlan.zhihu.com/p/59618999</a> 等专门介绍Ubuntu显卡驱动安装的文章。</p>
<p>能够执行<code>nvidia-smi</code>后，执行该命令，找到驱动支持的最高CUDA版本。</p>
<h3 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h3><p>首先，我们要定一个CUDA安装版本。</p>
<p>CUDA安装版本的第一个限制是，该版本不能大于刚刚在<code>nvidia-smi</code>中获取的最高CUDA版本。</p>
<p>第二个限制是，PyTorch版本必须支持当前CUDA版本。在 <a target="_blank" rel="noopener" href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a> 中，有许多安装命令。每条Linux和Windows的安装命令中，有一条<code>cudatoolkit=x.x</code>的参数。这个参数表示的是当前PyTorch版本一定支持的CUDA版本。当然，并不是其他版本就不支持，一般新CUDA版本会向旧版的兼容。为了保险，可以尽可能和安装命令中的CUDA版本对齐。</p>
<p>由于开发环境中可能会安装多个编程框架（TensorFlow，PyTorch），建议先安装一个比较常用、版本较高的CUDA，比如CUDA 11.1,11.2之类的。之后，让编程框架向CUDA版本妥协。</p>
<p>如果之后安装PyTorch后发现CUDA版本不对应，可以尝试升级PyTorch版本。如果PyTorch实在是支持不了当前的CUDA版本，最后再考虑降级当前的CUDA版本。</p>
<p>选好了CUDA版本后，去 <a target="_blank" rel="noopener" href="https://developer.nvidia.com/cuda-toolkit-archive">https://developer.nvidia.com/cuda-toolkit-archive</a> 上下载CUDA安装器。同样，Windows和Linux分别会得到GUI安装器和shell脚本。</p>
<p>装完CUDA后，再控制台上输入<code>nvcc -V</code>。<code>nvcc</code>是CUDA专用的编译器，<code>-V</code>用于查询版本。如果这个命令能够运行，就说明CUDA已经装好了。以下是<code>nvcc -V</code>的输出：</p>
<p><img src="/2022/07/01/20220701-pytorchinstall2/DLS-note-7-2/3.jpg" alt></p>
<h3 id="cuDNN"><a href="#cuDNN" class="headerlink" title="cuDNN"></a>cuDNN</h3><p>打开下载网站 <a target="_blank" rel="noopener" href="https://developer.nvidia.com/rdp/cudnn-download">https://developer.nvidia.com/rdp/cudnn-download</a> （最新版本） 或 <a target="_blank" rel="noopener" href="https://developer.nvidia.com/rdp/cudnn-archive">https://developer.nvidia.com/rdp/cudnn-archive</a> （历史版本）。注册账号并登录。</p>
<p>根据CUDA版本，找到合适版本的cuDNN。<a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/cudnn/archives/index.html">https://docs.nvidia.com/deeplearning/cudnn/archives/index.html</a> 这个网站列出了每个cuDNN版本支持的CUDA版本(Support Matrix)。一般来说，可以去找最新的cuDNN，看它是否兼容当前的CUDA版本。如果不行，再考虑降级cuDNN。一般来说，CUDA 11.x 的兼容性都很好。</p>
<p>选好了cuDNN版本后，去上面的下载网站上下载最新或某个历史版本的cuDNN。注意，应该下载一个压缩文件，而不应该下载一个可执行文件。比如对于所有的Linux系统，都应该下载”xxx for Linux x86_64 (Tar)”</p>
<p>装CUDA和cuDNN，主要的目的是把它们的动态库放进环境变量里，把头文件放到系统头文件目录变量里。因此，下一步，我们要把cuDNN的文件放到系统能够找到的地方。由于CUDA的库目录、包含目录都会在安装时自动设置好，一种简单的配置方法是把cuDNN的文件放到CUDA的对应目录里。</p>
<p>对于Windows，我们要找到CUDA的安装目录，比如<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2</code>。再找到刚刚cuDNN解压后的目录，比如<code>D:\Download\cudnn-11.1-windows-x64-v8.0.4.30\cuda</code>。把cuDNN目录下bin、include、lib里的文件分别复制到CUDA目录的对应文件夹中。</p>
<p>对于Linux，CUDA的安装目录一般是<code>/usr/local/cuda</code>。再找到cuDNN的解压目录，比如<code>~/Downloads/cudnn-linux-x86_64-8.4.0.27_cuda11.6-archive</code>。切换到cuDNN的根目录下，输入类似下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo cp include/* /usr/local/cuda/include</span><br><span class="line">sudo cp lib/lib* /usr/local/cuda/lib64</span><br><span class="line">sudo chmod a+r /usr/local/cuda/include/*</span><br><span class="line">sudo chmod a+r /usr/local/cuda/lib64/lib*</span><br></pre></td></tr></table></figure>
<p>该命令用于把所有cuDNN的相关文件暴力复制到cuda的对应目录下，并修改它们的访问权限。一定要注意一下该命令中的路径，如果路径不对应的话要修改上述命令，比如有些cuDNN的库目录不叫<code>lib</code>而叫<code>lib64</code>。</p>
<p>如果大家对操作系统熟悉的话，可以灵活地把复制改为剪切或者软链接。</p>
<h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h2><p>Anaconda可以让用户更好地管理Python包。反正大家都在用，我也一直在用。</p>
<p>无论是什么操作系统，都可以在这里下Anaconda：<br><a target="_blank" rel="noopener" href="https://www.anaconda.com/products/individual#Downloads">https://www.anaconda.com/products/individual#Downloads</a> </p>
<p>同样，Windows和Linux分别会得到GUI安装器和shell脚本。</p>
<p>下好了安装器后，按照默认配置安装即可。</p>
<p>安装完成后，下一步是打开有Anaconda环境的控制台。</p>
<p>在Windows下，点击任务栏中的搜索框，搜索Anaconda，打开<code>Anaconda Powershell Prompt (Anaconda)</code>或者<code>Anaconda Prompt (Anaconda)</code>。</p>
<p>在Linux下，新建一个命令行即可。</p>
<p>如果在命令行里看到了<code>(base)</code>，就说明安装成功了。</p>
<p>之后，要创建<strong>某个Python版本</strong>的虚拟环境，专门放我们用来做深度学习的Python库。该命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name &#123;env_name&#125; python=&#123;version&#125;</span><br></pre></td></tr></table></figure>
<p>比如我要创建一个名字叫<code>pt</code>，Python版本3.7的虚拟环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name pt python=3.7</span><br></pre></td></tr></table></figure>
<p>创建完成后，使用下面的命令进入虚拟环境：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate &#123;env_name&#125;</span><br></pre></td></tr></table></figure></p>
<p>我的命令是：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate pt</span><br></pre></td></tr></table></figure></p>
<p>如果在命令行前面看到了<code>(&#123;env_name&#125;)</code>，就算是成功了：</p>
<p><img src="/2022/07/01/20220701-pytorchinstall2/DLS-note-7-2/1.jpg" alt></p>
<blockquote>
<p>完成上述步骤后，在VSCode里用<code>ctrl+shift+p</code>打开命令面板，输入<code>select interpreter</code>，找到<code>Python: Select Interpreter</code>这个选项，选择刚刚新建好的虚拟环境中的Python解释器。这样，新建VSCode的控制台时，控制台就能自动进入到conda虚拟环境里了。</p>
</blockquote>
<h2 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h2><p>推荐直接去官网首页下载。在首页，可以找到稳定版、最新版、长期支持版在不同操作系统下用不同包管理器，不同设备（不同CUDA版本或CPU）的pytorch安装命令：</p>
<p><img src="/2022/07/01/20220701-pytorchinstall2/1.jpg" alt></p>
<p>这里选操作系统和编程语言没什么好讲的，包管理器也是最好选conda。要注意的就是PyTorch版本和CUDA版本。PyTorch版本最好选择稳定版和长期支持版（第一个和第三个）。同时，如前文所述，PyTorch和CUDA有一个大致的对应关系，最好能找到一个版本完美对应的安装命令。如果这里找不到合适的命令，可以去 <a target="_blank" rel="noopener" href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a> 找旧版PyTorch的安装命令。</p>
<p>比如我要装cuda11.1的LTS版PyTorch，查出来的命令是：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio cudatoolkit=11.1 -c pytorch-lts -c nvidia</span><br></pre></td></tr></table></figure><br>又比如我要装当前稳定版cuda11.3的PyTorch，查出来的命令是：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio cudatoolkit=11.3 -c pytorch</span><br></pre></td></tr></table></figure><br>去Anaconda的命令行里执行这样一句安装指令即可。</p>
<blockquote>
<p>如果下载速度较慢，请更换conda和pip的下载源。可参考的教程很多，比如 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011935830/article/details/10307">https://blog.csdn.net/u011935830/article/details/10307</a> 95。</p>
</blockquote>
<p>如果显卡驱动和conda都装好了，执行完上面的命令后，GPU版PyTorch也就装好了。打开Python，执行下面的命令（或者写一个<code>.py</code>文件再运行），即可验证GPU版安装是否成功。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available())</span><br></pre></td></tr></table></figure>
<p>如果输出了True，就说明GPU版的PyTorch安装成功了。</p>
<h1 id="用PyTorch实现多分类任务"><a href="#用PyTorch实现多分类任务" class="headerlink" title="用PyTorch实现多分类任务"></a>用PyTorch实现多分类任务</h1><p>每当学习一门新的编程技术时，程序员们都会完成一个”Hello World”项目。让我们完成一个简单的点集多分类任务，作为PyTorch的入门项目。这个项目只会用到比较底层的函数，而不会使用框架的高级特性，可以轻松地翻译成纯NumPy或者其他框架的实现。</p>
<p>在这个项目中，我们会学到以下和PyTorch有关的知识：</p>
<ul>
<li>PyTorch与NumPy的相互转换</li>
<li>PyTorch的常见运算（矩阵乘法、激活函数、误差）</li>
<li>PyTorch的初始化器</li>
<li>PyTorch的优化器</li>
<li>PyTorch维护梯度的方法</li>
</ul>
<p>我们将按照程序运行的逻辑顺序，看看这个多分类器是怎么实现的。</p>
<p>如果你看过我其他的代码实战文章，欢迎比较一下这些代码，看看相比NumPy，PyTorch节约了多少代码。同时可以看一看PyTorch和TensorFlow的区别。</p>
<p>欢迎在GitHub上面访问<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/MulticlassClassification">本项目</a>。</p>
<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>本项目中，我们要用到一个平面点数据集。在平面上，有三种颜色不同的点。我们希望用PyTorch编写的神经网络能够区分这三种点。</p>
<p><img src="/2022/07/01/20220701-pytorchinstall2/2.jpg" alt></p>
<p>在项目中，我已经写好了生成数据集的函数。<code>generate_points</code>能根据数据集大小生成一个平面点数据集。<code>generate_plot_set</code>能生成最终测试平面上每一个“像素”的测试集。使用这两个函数，得到的<code>X</code>的形状为<code>[2, m]</code>（因为是平面点，所以只有两个通道），<code>Y</code>的形状为<code>[1, m]</code>。<code>Y</code>的元素是0-2的标签，分别表示红、绿、蓝三种颜色的点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">train_X, train_Y = generate_points(<span class="number">400</span>)</span><br><span class="line">plot_X = generate_plot_set()</span><br><span class="line"></span><br><span class="line"><span class="comment"># X: [2, m]</span></span><br><span class="line"><span class="comment"># Y: [1, m]</span></span><br></pre></td></tr></table></figure>
<h2 id="数据预处理与PyTorch转换"><a href="#数据预处理与PyTorch转换" class="headerlink" title="数据预处理与PyTorch转换"></a>数据预处理与PyTorch转换</h2><p>我们刚刚得到的<code>X, Y</code>都是NumPy数组，我们要把它们转换成PyTorch认识的数据结构。</p>
<p>在PyTorch中，所有参与运算的张量都用同一个类表示，其类型名叫做<code>Tensor</code>。而在构建张量时，我们一般要用<code>torch.tensor</code>这个函数。不要把<code>torch.Tensor</code>和<code>torch.tensor</code>搞混了哦。</p>
<p>使用<code>torch.tensor</code>和使用<code>np.ndarray</code>非常类似，一般只要把数据传入第一个参数就行。有需要的话可以设置数据类型。对于<code>train_X</code>，可以用如下代码转换成torch的数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_X_pt = torch.tensor(train_X, dtype=torch.float32)</span><br></pre></td></tr></table></figure>
<p>而在使用<code>train_Y</code>时，要做一些额外的预处理操作。在计算损失函数时，PyTorch默认标签<code>Y</code>是一个一维整形数组。而我们之前都会把<code>Y</code>预处理成<code>[1, m]</code>的张量。因此，这里要先做一个维度转换，再转张量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_Y_pt = torch.tensor(train_Y.squeeze(<span class="number">0</span>), dtype=torch.long)</span><br></pre></td></tr></table></figure>
<p>经过上述操作，<code>X, Y</code>再被送入PyTorch模型之前的形状是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(train_X_pt.shape)</span><br><span class="line"><span class="built_in">print</span>(train_Y_pt.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># X: [2, m]</span></span><br><span class="line"><span class="comment"># Y: [m]</span></span><br></pre></td></tr></table></figure>
<h2 id="PyTorch多分类模型"><a href="#PyTorch多分类模型" class="headerlink" title="PyTorch多分类模型"></a>PyTorch多分类模型</h2><p>处理完了数据，接下来，我们就要定义神经网络了。在神经网络中，我们要实现初始化、正向传播、误差、评估这四个方法。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MulticlassClassificationNet</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, neuron_cnt: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.num_layer = <span class="built_in">len</span>(neuron_cnt) - <span class="number">1</span></span><br><span class="line">        self.neuron_cnt = neuron_cnt</span><br><span class="line">        self.W = []</span><br><span class="line">        self.b = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">            new_W = torch.empty(neuron_cnt[i + <span class="number">1</span>], neuron_cnt[i])</span><br><span class="line">            new_b = torch.empty(neuron_cnt[i + <span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">            torch.nn.init.kaiming_normal_(new_W, nonlinearity=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">            torch.nn.init.kaiming_normal_(new_b, nonlinearity=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">            self.W.append(torch.nn.Parameter(new_W))</span><br><span class="line">            self.b.append(torch.nn.Parameter(new_b))</span><br><span class="line">        self.trainable_vars = self.W + self.b</span><br><span class="line">        self.loss_fn = torch.nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>
<p>和之前一样，我们通过<code>neuron_cnt</code>指定神经网络包含输出层在内每一层的神经元数。之后，根据每一层的神经元数，我们就可以初始化参数<code>W</code>和<code>b</code>了。</p>
<p>使用PyTorch，我们可以方便地完成一些高级初始化操作。首先，我们用<code>torch.empty</code>生成一个形状正确的空张量。之后，我们调用<code>torch.nn.init.kaiming_normal_</code>的初始化函数。kaiming_normal就是He Initialization。这个初始化方法需要指定激活函数是ReLU还是LeakyReLU。我们之后要用ReLU，所以<code>nonlinearity</code>是那样填的。</p>
<p>初始化完成后，为了让torch知道这几个张量是用可训练的参数，我们把它们<br>构造成<code>torch.nn.Parameter</code>。这样，torch就会自动更新这些参数了。</p>
<p>最后，我们用<code>self.trainable_vars = self.W + self.b</code>记录一下所有待优化变量，并提前初始化一个交叉熵误差函数，为之后的优化算法做准备</p>
<h3 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h3><p>正向传播的写法很简单，只要在每层算一个矩阵乘法和一次加法，再经过激活函数即可（在这个神经网络中，隐藏层的激活函数默认使用ReLU）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">    A = X</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">        Z = torch.matmul(self.W[i], A) + self.b[i]</span><br><span class="line">        <span class="keyword">if</span> i == self.num_layer - <span class="number">1</span>:</span><br><span class="line">            A = F.softmax(Z, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A = F.relu(Z)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure><br>在这份代码中,<code>torch.matmul</code>用于执行矩阵乘法，等价于<code>np.dot</code>。和NumPy里的张量一样，PyTorch里的张量也可以直接用运算符<code>+</code>来完成加法。</p>
<p>做完了线性层的运算后，我们可以方便地调用<code>torch.nn.functional</code>里的激活函数完成激活操作。在大多数人的项目中，<code>torch.nn.functional</code>会被导入简称成<code>F</code>。PyTorch里的底层运算函数都在<code>F</code>中，而构造一个函数类（比如刚刚构造的<code>torch.nn.CrossEntropyLoss()</code>再调用该函数类，其实等价于直接去运行<code>F</code>里的函数。</p>
<p>值得一提的是，PyTorch会自动帮我们计算导数。因此，我们不用在正向传播里保存中间运算结果，也不用再编写反向传播函数了。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>由于之前已经初始化好了误差函数，这里直接就调用就行了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">self, Y, Y_hat</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.loss_fn(Y_hat.T, Y)</span><br></pre></td></tr></table></figure><br><code>self.loss_fn = torch.nn.CrossEntropyLoss()</code>就是PyTorch的交叉熵误差函数，它也适用于多分类。由于这个函数要求第一个参数的形状为<code>[num_samples, num_classes]</code>，和我们的定义相反，我们要把网络输出<code>Y_hat</code>转置一下。第二个输入<code>Y</code>必须是一维整形数组，我们之前已经初始化好了，不用做额外操作，PyTorch会自动把它变成one-hot向量。做完运算后，该函数会自动计算出平均值，不要再手动求一次平均。</p>
<h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>为了监控网络的运行结果，我们可以手写一个评估网络正确率和误差的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span>(<span class="params">self, X, Y, return_loss=<span class="literal">False</span></span>):</span></span><br><span class="line">    Y_hat = self.forward(X)</span><br><span class="line">    Y_predict = Y</span><br><span class="line">    Y_hat_predict = torch.argmax(Y_hat, <span class="number">0</span>)</span><br><span class="line">    res = (Y_predict == Y_hat_predict).<span class="built_in">float</span>()</span><br><span class="line">    accuracy = torch.mean(res)</span><br><span class="line">    <span class="keyword">if</span> return_loss:</span><br><span class="line">        loss = self.loss(Y, Y_hat)</span><br><span class="line">        <span class="keyword">return</span> accuracy, loss</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> accuracy</span><br></pre></td></tr></table></figure>
<p>首先，我们使用<code>Y_hat = self.forward(X)</code>，根据<code>X</code>算出估计值<code>Y_hat</code>。之后我们就要对<code>Y</code>和<code>Y_hat</code>进行比较了。</p>
<p><code>Y_hat</code>只记录了分类成各个类别的概率，用向量代表了标签。为了方便比较，我们要把它转换回用整数表示的标签。这个转换函数是<code>torch.argmax</code>。</p>
<p>和数学里的定义一样，<code>torch.argmax</code>返回令函数最大的参数值。而对于数组来说，就是返回数组里值最大的下标值。<code>torch.argmax</code>的第一个参数是参与运算的张量，第二个参数是参与运算的维度。<code>Y_hat</code>的形状是<code>[3, m]</code>，我们要把长度为3的向量转换回标签向量，因此应该对第一维进行运算（即维度0）。</p>
<p>得到了<code>Y_predict, Y_hat_predict</code>后，我们要比对它们以计算准确率。这时，我们可以用<code>Y_predict == Y_hat_predict</code>得到一个bool值的比对结果。PyTorch的类型比较严格，bool值是无法参与普通运算的，我们要用<code>.float</code>强制类型转换成浮点型。</p>
<p>最后，用<code>accuracy = torch.mean(res)</code>就可以得到准确率了。</p>
<p>由于我们前面写好了<code>loss</code>方法，计算loss时直接调用方法就行了。</p>
<h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>写完了模型，该训练模型了。下面是模型训练的主要代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">model: MulticlassClassificationNet,</span></span></span><br><span class="line"><span class="params"><span class="function">          X,</span></span></span><br><span class="line"><span class="params"><span class="function">          Y,</span></span></span><br><span class="line"><span class="params"><span class="function">          step,</span></span></span><br><span class="line"><span class="params"><span class="function">          learning_rate,</span></span></span><br><span class="line"><span class="params"><span class="function">          print_interval=<span class="number">100</span></span>):</span></span><br><span class="line">    optimizer = torch.optim.Adam(model.trainable_vars, learning_rate)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(step):</span><br><span class="line">        Y_hat = model.forward(X)</span><br><span class="line">        cost = model.loss(Y, Y_hat)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        cost.backward()</span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure>
<p>PyTorch使用一系列的优化器来维护梯度下降的过程。我们只需要用<code>torch.optim.Adam(model.trainable_vars, learning_rate)</code>即可获取一个Adam优化器。构造优化器时要输入待优化对象，我们已经提前存好了。</p>
<p>接下来，我们看<code>for s in range(step):</code>里每一步更新参数的过程。</p>
<p>在PyTorch里，和可学习参数相关的计算所构成的计算图会被动态地构造出来。我们只要普通地写正向传播代码，求误差即可。</p>
<p>执行完<code>cost = model.loss(Y, Y_hat)</code>，整个计算图就已经构造完成了。我们调用<code>optimizer.zero_grad()</code>清空优化器，用<code>cost.backward()</code>自动完成反向传播并记录梯度，之后用<code>optimizer.step()</code>完成一步梯度下降。</p>
<p>可以看出，相比完全用NumPy实现，PyTorch用起来十分方便。只要我们用心定义好了前向传播函数和损失函数，维护梯度和优化参数都可以交给编程框架来完成。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>做完了所有准备后，我们用下面的代码初始化模型并调用训练函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n_x = <span class="number">2</span></span><br><span class="line">neuron_list = [n_x, <span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>]</span><br><span class="line">model = MulticlassClassificationNet(neuron_list)</span><br><span class="line">train(model, train_X_pt, train_Y_pt, <span class="number">5000</span>, <span class="number">0.001</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><br>这里要注意一下，由于数据有三种类别，神经网络最后一层必须是3个神经元。</p>
<p>网络训练完成后，我们用下面的代码把网络推理结果转换成可视化要用的NumPy结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plot_result = model.forward(torch.Tensor(plot_X))</span><br><span class="line">plot_result = torch.argmax(plot_result, <span class="number">0</span>).numpy()</span><br><span class="line">plot_result = np.expand_dims(plot_result, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>运行完<code>plot_result = model.forward(torch.Tensor(plot_X))</code>后，我们得到的是一个<code>[3, m]</code>的概率矩阵。我们要用<code>torch.argmax(plot_result, 0)</code>把它转换回整型标签。</p>
<p>之后，我们对PyTorch的张量调用<code>.numpy()</code>，即可使用我们熟悉的NumPy张量了。为了对齐可视化API的格式，我用<code>expand_dims</code>把最终的标签转换成了<code>[1, m]</code>的形状。</p>
<p>完成了转换，只需调用我写的可视化函数即可看出模型是怎样对二维平面分类的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visualize(train_X, train_Y, plot_result)</span><br></pre></td></tr></table></figure>
<p>我的一个运行结果如下：</p>
<p><img src="/2022/07/01/20220701-pytorchinstall2/3.jpg" alt></p>
<p>只能说，神经网络实在太强啦。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这篇笔记中，我介绍了PyTorch在Windows/Linux下的从零安装方法，并且介绍了一个简单的PyTorch多分类项目。希望大家能通过这篇笔记，成功上手PyTorch。</p>
<p>项目链接：<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/MulticlassClassification">https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/MulticlassClassification</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/06/27/DLS-note-summary-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/27/DLS-note-summary-2/" class="post-title-link" itemprop="url">吴恩达《深度学习专项》第二阶段总结与第三阶段预览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-27 18:56:06" itemprop="dateCreated datePublished" datetime="2022-06-27T18:56:06+08:00">2022-06-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在过去的三周，我们学完了《深度学习专项》的第二门课《改进深度神经网络：调整超参数、正则化和优化》。这些知识十分零散，让我们用点技能点的方式回顾一下这些知识，同时评测一下自己的学习情况。复习完了后，我们来看看下一门课的学习内容。</p>
<h1 id="第二阶段回顾"><a href="#第二阶段回顾" class="headerlink" title="第二阶段回顾"></a>第二阶段回顾</h1><p>在本节中，你需要记下两个数字：技能点数和觉醒技能点数。</p>
<p>技能点获取规则：必须先点完基础的知识，再点进阶的知识。同级知识之间没有先后限制。同时，某些知识还有额外的前置条件。</p>
<h2 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h2><p><strong>浅尝（+1点）</strong></p>
<ul>
<li>数据集可以分成训练集、开发集、测试集三种。</li>
<li>数据量小时按比例划分，数据量大时只需要选少量数据用作开发集、测试集。</li>
<li><strong>开发集和测试集的区别：开发模型时不能偷看测试集的评估结果。</strong></li>
</ul>
<h2 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h2><p><strong>浅尝（+1点）</strong></p>
<ul>
<li>理解偏差和方差的基本意义。</li>
<li>能用二维点集分类的例子描述偏差问题和方差问题。</li>
<li>在知道了模型在训练集、开发集上的误差后，能够诊断模型存在的问题。</li>
</ul>
<p><strong>精通 - 解决偏差与方差问题（+1点）</strong></p>
<p>前置技能点：正则化</p>
<ul>
<li>面对偏差问题，常见的解法是使用的更复杂的模型提升参数量，并延长训练时间。</li>
<li>面对方差问题，常见的解法是增加数据（数量和质量）和正则化。</li>
<li>改变模型结构往往能同时解决这两个问题。</li>
</ul>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p><strong>浅尝（+1点）</strong></p>
<p>前置技能点：了解方差</p>
<ul>
<li>正则化的作用：缓解过拟合。</li>
<li>正则化的通用思想：防止网络过分依赖少量的某些参数。</li>
</ul>
<p><strong>入门 - 添加正则化项（+1点）</strong></p>
<p>在损失函数新加一项：</p>
<script type="math/tex; mode=display">
J(w, b) = \frac{1}{m}\Sigma_{i=1}^{m}L(\hat{y}, y) + \frac{\lambda}{2m}||w^2||_2</script><p>梯度下降时稍微修改一下参数的更新方法：</p>
<script type="math/tex; mode=display">
w :=(1-\frac{\alpha\lambda}{m})w-\alpha dw</script><p><strong>精通 - dropout（+1点）</strong></p>
<ul>
<li>dropout的思想：训练时随机丢掉某些激活输出。</li>
<li>dropout的实现：由随机数矩阵和失活概率算出一个bool矩阵，以此bool矩阵为mask与激活输出相乘。</li>
</ul>
<p><strong>博闻 - 其他正则化方法（+1点）</strong></p>
<ul>
<li>数据增强。</li>
<li>提前停止（early stopping)。</li>
<li>……</li>
</ul>
<p>若能够实现正则化项、dropout、提前停止，则获得<strong>1觉醒点</strong>。</p>
<h2 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h2><p><strong>浅尝（+0点）</strong></p>
<ul>
<li>知道参数要用比较小的值初始化。</li>
</ul>
<p><strong>入门（+1点）</strong></p>
<ul>
<li>了解梯度数值异常的原因：中间计算结果随网络层数指数级变化。</li>
<li>参数初始化可以令数据的方差尽可能靠近1，防止梯度异常问题。</li>
</ul>
<p><strong>精通（+1点）</strong></p>
<ul>
<li>知道如何添加参数初始化系数。</li>
<li>了解常见的初始化系数的选择方法，比如He、Xavier。</li>
</ul>
<p><strong>博闻（+1点）</strong></p>
<ul>
<li>看参数初始化的原论文，深入理解参数初始化的原理。</li>
</ul>
<h2 id="梯度检查"><a href="#梯度检查" class="headerlink" title="梯度检查"></a>梯度检查</h2><p><strong>精通（+1点）</strong></p>
<ul>
<li>知道梯度检查的数学公式。</li>
<li>实现简单模型的梯度检查。</li>
</ul>
<p><strong>博闻（+1点）</strong></p>
<ul>
<li>会用编程框架里的梯度检查以调试大模型里的梯度。</li>
</ul>
<h2 id="mini-batch"><a href="#mini-batch" class="headerlink" title="mini-batch"></a>mini-batch</h2><p><strong>入门（+1点）</strong></p>
<ul>
<li>知道mini-batch是怎么根据batchsize划分训练集的。</li>
<li>能够实现mini-batch。</li>
</ul>
<p><strong>精通（+2点）</strong></p>
<ul>
<li>mini-batch的加速原理：增加参数更新次数，同时不影响向量化运算的性能。</li>
<li>在实验中体会不同batchsize的效果，能灵活选择batchsize。</li>
</ul>
<h2 id="指数加权移动平均"><a href="#指数加权移动平均" class="headerlink" title="指数加权移动平均"></a>指数加权移动平均</h2><p><strong>入门（+1点）</strong></p>
<ul>
<li>移动平均数的作用。</li>
<li>指数加权移动平均的公式：$v_i=\beta v_{i-1} + (1 - \beta)t_i$。</li>
</ul>
<p><strong>精通（+1点）</strong></p>
<ul>
<li>大概明白为什么使用指数加权移动平均而不使用普通的移动平均。</li>
<li>偏差矫正的原理和实现。</li>
</ul>
<h2 id="高级梯度下降算法"><a href="#高级梯度下降算法" class="headerlink" title="高级梯度下降算法"></a>高级梯度下降算法</h2><p>前置知识：指数加权移动平均</p>
<p><strong>精通 - Momentum（+1点）</strong></p>
<ul>
<li>大致理解Momentum的思想。</li>
<li>掌握公式，能用代码实现，知道一般情况下超参数$\beta=0.9$。</li>
</ul>
<p><strong>精通 - RMSProp（+0点）</strong></p>
<ul>
<li>掌握公式，能用代码实现，知道有哪些超参数。</li>
</ul>
<p><strong>精通 - Adam（+2点）</strong></p>
<p>前置知识：Momentum, RMSProp</p>
<ul>
<li>掌握公式，能用代码实现，知道一般情况下超参数$\beta_1=0.9, \beta_2=0.999, \epsilon=10^{-8}$，基本不需要调参。</li>
</ul>
<p><strong>博闻（+1点）</strong></p>
<ul>
<li>阅读经典优化器的论文。</li>
<li>了解各优化器的由来，能直观理解各种优化算法的意义。</li>
</ul>
<p>实现Adam后，获得<strong>1觉醒点</strong>。</p>
<h2 id="学习率衰减"><a href="#学习率衰减" class="headerlink" title="学习率衰减"></a>学习率衰减</h2><p><strong>精通（+1点）</strong></p>
<ul>
<li>知道学习率衰减的意义。</li>
<li>了解几个常见的学习率衰减公式。</li>
</ul>
<p>尝试使用Mini-batch、高级优化算法、学习率衰减训练网络，比较各类改进梯度下降方法的效果，则获得<strong>1觉醒点</strong>。</p>
<h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><p><strong>浅尝（+1点）</strong></p>
<ul>
<li>明确自己的模型里有哪些超参数。</li>
<li>大概知道超参数的优先级，会先去尝试调学习率。</li>
</ul>
<p><strong>入门（+1点）</strong></p>
<ul>
<li>调参整体思想：随机选数，由粗至精。</li>
<li>不要均匀采样，而要根据参数的意义选择合适的搜索尺度。</li>
</ul>
<h2 id="批归一化"><a href="#批归一化" class="headerlink" title="批归一化"></a>批归一化</h2><p><strong>浅尝（+0点）</strong></p>
<ul>
<li>知道批归一化的存在。</li>
<li>知道深度学习框架有时默认附带批归一化操作。</li>
</ul>
<p><strong>入门（+1点）</strong></p>
<ul>
<li>知道批归一化的意义，与输入归一化的异同。</li>
<li>知道批归一化层有两个超参数。</li>
</ul>
<p><strong>精通（+1点）</strong></p>
<ul>
<li>知道批归一化的数学公式（正向传播、反向传播）。</li>
<li>知道批归一化在测试时的用法。</li>
</ul>
<p><strong>精通II（+1点）</strong></p>
<ul>
<li>动手实现批归一化</li>
</ul>
<p><strong>博闻（+1点）</strong></p>
<p>完成<strong>入门</strong>即可学习。</p>
<ul>
<li>了解其他的几种归一化(layer, group)。</li>
<li>知道不同归一化方法的优劣。</li>
</ul>
<h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><p><strong>浅尝（+1点）</strong></p>
<ul>
<li>多分类问题的定义。</li>
<li>知道多分类问题的输出、训练集标签与二分类有什么不同。</li>
</ul>
<p><strong>精通 - softmax（+1点）</strong></p>
<ul>
<li>softmax的公式定义。</li>
<li>如何在网络中使用softmax。</li>
<li>大致了解softmax为什么要做一步指数运算。</li>
</ul>
<p><strong>精通II - 实现带softmax的多分类网络（+1点）</strong></p>
<ul>
<li>one-hot编码转换。</li>
<li>实现多分类网络。</li>
<li>利用one-hot处理标签和输出结果，正确评测多分类网络。</li>
</ul>
<h2 id="初识Tensorflow"><a href="#初识Tensorflow" class="headerlink" title="初识Tensorflow"></a>初识Tensorflow</h2><p><strong>浅尝 - 编程框架（+1点）</strong></p>
<ul>
<li>知道编程框架能做什么事。</li>
<li>认识常见的编程框架。</li>
<li>知道选择编程框架的原则。</li>
</ul>
<p><strong>入门（+1点）</strong></p>
<ul>
<li>安装GPU版的TensorFlow。</li>
</ul>
<p><strong>精通（+2点，+1觉醒点）</strong></p>
<p>前置知识：多分类问题</p>
<ul>
<li>使用TensorFlow实现多分类网络。</li>
</ul>
<h1 id="第二阶段自评"><a href="#第二阶段自评" class="headerlink" title="第二阶段自评"></a>第二阶段自评</h1><p>在“回顾”一节中，共35个普通技能点，4个觉醒技能点。普通技能点主要表示课堂知识，以及少量的课堂上没讲到的可拓展知识点（我自己也拿不满），觉醒技能点主要表示对知识的综合实现与应用。让我们根据自己获得的技能点数，看看自己的学习情况。</p>
<h2 id="Level-0：乱搞一通"><a href="#Level-0：乱搞一通" class="headerlink" title="Level 0：乱搞一通"></a>Level 0：乱搞一通</h2><p>条件：<strong>技能点≤5</strong></p>
<p>评价：随便去拷贝了几份深度学习代码，跑通了，就以为自己会深度学习了。丝毫不去关心深度学习的基础知识。这样下去，学习和应用更难的深度学习技术时肯定会碰到很多困难。</p>
<h2 id="Level-1：初来乍到"><a href="#Level-1：初来乍到" class="headerlink" title="Level 1：初来乍到"></a>Level 1：初来乍到</h2><p>条件：<strong>6≤技能点≤15</strong></p>
<p>预估学习情况：大致获取了6个<strong>浅尝</strong>技能点和7个<strong>入门</strong>技能点，没有对知识做进一步的思考和实现。</p>
<p>评价：要学会使用深度学习编程框架，甚至复现出一些经典模型，了解入门知识就足够了。尽管如此，钻研更深的知识对深度学习项目的开发还是有很大的帮助的。</p>
<h2 id="Level-2：学有所成"><a href="#Level-2：学有所成" class="headerlink" title="Level 2：学有所成"></a>Level 2：学有所成</h2><p>条件：<strong>16≤技能点≤22</strong>。至少有1个觉醒点才能升级到Level 2。</p>
<p>预估学习情况：完全获取了6个<strong>浅尝</strong>技能点和7个<strong>入门</strong>技能点，深入理解了部分知识，进行过代码实现。</p>
<p>评价：非常棒！相信在这一过程中，你已经对部分知识有了更深的理解。第二阶段的所有知识都很重要，建议坚持下去，把所有知识都探究完。</p>
<h2 id="Level-3：登堂入室"><a href="#Level-3：登堂入室" class="headerlink" title="Level 3：登堂入室"></a>Level 3：登堂入室</h2><p>条件：<strong>23≤技能点≤32</strong>。至少有3个觉醒点才能升级到Level 3。</p>
<p>预估学习情况：完全获取了6个<strong>浅尝</strong>技能点和7个<strong>入门</strong>技能点，基本获取了17个<strong>精通</strong>知识点，对部分自己感兴趣的知识做了额外的探究。</p>
<p>评价：恭喜！学到这里，你可以说自己已经完全掌握了第二阶段的知识了。同时，在多个代码实现项目中，你也锻炼了编程能力，从代码的角度近距离接触了各项知识。相信这些学习经验会对你未来的学习和应用产生莫大的帮助。</p>
<h2 id="Level-4：学无止境"><a href="#Level-4：学无止境" class="headerlink" title="Level 4：学无止境"></a>Level 4：学无止境</h2><p>条件：<strong>33≤技能点≤35</strong>。至少有4个觉醒点才能升级到Level 4。</p>
<p>预估学习情况：学懂了除<strong>博闻</strong>外所有的知识点，对课堂中没有详细介绍的知识做了补充学习。同时，完成了大量的编程练习。</p>
<p>评价：很强。能做到这一步，说明你对深度学习的学习充满了兴趣。相信这一兴趣能够帮助在未来的学习中走得更远。</p>
<h2 id="成就"><a href="#成就" class="headerlink" title="成就"></a>成就</h2><p>此外，还要颁发两个成就：</p>
<p><strong>编程狂魔</strong>：获取4个觉醒点。</p>
<p><strong>百科全书</strong>：获取5个博闻知识点。</p>
<h1 id="第三阶段知识预览"><a href="#第三阶段知识预览" class="headerlink" title="第三阶段知识预览"></a>第三阶段知识预览</h1><p>经过了三周紧张的学习，我们学到了非常多硬核的深度学习知识，还完成了不少编程项目。</p>
<p>在《深度学习专项》的下一门课《组织深度学习项目》中，我们会用两周时间，轻松地学一些不那么困难的知识：</p>
<ul>
<li>机器学习改进策略的宗旨<ul>
<li>正交化</li>
</ul>
</li>
<li>设置改进目标<ul>
<li>评估指标</li>
<li>数据集划分的细节</li>
</ul>
</li>
<li>与人类表现比较<ul>
<li>为什么使用人类的表现</li>
<li>理解并利用人类表现</li>
<li>试图改进模型以超过人类的表现</li>
</ul>
</li>
<li>差错分析<ul>
<li>分析开发误差的由来</li>
<li>清理错标数据</li>
</ul>
</li>
<li>不匹配的训练与开发/测试集<ul>
<li>如何使用不同分布的数据</li>
<li>如何在这种情况下评估偏差与方差</li>
<li>解决数据不匹配问题</li>
</ul>
</li>
<li>完成多个任务<ul>
<li>迁移学习</li>
<li>多任务学习</li>
</ul>
</li>
<li>端到端学习<ul>
<li>什么是端到端学习</li>
<li>何时用端到端学习</li>
</ul>
</li>
</ul>
<p>从标题中也能大致看出，这些知识基本不涉及任何复杂的数学公式，学习起来应该会很轻松。不过，了解这些知识也是很有必要的。在搭建一个能解决实际问题的深度学习项目时，这些组织深度学习项目的经验往往能帮助到我们。让我们做好准备，迎接新课程的学习。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/06/27/DLS-note-7-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/27/DLS-note-7-2/" class="post-title-link" itemprop="url">吴恩达《深度学习专项》代码实战（七）：Windows/Linux安装TensorFlow并实现多分类任务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-27 16:22:23" itemprop="dateCreated datePublished" datetime="2022-06-27T16:22:23+08:00">2022-06-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="安装Tensorflow"><a href="#安装Tensorflow" class="headerlink" title="安装Tensorflow"></a>安装Tensorflow</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>配编程环境考察的是利用搜索引擎的能力。在配环境时，应该多参考几篇文章。有英文阅读能力的应该去参考官方给的配置教程。出了问题把问题的出错信息放到搜索引擎上去查。一般多踩几次坑，多花点时间，环境总能配好。</p>
<p>本文只能给出一个大概率可行的指导，不能覆盖所有情况。如果在执行本文的安装步骤时出了问题，请灵活使用搜索引擎。</p>
<p>配置深度学习编程框架时，强烈推荐配置GPU版本。本文会介绍TensorFlow GPU版本的配置。如果只想用CPU版本的话，跳过“CUDA与cuDNN”一节即可。</p>
<p>本文会同时介绍Windows和Linux下的安装方法。二者操作有区别的地方本文会特别强调，若没有强调则默认二者处理方法一致。</p>
<h2 id="CUDA与cuDNN"><a href="#CUDA与cuDNN" class="headerlink" title="CUDA与cuDNN"></a>CUDA与cuDNN</h2><p>CUDA是NVIDIA显卡的GPU编程语言。cuDNN是基于CUDA编写的GPU深度学习编程库。在使用深度学习编程框架时，我们一般都要装好CUDA和cuDNN。</p>
<p>这个安装步骤主要分三步：</p>
<ol>
<li>装显卡驱动</li>
<li>装CUDA</li>
<li>装cuDNN</li>
</ol>
<p>其中，显卡驱动一般不需要手动安装，尤其是在自带了NVIDIA显卡的Windows电脑上。</p>
<h3 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h3><p>用<code>nvidia-smi</code>查看电脑的CUDA驱动最高支持版本。下图标出了命令运行成功后该信息所在位置：</p>
<p><img src="/2022/06/27/DLS-note-7-2/2.jpg" alt></p>
<p>如果命令能成功运行，记住这个信息。</p>
<p>如果这个命令失败了，就说明电脑需要重新安装显卡驱动。现在（2022年）CUDA的主流版本都是11.x，如果你发现驱动支持的最高版本偏低，也可以按照下面的步骤重新安装显卡驱动。</p>
<p>访问NVIDIA驱动官网：<a target="_blank" rel="noopener" href="https://www.nvidia.cn/geforce/drivers/">https://www.nvidia.cn/geforce/drivers/</a>  。在网站上，输入显卡型号和操作系统等信息，即可找到对应的驱动安装程序。</p>
<p>对于Windows，下载的是一个有GUI的安装器；对于Linux，下载的是一个shell脚本。如果你用的是Linux服务器，没有图形接口，可以先复制好下载链接，之后用<code>wget</code>下载脚本。</p>
<p>之后，运行安装器，按照指引即可完成驱动的安装。</p>
<p>注意，如果是带图形界面的Linux系统，可能要关闭图像界面再安装驱动。比如对于Ubuntu，一般要关闭nouveau再重启。请参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59618999">https://zhuanlan.zhihu.com/p/59618999</a> 等专门介绍Ubuntu显卡驱动安装的文章。</p>
<p>能够执行<code>nvidia-smi</code>后，执行该命令，找到驱动支持的最高CUDA版本。</p>
<h3 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h3><p>首先，我们要定一个CUDA安装版本。</p>
<p>CUDA安装版本的第一个限制是，该版本不能大于刚刚在<code>nvidia-smi</code>中获取的最高CUDA版本。</p>
<p>第二个限制是，TensorFlow版本必须支持当前CUDA版本。在 <a target="_blank" rel="noopener" href="https://www.tensorflow.org/install/source#gpu">https://www.tensorflow.org/install/source#gpu</a> 中，可以找到TensorFlow与CUDA、cuDNN的版本对应表。这个表格仅表示了经过测试的CUDA版本，不代表其他CUDA版本就一定不行。</p>
<p>由于开发环境中可能会安装多个编程框架（TensorFlow，PyTorch），建议先安装一个比较常用、版本较高的CUDA，比如CUDA 11.1,11.2之类的。之后，让编程框架向CUDA版本妥协。</p>
<p>如果之后安装TensorFlow后发现CUDA版本不对应，可以尝试升级TensorFlow版本。如果TensorFlow实在是支持不了当前的CUDA版本，最后再考虑降级当前的CUDA版本。</p>
<p>选好了CUDA版本后，去 <a target="_blank" rel="noopener" href="https://developer.nvidia.com/cuda-toolkit-archive">https://developer.nvidia.com/cuda-toolkit-archive</a> 上下载CUDA安装器。同样，Windows和Linux分别会得到GUI安装器和shell脚本。</p>
<p>装完CUDA后，再控制台上输入<code>nvcc -V</code>。<code>nvcc</code>是CUDA专用的编译器，<code>-V</code>用于查询版本。如果这个命令能够运行，就说明CUDA已经装好了。以下是<code>nvcc -V</code>的输出：</p>
<p><img src="/2022/06/27/DLS-note-7-2/3.jpg" alt></p>
<h3 id="cuDNN"><a href="#cuDNN" class="headerlink" title="cuDNN"></a>cuDNN</h3><p>打开下载网站 <a target="_blank" rel="noopener" href="https://developer.nvidia.com/rdp/cudnn-download">https://developer.nvidia.com/rdp/cudnn-download</a> （最新版本） 或 <a target="_blank" rel="noopener" href="https://developer.nvidia.com/rdp/cudnn-archive">https://developer.nvidia.com/rdp/cudnn-archive</a> （历史版本）。注册账号并登录。</p>
<p>根据CUDA版本，找到合适版本的cuDNN。<a target="_blank" rel="noopener" href="https://docs.nvidia.com/deeplearning/cudnn/archives/index.html">https://docs.nvidia.com/deeplearning/cudnn/archives/index.html</a> 这个网站列出了每个cuDNN版本支持的CUDA版本(Support Matrix)。一般来说，可以去找最新的cuDNN，看它是否兼容当前的CUDA版本。如果不行，再考虑降级cuDNN。一般来说，CUDA 11.x 的兼容性都很好。</p>
<p>选好了cuDNN版本后，去上面的下载网站上下载最新或某个历史版本的cuDNN。注意，应该下载一个压缩文件，而不应该下载一个可执行文件。比如对于所有的Linux系统，都应该下载”xxx for Linux x86_64 (Tar)”</p>
<p>装CUDA和cuDNN，主要的目的是把它们的动态库放进环境变量里，把头文件放到系统头文件目录变量里。因此，下一步，我们要把cuDNN的文件放到系统能够找到的地方。由于CUDA的库目录、包含目录都会在安装时自动设置好，一种简单的配置方法是把cuDNN的文件放到CUDA的对应目录里。</p>
<p>对于Windows，我们要找到CUDA的安装目录，比如<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2</code>。再找到刚刚cuDNN解压后的目录，比如<code>D:\Download\cudnn-11.1-windows-x64-v8.0.4.30\cuda</code>。把cuDNN目录下bin、include、lib里的文件分别复制到CUDA目录的对应文件夹中。</p>
<p>对于Linux，CUDA的安装目录一般是<code>/usr/local/cuda</code>。再找到cuDNN的解压目录，比如<code>~/Downloads/cudnn-linux-x86_64-8.4.0.27_cuda11.6-archive</code>。切换到cuDNN的根目录下，输入类似下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo cp include/* /usr/local/cuda/include</span><br><span class="line">sudo cp lib/lib* /usr/local/cuda/lib64</span><br><span class="line">sudo chmod a+r /usr/local/cuda/include/*</span><br><span class="line">sudo chmod a+r /usr/local/cuda/lib64/lib*</span><br></pre></td></tr></table></figure>
<p>该命令用于把所有cuDNN的相关文件暴力复制到cuda的对应目录下，并修改它们的访问权限。一定要注意一下该命令中的路径，如果路径不对应的话要修改上述命令，比如有些cuDNN的库目录不叫<code>lib</code>而叫<code>lib64</code>。</p>
<p>如果大家对操作系统熟悉的话，可以灵活地把复制改为剪切或者软链接。</p>
<h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h2><p>Anaconda可以让用户更好地管理Python包。反正大家都在用，我也一直在用。</p>
<p>无论是什么操作系统，都可以在这里下Anaconda：<br><a target="_blank" rel="noopener" href="https://www.anaconda.com/products/individual#Downloads">https://www.anaconda.com/products/individual#Downloads</a> </p>
<p>同样，Windows和Linux分别会得到GUI安装器和shell脚本。</p>
<p>下好了安装器后，按照默认配置安装即可。</p>
<p>安装完成后，下一步是打开有Anaconda环境的控制台。</p>
<p>在Windows下，点击任务栏中的搜索框，搜索Anaconda，打开<code>Anaconda Powershell Prompt (Anaconda)</code>或者<code>Anaconda Prompt (Anaconda)</code>。</p>
<p>在Linux下，新建一个命令行即可。</p>
<p>如果在命令行里看到了<code>(base)</code>，就说明安装成功了。</p>
<p>之后，要创建<strong>某个Python版本</strong>的虚拟环境，专门放我们用来做深度学习的Python库。该命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name &#123;env_name&#125; python=&#123;version&#125;</span><br></pre></td></tr></table></figure>
<p>比如我要创建一个名字叫<code>pt</code>，Python版本3.7的虚拟环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name pt python=3.7</span><br></pre></td></tr></table></figure>
<p>创建完成后，使用下面的命令进入虚拟环境：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate &#123;env_name&#125;</span><br></pre></td></tr></table></figure></p>
<p>我的命令是：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate pt</span><br></pre></td></tr></table></figure></p>
<p>如果在命令行前面看到了<code>(&#123;env_name&#125;)</code>，就算是成功了：</p>
<p><img src="/2022/06/27/DLS-note-7-2/1.jpg" alt></p>
<blockquote>
<p>完成上述步骤后，在VSCode里用<code>ctrl+shift+p</code>打开命令面板，输入<code>select interpreter</code>，找到<code>Python: Select Interpreter</code>这个选项，选择刚刚新建好的虚拟环境中的Python解释器。这样，新建VSCode的控制台时，控制台就能自动进入到conda虚拟环境里了。</p>
</blockquote>
<h2 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h2><p>无论是GPU版还是CPU版，只需要在对应的虚拟环境中输入下面的命令即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflow</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果下载速度较慢，请更换conda和pip的下载源。可参考的教程很多，比如 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011935830/article/details/10307">https://blog.csdn.net/u011935830/article/details/10307</a> 95。</p>
</blockquote>
<p>如果显卡驱动和conda都装好了，执行完上面的命令后，GPU版TensorFlow也就装好了。打开Python，执行下面的命令（或者写一个<code>.py</code>文件再运行），即可验证GPU版安装是否成功。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.config.list_physical_devices(<span class="string">&#x27;GPU&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果最后输出了一大堆信息，最后一行是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PhysicalDevice(name=&#x27;/physical_device:GPU:0&#x27;, device_type=&#x27;GPU&#x27;)]</span><br></pre></td></tr></table></figure>
<p>，那么就说明GPU版的TensorFlow安装成功了。</p>
<h2 id="VSCode代码补全"><a href="#VSCode代码补全" class="headerlink" title="VSCode代码补全"></a>VSCode代码补全</h2><p>TensorFlow.keras在VSCode中无法生成代码补全，编程体验极差，不知道维护者在干什么东西。有人在issue中提出了解决方法。</p>
<p>打开<code>tensorflow/__init__.py</code>，添加以下内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _typing.TYPE_CHECKING:</span><br><span class="line">  <span class="keyword">from</span> tensorflow_estimator.python.estimator.api._v2 <span class="keyword">import</span> estimator <span class="keyword">as</span> estimator</span><br><span class="line">  <span class="keyword">from</span> keras.api._v2 <span class="keyword">import</span> keras</span><br><span class="line">  <span class="keyword">from</span> keras.api._v2.keras <span class="keyword">import</span> losses</span><br><span class="line">  <span class="keyword">from</span> keras.api._v2.keras <span class="keyword">import</span> metrics</span><br><span class="line">  <span class="keyword">from</span> keras.api._v2.keras <span class="keyword">import</span> optimizers</span><br><span class="line">  <span class="keyword">from</span> keras.api._v2.keras <span class="keyword">import</span> initializers</span><br></pre></td></tr></table></figure></p>
<h1 id="用TensorFlow实现多分类任务"><a href="#用TensorFlow实现多分类任务" class="headerlink" title="用TensorFlow实现多分类任务"></a>用TensorFlow实现多分类任务</h1><p>每当学习一门新的编程技术时，程序员们都会完成一个”Hello World”项目。让我们完成一个简单的点集多分类任务，作为TensorFlow的入门项目。这个项目只会用到比较底层的函数，而不会使用框架的高级特性，可以轻松地翻译成纯NumPy或者其他框架的实现。</p>
<p>在这个项目中，我们会学到以下和TensorFlow有关的知识：</p>
<ul>
<li>TensorFlow与NumPy的相互转换</li>
<li>TensorFlow的常量与变量</li>
<li>TensorFlow的常见运算（矩阵乘法、激活函数、误差）</li>
<li>TensorFlow的初始化器</li>
<li>TensorFlow的优化器</li>
<li>TensorFlow保存梯度中间结果的方法</li>
<li>one-hot与标签的相互转换</li>
</ul>
<p>我们将按照程序运行的逻辑顺序，看看这个多分类器是怎么实现的。</p>
<p>如果你看过我前几周的代码实战文章，欢迎比较一下这周和之前的代码，看看相比NumPy，TensorFlow节约了多少代码。</p>
<p>欢迎在GitHub上面访问<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/MulticlassClassification">本项目</a>。</p>
<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>这周，我们要用到一个平面点数据集。在平面上，有三种颜色不同的点。我们希望用TensorFlow编写的神经网络能够区分这三种点。</p>
<p><img src="/2022/06/27/DLS-note-7-2/r1.jpg" alt></p>
<p>在项目中，我已经写好了生成数据集的函数。<code>generate_points</code>能根据数据集大小生成一个平面点数据集。<code>generate_plot_set</code>能生成最终测试平面上每一个“像素”的测试集。使用这两个函数，得到的<code>X</code>的形状为<code>[2, m]</code>（因为是平面点，所以只有两个通道），<code>Y</code>的形状为<code>[1, m]</code>。<code>Y</code>的元素是0-2的标签，分别表示红、绿、蓝三种颜色的点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">train_X, train_Y = generate_points(<span class="number">400</span>)</span><br><span class="line">plot_X = generate_plot_set()</span><br><span class="line"></span><br><span class="line"><span class="comment"># X: [2, m]</span></span><br><span class="line"><span class="comment"># Y: [1, m]</span></span><br></pre></td></tr></table></figure>
<h2 id="数据预处理与TensorFlow转换"><a href="#数据预处理与TensorFlow转换" class="headerlink" title="数据预处理与TensorFlow转换"></a>数据预处理与TensorFlow转换</h2><p>我们刚刚得到的<code>X, Y</code>都是NumPy数组，我们要把它们转换成TensorFlow认识的数据结构。</p>
<p>TensorFlow用起来和C++很像，我们要决定一个数据是变量还是常量。由于<code>X</code>是不可变的训练数据，它应该属于常量。因此，我们用下面的语句把它转换成TensorFlow的常量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_X_tf = tf.constant(train_X, dtype=tf.float32)</span><br></pre></td></tr></table></figure>
<p>TensorFlow常量的类型名叫做<code>tf.Tensor</code>，也就是说<code>train_X_tf</code>是一个<code>tf.Tensor</code>。</p>
<p>而在使用<code>Y</code>时，我们要加一步转换到one-hot编码的步骤。回忆<a href>本周笔记中</a>有关多分类loss的知识，这里的<code>Y</code>是一个整型数组，表示每个数据的类别。而在loss的计算中，我们需要把每个整数转换成一个one-hot向量，得到一个one-hot向量的向量。</p>
<p>因此，我们可以用下面的代码把<code>Y</code>预处理并转换成TensorFlow的数据结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_Y_tf = tf.transpose(tf.one_hot(train_Y.squeeze(<span class="number">0</span>), <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p><code>tf.one_hot()</code>用于生成one-hot编码，其第二个参数为总类别数。我们的数据集有3种点，因此取3。<code>tf.one_hot()</code>的输出是一个<code>[m, 3]</code>形状的张量，我们要把它<code>tf.transpose</code>转置一下，得到与其他代码相匹配的<code>[3, m]</code>张量。</p>
<p>顺带一提，由于<code>tf.one_hot</code>是一个TensorFlow的运算，如果输入是一个numpy数组，输出会被自动转换成一个TensorFlow的常量<code>tf.Tensor</code>。所以，<code>Y</code>的类型也是<code>tf.Tensor</code>。</p>
<p>经过上述操作，<code>X, Y</code>再被送入TensorFlow模型之前的形状是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># X: [2, m]</span></span><br><span class="line"><span class="comment"># Y: [3, m]</span></span><br></pre></td></tr></table></figure>
<h2 id="TensorFlow多分类模型"><a href="#TensorFlow多分类模型" class="headerlink" title="TensorFlow多分类模型"></a>TensorFlow多分类模型</h2><p>处理完了数据，接下来，我们就要定义神经网络了。在神经网络中，我们要实现初始化、正向传播、误差、评估这四个方法。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MulticlassClassificationNet</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, neuron_cnt: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.num_layer = <span class="built_in">len</span>(neuron_cnt) - <span class="number">1</span></span><br><span class="line">        self.neuron_cnt = neuron_cnt</span><br><span class="line">        self.W = []</span><br><span class="line">        self.b = []</span><br><span class="line">        initializer = tf.keras.initializers.HeNormal(seed=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">            self.W.append(</span><br><span class="line">                tf.Variable(</span><br><span class="line">                    initializer(shape=(neuron_cnt[i + <span class="number">1</span>], neuron_cnt[i]))))</span><br><span class="line">            self.b.append(</span><br><span class="line">                tf.Variable(initializer(shape=(neuron_cnt[i + <span class="number">1</span>], <span class="number">1</span>))))</span><br><span class="line">        self.trainable_vars = self.W + self.b</span><br></pre></td></tr></table></figure>
<p>和之前一样，我们通过<code>neuron_cnt</code>指定神经网络包含输出层在内每一层的神经元数。之后，根据每一层的神经元数，我们就可以初始化参数<code>W</code>和<code>b</code>了。</p>
<p>使用TensorFlow，我们可以方便地完成一些高级初始化操作。比如我们要使用He Initialization，我们可以用<code>tf.keras.initializers.HeNormal(seed=1)</code>生成一个初始化器<code>initializer</code>，再用这个工具生成每一个初始化后的变量。</p>
<p>使用<code>initializer(*shape)</code>即可生成某形状的参数。由于参数是需要被优化更新的，我们需要用<code>tf.Variable</code>来把参数转换成可以优化的变量。</p>
<p>最后，我们用<code>self.trainable_vars = self.W + self.b</code>记录一下所有待优化变量，为之后的优化算法做准备。</p>
<h3 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h3><p>正向传播的写法很简单，只要在每层算一个矩阵乘法和一次加法，再经过激活函数即可（在这个神经网络中，隐藏层的激活函数默认使用ReLU）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">    A = X</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">        Z = tf.matmul(self.W[i], A) + self.b[i]</span><br><span class="line">        <span class="keyword">if</span> i == self.num_layer - <span class="number">1</span>:</span><br><span class="line">            A = tf.keras.activations.softmax(Z)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A = tf.keras.activations.relu(Z)</span><br></pre></td></tr></table></figure><br>在这份代码中,<code>tf.matmul</code>用于执行矩阵乘法，等价于<code>np.dot</code>。和NumPy里的张量一样，TensorFlow里的张量也可以直接用运算符<code>+</code>来完成加法。</p>
<p>做完了线性层的运算后，我们可以方便地调用<code>tf.keras.activations</code>里的激活函数完成激活操作。</p>
<p>值得一提的是，TensorFlow会自动帮我们计算导数。因此，之前我们在正向传播里保存中间运算结果的代码全都可以删掉。我们也不用再编写反向传播函数了。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>使用下面的代码可以在一行内算完损失函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">self, Y, Y_hat</span>):</span></span><br><span class="line">    <span class="keyword">return</span> tf.reduce_mean(</span><br><span class="line">        tf.keras.losses.categorical_crossentropy(</span><br><span class="line">            tf.transpose(Y),tf.transpose(Y_hat)))</span><br></pre></td></tr></table></figure><br><code>tf.keras.losses.categorical_crossentropy</code>就是多分类使用的交叉熵误差。由于这个函数要求输入的形状为<code>[num_samples, num_classes]</code>，和我们的定义相反，我们要把两个输入都转置一下。算完误差后，我们用<code>tf.reduce_mean</code>算误差的平均数以得到最终的损失函数。这个函数等价于NumPy里用<code>mean</code>时令<code>keepdims=False</code>。</p>
<h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>为了监控网络的运行结果，我们可以手写一个评估网络正确率和误差的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span>(<span class="params">self, X, Y, return_loss=<span class="literal">False</span></span>):</span></span><br><span class="line">    Y_hat = self.forward(X)</span><br><span class="line">    Y_predict = tf.argmax(Y, <span class="number">0</span>)</span><br><span class="line">    Y_hat_predict = tf.argmax(Y_hat, <span class="number">0</span>)</span><br><span class="line">    res = tf.cast(Y_predict == Y_hat_predict, tf.float32)</span><br><span class="line">    accuracy = tf.reduce_mean(res)</span><br><span class="line">    <span class="keyword">if</span> return_loss:</span><br><span class="line">        loss = self.loss(Y, Y_hat)</span><br><span class="line">        <span class="keyword">return</span> accuracy, loss</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> accuracy</span><br></pre></td></tr></table></figure>
<p>首先，我们使用<code>Y_hat = self.forward(X)</code>，根据<code>X</code>算出估计值<code>Y_hat</code>。之后我们就要对<code>Y</code>和<code>Y_hat</code>进行比较了。</p>
<p><code>Y</code>和<code>Y_hat</code>都不是整数标签，而是用向量代表了标签。为了方便比较，我们要把它们转换回用整数表示的标签。这个转换函数是<code>tf.argmax</code>。</p>
<p>和数学里的定义一样，<code>tf.argmax</code>返回令函数最大的参数值。而对于数组来说，就是返回数组里值最大的下标值。<code>tf.argmax</code>的第一个参数是参与运算的张量，第二个参数是参与运算的维度。<code>Y</code>和<code>Y_hat</code>的形状是<code>[3, m]</code>，我们要把长度为3的向量转换回标签向量，因此应该对第一维进行运算（即维度0）。</p>
<p>得到了<code>Y_predict, Y_hat_predict</code>后，我们要比对它们以计算准确率。这时，我们可以用<code>res = Y_predict == Y_hat_predict</code>得到一个bool值的比对结果。TensorFlow的类型非常严格，bool值是无法参与普通运算的，我们要用<code>tf.cast</code>强制类型转换。由于最终的准确率是一个浮点数，我们要转换成<code>tf.float32</code>浮点类型。</p>
<p>最后，用<code>accuracy = tf.reduce_mean(res)</code>就可以得到准确率了。</p>
<p>由于我们前面写好了<code>loss</code>方法，计算loss时直接调用方法就行了。</p>
<h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>写完了模型，该训练模型了。下面是模型训练的主要代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">model: MulticlassClassificationNet,</span></span></span><br><span class="line"><span class="params"><span class="function">          X,</span></span></span><br><span class="line"><span class="params"><span class="function">          Y,</span></span></span><br><span class="line"><span class="params"><span class="function">          step,</span></span></span><br><span class="line"><span class="params"><span class="function">          learning_rate,</span></span></span><br><span class="line"><span class="params"><span class="function">          print_interval=<span class="number">100</span></span>):</span></span><br><span class="line">    optimizer = tf.keras.optimizers.Adam(learning_rate)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(step):</span><br><span class="line">        <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">            Y_hat = model.forward(X)</span><br><span class="line">            cost = model.loss(Y, Y_hat)</span><br><span class="line">        grads = tape.gradient(cost, model.trainable_vars)</span><br><span class="line">        optimizer.apply_gradients(<span class="built_in">zip</span>(grads, model.trainable_vars))</span><br></pre></td></tr></table></figure>
<p>TensorFlow使用一系列的优化器来维护梯度下降的过程。我们只需要用<code>tf.keras.optimizers.Adam(learning_rate)</code>即可获取一个Adam优化器。</p>
<p>接下来，我们看<code>for s in range(step):</code>里每一步更新参数的过程。</p>
<p>在TensorFlow里，为了计算梯度，我们要使用一个上下文<code>with tf.GradientTape() as tape:</code>。在这个上下文中，执行完运算后，所有<code>Variable</code>的求导中间结果都会被记录下来。因此，我们应该调用网络的前向传播和损失函数，完成整套的计算过程。</p>
<p>计算出损失函数后，我们用<code>grads = tape.gradient(cost, model.trainable_vars)</code>算出最终的梯度，并调用<code>optimizer.apply_gradients(zip(grads, model.trainable_vars))</code>更新参数。</p>
<p>可以看出，相比完全用NumPy实现，TensorFlow用起来十分方便。只要我们用心定义好了前向传播函数和损失函数，维护梯度和优化参数都可以交给编程框架来完成。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>做完了所有准备后，我们用下面的代码初始化模型并调用训练函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n_x = <span class="number">2</span></span><br><span class="line">neuron_list = [n_x, <span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>]</span><br><span class="line">model = MulticlassClassificationNet(neuron_list)</span><br><span class="line">train(model, train_X_tf, train_Y_tf, <span class="number">5000</span>, <span class="number">0.001</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><br>这里要注意一下，由于数据有三种类别，神经网络最后一层必须是3个神经元。</p>
<p>网络训练完成后，我们用下面的代码把网络推理结果转换成可视化要用的NumPy结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plot_result = model.forward(plot_X)</span><br><span class="line">plot_result = tf.argmax(plot_result, <span class="number">0</span>).numpy()</span><br><span class="line">plot_result = np.expand_dims(plot_result, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>运行完<code>plot_result = model.forward(plot_X)</code>后，我们得到的是一个<code>[3, m]</code>的概率t矩阵。我们要用<code>tf.argmax(plot_result, 0)</code>把它转换回整型标签。</p>
<p>之后，我们对TensorFlow的张量调用<code>.numpy()</code>，即可使用我们熟悉的NumPy张量了。为了对齐可视化API的格式，我用<code>expand_dims</code>把最终的标签转换成了<code>[1, m]</code>的形状。</p>
<p>完成了转换，只需调用我写的可视化函数即可看出模型是怎样对二维平面分类的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visualize(train_X, train_Y, plot_result)</span><br></pre></td></tr></table></figure>
<p>我的一个运行结果如下：</p>
<p><img src="/2022/06/27/DLS-note-7-2/r2.jpg" alt></p>
<p>只能说，神经网络实在太强啦。</p>
<h2 id="附录：TensorFlow的GPU版本"><a href="#附录：TensorFlow的GPU版本" class="headerlink" title="附录：TensorFlow的GPU版本"></a>附录：TensorFlow的GPU版本</h2><p>在使用TensorFlow时，我唯一发现它比PyTorch更便捷的地方，就是TensorFlow能够自动选择运算时的设备。如果电脑按上面的流程装好了驱动、CUDA和cuDNN，TensorFlow就会很主动地把张量放到GPU上运算。而如果没有检测到GPU，TensorFlow也会用CPU计算。</p>
<p>如果想要手动管理张量的运算设备，可以参考下面的代码。当我想在CPU上初始化张量时：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.device(<span class="string">&#x27;/CPU:0&#x27;</span>):</span><br><span class="line">    a = tf.constant([[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>]])</span><br><span class="line">    b = tf.constant([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>], [<span class="number">5.0</span>, <span class="number">6.0</span>]])</span><br></pre></td></tr></table></figure><br>想初始化多个GPU中的某个GPU上的张量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.device(<span class="string">&#x27;/device:GPU:2&#x27;</span>):</span><br><span class="line">    a = tf.constant([[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>]])</span><br><span class="line">    b = tf.constant([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>], [<span class="number">5.0</span>, <span class="number">6.0</span>]])</span><br></pre></td></tr></table></figure><br>这里GPU的名称可以用我们之前见过的<code>tf.config.list_physical_devices(&#39;GPU&#39;)</code>来查找：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; tf.config.list_physical_devices(<span class="string">&#x27;GPU&#x27;</span>)</span></span><br><span class="line">[PhysicalDevice(name=&#x27;/physical_device:GPU:0&#x27;, device_type=&#x27;GPU&#x27;)]</span><br></pre></td></tr></table></figure>
<p>有趣的是，这个项目的代码用TensorFlow在GPU上运行，比我之前的NumPy项目用CPU运行还慢。感觉是这个项目的计算过于简单，GPU无法发挥性能上的优势。GPU计算的一些其他开销盖过了运算时间的减少。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这篇笔记中，我介绍了TensorFlow在Windows/Linux下的从零安装方法，并且介绍了一个简单的TensorFlow多分类项目。希望大家能通过这篇笔记，成功上手TensorFlow。</p>
<p>项目链接：<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/MulticlassClassification">https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/MulticlassClassification</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/06/21/DLS-note-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/21/DLS-note-7/" class="post-title-link" itemprop="url">吴恩达《深度学习专项》笔记（七）：调参、批归一化、多分类任务、编程框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-21 13:47:43" itemprop="dateCreated datePublished" datetime="2022-06-21T13:47:43+08:00">2022-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="学习提示"><a href="#学习提示" class="headerlink" title="学习提示"></a>学习提示</h1><p>这周的知识点也十分分散，主要包含四项内容：调参、批归一化、多分类任务、编程框架。</p>
<p>通过在之前的编程项目里调整学习率，我们能够体会到超参数对模型效果的重要影响。实际上，选择超参数不是一个撞运气的过程。我们应该有一套系统的方法来快速找到合适的超参数。</p>
<p>两周前，我们学习了输入归一化。类似地，如果对网络的每一层都使用归一化，也能提升网络的整体表现。这样一种常用的归一化方法叫做批归一化。</p>
<p>之前，我们一直都在讨论二分类问题。而只要稍微修改一下网络结构和激活函数，我们就能把二分类问题的算法拓展到多分类问题上。</p>
<p>为了提升编程的效率，从这周开始，我们要学习深度学习编程框架。编程框架往往能够帮助我们完成求导的功能，我们可以把精力集中在编写模型的正向传播上。</p>
<h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><blockquote>
<p>调参的英文动词叫做tune，这个单词作动词时大部分情况下是指调音。这样一看，把调参叫做“调整参数”或“调试参数”都显得很“粗鲁”。理想情况下，调参应该是一个系统性的过程，就像你去给乐器调音一样。乱调可是行不通的。</p>
</blockquote>
<h3 id="超参数优先级"><a href="#超参数优先级" class="headerlink" title="超参数优先级"></a>超参数优先级</h3><p>回顾一下，我们接触过的超参数有：</p>
<ul>
<li>学习率 $\alpha$</li>
<li>momentum $\beta$</li>
<li>adam $\beta_1, \beta_2, \epsilon$</li>
<li>隐藏层神经元数</li>
<li>层数</li>
<li>学习率递减率</li>
<li>mini-batch size</li>
</ul>
<p>其中，优先级最高的是学习率。吴恩达老师建议大家调完学习率后，再去调$\beta$、隐藏层神经元数、mini-batch size。如果使用adam，则它的三个参数基本不用调。</p>
<h3 id="超参数采样策略"><a href="#超参数采样策略" class="headerlink" title="超参数采样策略"></a>超参数采样策略</h3><p>在尝试各种超参数时，不要按“网格”选参数（如下图左半所示），最好随机选参数（如下图右半所示）：</p>
<p><img src="/2022/06/21/DLS-note-7/1.jpg" alt></p>
<p>如果用网格采样法的话，你可能试了25组参数，每个参数只试了5个不同的值。而实际上，你试的两个参数中只有一个参数对结果的影响较大，另一个参数几乎不影响结果。最终，你尝试的25次中只有5次是有效的。</p>
<p>而采用随机采样法试参数的话，你能保证每个参数在每次尝试时都取不同值。这样试参数的效率会更高一点。</p>
<p>另外，调参时还有一个“由粗至精”的过程。如下图所示：</p>
<p><img src="/2022/06/21/DLS-note-7/2.jpg" alt></p>
<p>当我们发现某几个参数的结果比较优秀时，我们可以缩小搜索范围，仅在这几个参数附近进行搜索。</p>
<h3 id="超参数搜索尺度"><a href="#超参数搜索尺度" class="headerlink" title="超参数搜索尺度"></a>超参数搜索尺度</h3><p>搜索参数时，要注意搜索的尺度。如果搜索的尺度不够恰当，我们大部分的调参尝试可能都是无用功。</p>
<p>比如当搜索学习率时，我们应该按<code>0.0001, 0.001, 0.01, 0.1, 1</code>这样指数增长的方式去搜索，而不应该按<code>0.2, 0.4, 0.6, 0.8, 1</code>这种均匀采样的方式搜索。这是因为学习率是以乘法形式参与计算，取<code>0.4, 0.6, 0.8</code>得到的结果可能差不多，按这种方式采样的话，大部分的尝试都是浪费的。而以<code>0.001, 0.01, 0.1</code>这种方式取学习率的话，每次的运行结果就会差距较大，每次尝试都是有意义的。</p>
<p>除了搜索学习率时用到的指数采样，还有其他的采样方式。让我们看调整momentum项$\beta$的情况。回忆一下，$\beta$取0.9，表示近10项的平均数；$\beta$取0.99，表示近100项的平均数。也就是说，$\beta$表示$\frac{1}{1-\beta}$项的平均数。我们可以对$\frac{1}{1-\beta}$进行指数均匀采样。</p>
<p>当然，有些参数是可以均匀采样的。比如隐藏层的个数，我们可以从[2, 3, 4]里面挑一个；比如每个隐藏层的神经元数，我们也可以直接均匀采样。</p>
<p>总结一下，我们在搜索超参数的时候，应该从超参数所产生的影响出发，考虑应该在哪个指标上均匀采样，再反推超参数的采样公式，而不一定要对超参数本身均匀采样。</p>
<p>当然了，如果我们不确定应该从哪个尺度对超参数采样，可以先默认使用均匀采样。因为我们会遵循由粗至精的搜索原则，尝试几轮后我们就能够观察出超参数的取值规律，从而在正确的尺度上对超参数进行搜索。</p>
<h2 id="批归一化-Batch-Normalization"><a href="#批归一化-Batch-Normalization" class="headerlink" title="批归一化(Batch Normalization)"></a>批归一化(Batch Normalization)</h2><p>在<a href>第五篇笔记中</a>，我们曾学习了<strong>输入归一化</strong>。其计算公式如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mu&=\frac{1}{m}\Sigma_{i=1}^{m}x^{(i)} \\
x &:= (x - \mu) \\
\sigma^2&=\frac{1}{m}\Sigma_{i=1}^{m}(x^{(i)})^2 \\
x &:= x / \sigma
\end{aligned}</script><p>通过归一化，神经网络第一层的输入更加规整，模型的训练速度能得到有效提升。</p>
<p><img src="/2022/06/21/DLS-note-7/3.jpg" alt></p>
<p>我们知道，神经网络的输入可以看成是第零层（输入层）的激活输出。一个很自然的想法是：我们能不能把神经网络每一个隐藏层的激活输出也进行归一化，让神经网络更深的隐藏层也能享受到归一化的加速？</p>
<p><strong>批归一化</strong>(Batch Normalization)就是这样一种归一化神经网络每一个隐藏层输出的算法。准确来说，我们归一化的对象不是每一层的激活输出$a^{[l]}$，而是激活前的计算结果$z^{[l]}$。让我们看看对于某一层的激活前输出$z=z^{[l]}$，我们该怎么进行批归一化。</p>
<p>首先，还是先获取符合标准正态分布的归一化结果$z^{(i)}_{norm}$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& Input \ z^{(1)}, z^{(2)}, ...z^{(m)} \\
& \mu=\frac{1}{m}\Sigma_i^{m}z^{(i)} \\
& \sigma^2=\frac{1}{m}\Sigma_i^{m}(z^{(i)}- \mu)^2\\
& z^{(i)}_{norm}=\frac{z^{(i)}-\mu}{\sigma}
\end{aligned}</script><p>我们不希望每一层的输出都固定为标准正态分布，而是希望网络能够自己选择最恰当的分布。因此，我们可以用下式计算最终的批归一化结果：</p>
<script type="math/tex; mode=display">
\tilde{z}^{(i)}=\gamma z^{(i)}_{norm} + \beta</script><p>其中$\tilde{z}^{(i)}$是最终的批归一化结果，$\gamma, \beta$都是可学习参数，分别影响新分布的方差与均值。</p>
<blockquote>
<p>为什么我们不希望数据的分布总是标准正态分布呢？可以考察一个即将送入sigmoid的$z$。sigmoid在[-1, 1]这段区间内近乎是一个线性函数，为了利用该激活函数的非线性区域，我们应该让$z$的取值范围更大一点，即让$z$的方差大于1。</p>
<p>这里的$\beta$和梯度下降算法里的$\beta$不是同一回事，只是这几个算法的原论文里都使用了$\beta$这个符号。</p>
</blockquote>
<p>使用批归一化后，原来的神经网络计算公式需要做出一些调整。之前，$z^{(i)}$的计算公式如下：</p>
<script type="math/tex; mode=display">
z^{(i)}=Wa^{(i)}+b</script><p>现在，我们会把$z^{(i)}$的均值归一化到0。因此，$+b$成为了一个冗余的操作。使用了批归一化后，$z^{(i)}$应该按下面的方法计算：</p>
<script type="math/tex; mode=display">
z^{(i)}=Wa^{(i)}</script><p>总结一下，加入批归一化后，神经网络的计算过程如下所示：</p>
<script type="math/tex; mode=display">
X \to Z^{[1]}(use \ W^{[1]}) \to \tilde{Z}^{[1]}(use \ \beta^{[1]}, \gamma^{[1]}) \to A^{[1]} \to ...</script><p>注意，使用向量化计算后，$\tilde{Z}^{[l]}$的计算公式应该如下：</p>
<script type="math/tex; mode=display">
\tilde{Z}^{[l]}=\gamma^{[l]} \ast Z_{norm}^{[l]} + \beta^{[l]}</script><p>其中$\gamma^{[l]}$和$\beta^{[l]}$的形状都是$(n^{[l]}, 1)$</p>
<blockquote>
<p>课堂里没有介绍批归一化的求导公式。这里补充一下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
d\beta &= \frac{1}{m}dA \\
d\gamma &= \frac{1}{m}dA \ast Z_{norm}^{[l]} 
\end{aligned}</script></blockquote>
<p>使用批归一化后，常见优化算法（mini-batch, momentum, adam, …）仍能照常使用。</p>
<h3 id="直观理解批归一化的作用"><a href="#直观理解批归一化的作用" class="headerlink" title="直观理解批归一化的作用"></a>直观理解批归一化的作用</h3><p>对于神经网络中较深的层，它们只能“看到”来自上一层的激活输出，而不知道较浅的层的存在。如下图所示，对于第3层，它只知道第2层的激活输出$A^{[2]}$。</p>
<p><img src="/2022/06/21/DLS-note-7/4.jpg" alt></p>
<p>这样，经过一段时间的训练后，网络的第3层和第4层知道了如何较好地把$A^{[2]}$映射成$\hat{y}$。</p>
<p>可是，$A^{[2]}$并不是神经网络的真实输入。神经网络真正的结构如下：</p>
<p><img src="/2022/06/21/DLS-note-7/5.jpg" alt></p>
<p>$A^{[2]}$其实还受到神经网络前2层参数的影响。一旦前2层的参数更新，$A^{[2]}$的分布也会随之改变，第3层和第4层可能要从头学习$A^{[2]}$到$\hat{y}$的映射关系。</p>
<p>与之相比，使用了批归一化后，神经网络每一层的输出都会落在一个类似的分布里。这样，浅层和深层之间就没有那么强的依赖关系，较深的层能够更快完成学习。</p>
<p>顺带一提，当我们用批归一化的同时，如果还使用了mini-batch，则批归一化还能稍微起到一点正则化的作用。这是因为在mini-batch上每层批归一化用到的方差和均值是不准确的，这种“带噪音”的批归一化能够起到和dropout类似的作用，防止神经网络以较大的权重依赖于少数神经元。</p>
<h3 id="测试时的批归一化"><a href="#测试时的批归一化" class="headerlink" title="测试时的批归一化"></a>测试时的批归一化</h3><p>我们刚刚学习的批归一化操作，其实都是针对训练而言的。在训练时，我们有大批的数据，可以轻松算出每一层中间结果$Z^{[l]}$的均值和方差。但是，在测试时，我们可能只会对一项输入进行计算。对一项输入计算均值和方差是没有意义的。因此，我们要想办法决定测试时$Z^{[l]}\to Z_{norm}^{[l]}$用到的均值和方差。</p>
<p>我们可以用每一个mini-batch的均值和方差的指数加权移动平均数作为测试时的均值和方差。</p>
<h2 id="Softmax-与多分类问题"><a href="#Softmax-与多分类问题" class="headerlink" title="Softmax 与多分类问题"></a>Softmax 与多分类问题</h2><p>之前我们一直都在讨论二分类问题。比如，辨别一张图片是不是小猫。当我们把二分类问题拓展到多分类问题时，问题的数学模型会发生哪些变化呢？</p>
<p>首先，我们来看一下多分类问题的定义。在多分类问题中，我们要要判断一个输入是属于$C$种类型中的哪一种。比如我们希望判断一张图片里的生物是属于小猫、小狗、小鸡、其他这$C=4$类中的哪一种。</p>
<p>在二分类问题中，我们用1表示“是某一类”，0表示“不是某一类”。我们只需要计算$P(\hat{y}=1|x)$这一个概率。而多分类问题中，我们用一个数字表示一种类别，比如0表示“其他”，1表示“小猫”，2表示“小狗”，3表示“小鸡”。这样，我们就应该计算多个概率，比如$P(\hat{y}=0|x), P(\hat{y}=1|x), P(\hat{y}=2|x), P(\hat{y}=3|x)$这四个概率。</p>
<p>多分类问题的示意图和一个可能的多分类神经网络如下图所示（注意，该网络有4个输出）：</p>
<p><img src="/2022/06/21/DLS-note-7/6.jpg" alt></p>
<p>接着，我们来看看多分类问题带来了哪些新的困难。在二分类问题中，我们得到了最后一层的计算结果$z^{[L]}$，我们要用sigmoid把它映射到表示概率的[0, 1]上。而多分类问题中，同理，我们要把神经网络最后一层的计算结果$z^{[L]}$映射成一些有实际意义的概率值。具体而言，我们应让所有分类概率之和为1，即$\Sigma_{i=1}^CP(\hat{y}=i|x)=1$。为了达到这个目的，我们要引入一个激活函数——softmax。</p>
<p>和其他定义在一个实数上的激活函数不同，softmax定义在一个向量上，其计算方式为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&Input \ z^{[L]} \\
&output \ a^{[L]} \\
&t =  e^{z^{[L]}} \\
&a^{[L]} = \frac{t}{\Sigma_{i=1}^Ct_i}
\end{aligned}</script><p>注意，上式中所有运算都是逐元素运算。比如在上面提到的有四个类别的分类问题中，$z^{[L]}$是一个形状为$(4, 1)$的张量，经过逐元素运算后，$t, a^{[L]}$都是形状为$(4, 1)$的张量。</p>
<p>上述描述可能比较抽象，让我们看课件里的一个具体例子：</p>
<p><img src="/2022/06/21/DLS-note-7/7.jpg" alt></p>
<p>假设$z^{[L]}=[5, 2, -1, 3]$，则$t=[e^5, e^2, e^{-1}, e^3], \Sigma_{j=1}^4t_j\approx176.3,a^{[L]}_1\approx0.842,a^{[L]}_2\approx0.042,a^{[L]}_3\approx0.002,a^{[L]}_4\approx0.114$。</p>
<p>softmax的计算方法可以总结为：求指数，归一化。本质上来说，softmax就是把向量每个分量的自然指数作为一个新的标准，在这个标准上进行标准归一化操作。</p>
<blockquote>
<p>为什么要使用向量每个分量的自然指数作为归一化的变量，而不直接对原向量做标准归一化呢？可以考虑[1, 2], [10, 20]这两个向量。如果直接对这两个量进行进行归一化，算出来的概率都是[0.33, 0.67]。而实际上，第一个向量可能对应一幅比较模糊的输入，第二个向量可能对应一幅比较清楚的输入。显然，在更清晰的输入上，我们更有把握说我们的分类结果是正确的。通过使用softmax，我们可以放大数值的影响，[10, 20]相比[1, 2]，我们更有把握说输入是属于第二个类别的。该解释参考自<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17187507/why-use-softmax-as-opposed-to-standard-normalization">https://stackoverflow.com/questions/17187507/why-use-softmax-as-opposed-to-standard-normalization</a></p>
<p>在C=2时，softmax会退化成sigmoid。也就是说，softmax是sigmoid在多分类任务上的推广。</p>
<p>softmax这个名字，其实衍生自hardmax这个词。使用hardmax时，输入会被映射成[1, 0, 0, 0]这样一个one-hot向量。这种最大值太严格（hard）了，所以有相对来说比较宽松（soft）的最大值计算方法softmax。</p>
</blockquote>
<p>使用了softmax后，还需要调整的是网络的loss。推广到多分类后，我们要使用的loss是</p>
<script type="math/tex; mode=display">
L(y, \hat{y}) = -\Sigma_{i=1}^Cy_ilog\hat{y_i}</script><p>，其中$y_i$不是一个表示类别的整数，而是一个one-hot编码的向量。比如在一共有4类时，标签2的one-hot编码是：</p>
<script type="math/tex; mode=display">

\left[
  \begin{aligned}
  0 \\ 0 \\ 1 \\ 0
  \end{aligned}
\right]</script><p>假设整个标签数据集为$[0, 1, 3, 2]$，则参与网络运算时用到的$Y$应该是：</p>
<script type="math/tex; mode=display">
\left[
  \begin{aligned}
  1 \ 0 \ 0 \ 0\\ 
  0 \ 1 \ 0 \ 0\\ 
  0 \ 0 \ 0 \ 1\\ 
  0 \ 0 \ 1 \ 0
  \end{aligned}
\right]</script><p>在编程时，数据集一般只会提供用整数表示的标签。为了正确使用loss，我们需要多加一步转换到one-hot编码的步骤。</p>
<p>和逻辑回归类似，计算梯度时，$dZ^{[L]}=\hat{Y}-Y$这个等式依然成立，我们可以用它跳一个算梯度的步骤。</p>
<h2 id="编程框架"><a href="#编程框架" class="headerlink" title="编程框架"></a>编程框架</h2><p>由于深度学习的开发者越来越多，许多开源深度学习编程框架相继推出，比如：</p>
<ul>
<li>Caffe/Caffe2</li>
<li>Torch</li>
<li>TensorFlow</li>
<li>Keras</li>
<li>mxnet</li>
<li>PaddlePaddle</li>
<li>CNTK</li>
<li>DL4J</li>
<li>Lasagne</li>
<li>Theano</li>
</ul>
<p>这些编程框架不仅封装了常见的深度学习数学函数，如sigmoid、softmax、卷积，还支持自动求导的功能——这是深度学习编程框架最吸引人的一点。在使用编程框架时，我们只需要编写前向传播的过程，框架就会自动执行梯度计算，以辅助我们完成反向传播。</p>
<blockquote>
<p>目前，学术界最常用的是Torch的Python版PyTorch。第二常用的是TensorFlow。</p>
</blockquote>
<p>在选择编程框架时，我们要考虑以下几点：</p>
<ul>
<li>易用性（能否快速开发与部署）</li>
<li>运行性能</li>
<li>是否真正开源</li>
</ul>
<p>前两点注意事项毋庸置疑。框架之于编程语言，就像高级语言之于汇编语言一样。我们选择编程框架而不去从零编程，最主要的原因就是开发效率。使用框架能够节约大量的开发时间，有助于项目的迭代。而使用统一的框架，往往会损失一些效率，这些损失的效率不能太多。</p>
<p>第三点要着重强调一下。很多框架打着开源的名号，实际上却是某个公司在维护。如果这个公司哪天不想维护了，放弃继续开源，那么你的开发就会受到很大的影响。</p>
<blockquote>
<p>这周的课还介绍了TensorFlow的用法，我会在编程实战中补充这方面的知识。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这堂课的知识点有：</p>
<ul>
<li>调参<ul>
<li>优先级</li>
<li>采样策略</li>
<li>搜索尺度</li>
</ul>
</li>
<li>批归一化<ul>
<li>在网络中的位置</li>
<li>作用（归一化、<strong>新分布</strong>）</li>
<li><strong>超参数</strong>与公式</li>
<li>测试时的处理方式</li>
</ul>
</li>
<li>多分类问题<ul>
<li>softmax</li>
<li>loss</li>
</ul>
</li>
<li>编程框架<ul>
<li>了解常见的编程框架</li>
<li>选择编程框架的角度</li>
</ul>
</li>
</ul>
<p>通过这三周的学习，我们掌握了深度学习各方面的知识，能够用多种方式提升我们深度学习项目的性能了。</p>
<p>这周的编程要用到TensorFlow。我将另开一篇文章介绍本周的代码实战项目。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/06/15/DLS-note-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/15/DLS-note-6/" class="post-title-link" itemprop="url">吴恩达《深度学习专项》笔记+代码实战（六）：改进梯度下降算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-15 17:31:30" itemprop="dateCreated datePublished" datetime="2022-06-15T17:31:30+08:00">2022-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="学习提示"><a href="#学习提示" class="headerlink" title="学习提示"></a>学习提示</h1><p>一直以来，我们都用梯度下降法作为神经网络的优化算法。但是，这个优化算法还有很多的改进空间。这周，我们将学习一些更高级的优化技术，希望能够从各个方面改进普通的梯度下降算法。</p>
<p>我们要学习的改进技术有三大项：分批梯度下降、高级更新方法、学习率衰减。这三项是平行的，可以同时使用。</p>
<p>分批梯度下降是从数据集的角度改进梯度下降。我们没必要等遍历完了整个数据集后再进行参数更新，而是可以遍历完一小批数据后就进行更新。</p>
<p>高级更新方法指不使用参数的梯度值，而是使用一些和梯度相关的中间结果来更新参数。通过使用这些更高级的优化算法，我们能够令参数的更新更加平滑，更加容易收敛到最优值。这些高级的算法包括gradient descent with momentum, RMSProp, Adam。其中Adam是前两种算法的结合版，这是目前最流行的优化器之一。</p>
<p>学习率衰减指的是随着训练的进行，我们可以想办法减小学习率的值，从而减少参数的震荡，令参数更快地靠近最优值。</p>
<p>在这周的课里，我们要更关注每种优化算法的单独、组合使用方法，以及应该在什么场合用什么算法，最后再去关注算法的实现原理。对于多数技术，“会用”一般要优先于“会写”。</p>
<h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="分批梯度下降"><a href="#分批梯度下降" class="headerlink" title="分批梯度下降"></a>分批梯度下降</h2><blockquote>
<p>这项技术的英文名称取得极其糟糕。之前我们使用的方法被称为”batch gradient descent”, 改进后的方法被称为”mini-batch gradient descent”。但是，这两种方法的本质区别是是否把整个数据集分成多个子集。因此，我们认为我的中文翻译“分批梯度下降”、“整批梯度下降”比原来的英文名词或者“小批量梯度下降”等中文翻译要更贴切名词本身的意思。</p>
</blockquote>
<h3 id="使用mini-batch"><a href="#使用mini-batch" class="headerlink" title="使用mini-batch"></a>使用mini-batch</h3><p>在之前的学习中，我们都是用整个训练集的平均梯度来更新模型参数的。而如果训练集特别大的话，遍历整个数据集要花很长时间，梯度下降的速度将十分缓慢。</p>
<p>其实，我们不一定要等遍历完了整个数据集再做梯度下降。相较于每次遍历完所有$m$个训练样本再更新，我们可以遍历完一小批次(mini-batch)的样本就更新。让我们来看课件里的一个例子：</p>
<p><img src="/2022/06/15/DLS-note-6/1.jpg" alt></p>
<p>假设整个数据集大小$m=5,000,000$。我们可以把数据集划分成5000个mini-batch，其中每一个batch包含1000个数据。做梯度下降时，我们每跑完一个batch里的1000个数据，就用它们的平均梯度去更新参数，再去跑下一个batch。</p>
<p>这里要介绍一个新的标记。设整个数据集$X$的形状是$(n_x, m)(m=5,000,000)$，则第<strong>$i$个数据集的标记</strong>为 $X^{\lbrace i \rbrace}$ ,形状为$(n_x, 1000)$。</p>
<p>再次总结一下标记：$x^{(i)[j]\lbrace k\rbrace}$中的上标分别表示和第i个样本相关、和第j层相关、和第k个批次的样本集相关。实际上这三个标记几乎不会同时出现。</p>
<p>使用了分批梯度下降后，算法的写法由</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    update parameters</span><br></pre></td></tr></table></figure>
<p>变成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m / batch_size)</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(batch_size):</span><br><span class="line">      update parameters</span><br></pre></td></tr></table></figure>
<p>。现在的梯度下降法每进行一次内层循环，就更新一次参数。我们还是把一次内层循环称为一个”step（步）”。此外，我们把一次外层循环称为一个”epoch(直译为’时代’，简称‘代’)”，因为每完成一次外层循环就意味着训练集被遍历了一次。</p>
<h3 id="mini-batch-的损失函数变化趋势"><a href="#mini-batch-的损失函数变化趋势" class="headerlink" title="mini-batch 的损失函数变化趋势"></a>mini-batch 的损失函数变化趋势</h3><p>使用分批梯度下降后，损失函数的变化趋势会有所不同:</p>
<p><img src="/2022/06/15/DLS-note-6/2.jpg" alt></p>
<p>如图所示，如果是使用整批梯度下降，则损失函数会一直下降。但是，使用分批梯度下降后，损失函数可能会时升时降，但总体趋势保持下降。</p>
<p>这种现象主要是因为之前我们计算的是整个训练集的损失函数，而现在计算的是每个mini-batch的损失函数。每个mini-batch的损失函数时高时低，可以理解为：某批数据比较简单，损失函数较低；另一批数据难度较大，损失函数较大。</p>
<h3 id="选择批次大小"><a href="#选择批次大小" class="headerlink" title="选择批次大小"></a>选择批次大小</h3><p>批次大小(batch size)对训练速度有很大的影响。</p>
<p>如果批次过大，甚至极端情况下<code>batch_size=m</code>，那么这等价于整批梯度下降。我们刚刚也学过了，如果数据集过大，整批梯度下降是很慢的。</p>
<p>如果批次过小，甚至小到<code>batch_size=1</code>（这种梯度下降法有一个特别的名字：随机梯度下降（Stochastic Gradient Descent）），那么这种计算方法又会失去向量化计算带来的加速效果。</p>
<blockquote>
<p>回想一下第二周的内容：向量化计算指的是一次对多个数据做加法、乘法等运算。这种计算方式比用循环对每个数据做计算要快。</p>
</blockquote>
<p>出于折中的考虑，我们一般会选用一个介于<code>1-m</code>之间的数作为批次大小。</p>
<p>如果数据集过小(<code>m&lt;2000</code>)，那就没必要使用分批梯度下降，直接拿整个数据集做整批梯度下降即可。</p>
<p>如果数据集再大一点，就可以考虑使用<strong>64, 128, 256, 512</strong>这些数作为<code>batch_size</code>。这几个数都是2的次幂。由于电脑的硬件容量经常和2的次幂相关，把<code>batch_size</code>恰好设成2的次幂往往能提速。</p>
<p>当然，刚刚也讲了，使用较大<code>batch_size</code>的一个目的是充分利用向量化计算。而向量化计算要求参与运算的数据全部在CPU/GPU内存上。如果设备的内存不够，则设过大的<code>batch_size</code>也没有意义。</p>
<h2 id="一段数据的平均值"><a href="#一段数据的平均值" class="headerlink" title="一段数据的平均值"></a>一段数据的平均值</h2><blockquote>
<p>在课堂上，这段内容是从数学的角度切入介绍的。我认为这种介绍方式比较突兀。我将从计算机科学的角度切入，用更好理解的方式介绍“指数加权移动平均”。</p>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>假设我们绘制了某年每日气温的散点图：</p>
<p><img src="/2022/06/15/DLS-note-6/3.jpg" alt></p>
<p>假如让你来描述全年气温的趋势，你会怎么描述呢？</p>
<p>作为人类，我们肯定会说：“这一年里，冬天的气温较低。随后气温逐渐升高，在夏天来到最高值。夏天过后，气温又逐渐下降，直至冬天的最低值。”</p>
<p>但是，要让计算机看懂天气的变化趋势，应该怎么办呢？直接拿相邻的天气的差作为趋势可不行。冬天也会出现第二天气温突然升高的情况，夏天也会出现第二天气温突然降低的情况。我们需要一个能够概括<strong>一段时间内</strong>气温情况的指标。</p>
<h3 id="移动平均数"><a href="#移动平均数" class="headerlink" title="移动平均数"></a>移动平均数</h3><p>一段时间里的值，其实就是几天内多个值的总体情况。多个值的总体情况，可以用平均数表示。严谨地来说，假如这一年有365天，我们用$t$表示这一年每天的天气，那么：</p>
<script type="math/tex; mode=display">
t_i=\left\{
\begin{aligned}
&第i天的天气 &(1 \leq i \leq 365) \\
&0 &(i取其他值)
\end{aligned}
\right.</script><p>我们可以定义一种叫做<strong>移动平均数(Moving Averages)</strong> 的指标，表示某天及其前几天温度的平均值。比如对于5天移动平均数$ma$，其定义如下：</p>
<script type="math/tex; mode=display">
ma_i=\frac{t_i+t_{i-1}+t_{i-2}+t_{i-3}+t_{i-4}}{5} (1 \leq i \leq 365)</script><p>假如要让计算机<strong>依次输出</strong>每天的移动平均数，该怎么编写算法呢？我们来看几个移动平均数的例子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
ma_5=(t_5+t_4+t_3+t_2+t_1)/5 \\
ma_6=(t_6+t_5+t_4+t_3+t_2)/5 \\
ma_7=(t_7+t_6+t_5+t_4+t_3)/5
\end{aligned}</script><p>通过观察，我们可以发现$ma_6=ma_5+(t_6-t_1)/5$，$ma_7=ma_6+(t_7-t_2)/5$。</p>
<p>也就是说，在算n天里的m天移动平均数（我们刚刚计算的是5天移动平均数）时，我们不用在n次的外层循环里再写一个m次的循环，只需要根据前一天的移动平均数，减一个值加一个值即可。这种依次输出移动平均数的算法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> temperature[<span class="number">0</span>:n]</span><br><span class="line"><span class="built_in">input</span> m</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_temperature</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">return</span> temperature[i] <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> i &lt; n <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">ma = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    ma += (get_temperature(i) - get_temperature(i - m)) / m</span><br><span class="line">    ma_i = ma</span><br><span class="line">    output ma_i</span><br></pre></td></tr></table></figure>
<p>这种求移动平均数的方法确实很高效。但是，我们上面这个算法是基于所有温度值<strong>一次性给出</strong>的情况。假如我们正在算今年每天温度的移动平均数，每天的温度是一天一天给出的，而不是一次性给出的，上面的算法应该怎么修改呢？让我们来看修改后的算法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> m</span><br><span class="line">temp_i_day_ago = zeros((m))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_temperature</span>(<span class="params">t</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>):</span><br><span class="line">        temp_i_day_ago[i+<span class="number">1</span>] = temp_i_day_ago[i]</span><br><span class="line">    temp_i_day_ago[<span class="number">0</span>] = t</span><br><span class="line"></span><br><span class="line">ma = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="built_in">input</span> t_i</span><br><span class="line">    update_temperature(t_i)</span><br><span class="line">    ma += (temp_i_day_ago[<span class="number">0</span>] - temp_i_day_ago[m]) / m</span><br><span class="line">    ma_i = ma</span><br><span class="line">    output ma_i</span><br></pre></td></tr></table></figure>
<p>由于我们不能提前知道每天的天气，我们需要一个大小为m的数组<code>temp_i_day_ago</code>记录前几天的天气，以计算m天移动平均数。</p>
<p>上述代码的时间复杂度还是有优化空间的。可以用更好的写法去掉<code>update_temperature</code>里的循环，把计算每天移动平均数的时间复杂度变为$O(1)$。但是，这份代码的空间复杂度是无法优化的。为了算m天移动平均数，我们必须要维护一个长度为m的数组，空间复杂度一定是$O(m)$。</p>
<p>对于一个变量的m移动平均数，$O(m)$的空间复杂度还算不大。但假如我们要同时维护l个变量的m移动平均数，整个算法的空间复杂度就是$O(ml)$。在l很大的情况下，m对空间的影响是很大的。哪怕m取5这种很小的数，也意味着要多花4倍的空间去存储额外的数据。空间复杂度里这多出来的这个$m$是不能接受的。</p>
<h3 id="指数加权移动平均"><a href="#指数加权移动平均" class="headerlink" title="指数加权移动平均"></a>指数加权移动平均</h3><p>作为移动平均数的替代，人们提出了<strong>指数加权移动平均数（Exponential Weighted Moving Average）</strong> 这种表示一段时期内数据平均值的指标。其计算公式为：</p>
<script type="math/tex; mode=display">
v_i=\beta v_{i-1} + (1 - \beta)t_i</script><p>这个公式直观上的意义为：一段时间内的平均温度，等于上一段时间的平均温度与当日温度的加权和。</p>
<p>相比普通的移动平均数，指数平均数最大的好处就是减小了空间复杂度。在迭代更新这个新的移动平均数时，我们只需要维护一个当前平均数$v_i$，一个当前的温度$t_i$即可，空间复杂度为$O(1)$。</p>
<p>让我们进一步理解公式中的参数$\beta$。把公式展开可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
v_i&=(1 - \beta)t_i + \beta v_{i-1} \\
v_i&=(1 - \beta)t_i + (1 - \beta)\beta t_{i-1} +\beta^2 v_{i-2} \\ 
v_i&=(1 - \beta)t_i + (1 - \beta)\beta t_{i-1} + (1 - \beta)\beta ^2t_{i-2}+ \beta^3 v_{i-2} \\
...
\end{aligned}</script><p>从这个式子可以看出，之前数据的权重都在以$\beta$的速度指数衰减。根据$(1-\epsilon)^{\frac{1}{\epsilon}} \approx \frac{1}{e}$，并且我们可以认为一个数到了$\frac{1}{e}$就小到可以忽视了，那么指数平均数表示的就是$\frac{1}{1-\beta}$天内数据的平均情况。比如$\beta=0.9$表示的是10天内的平均数据，$\beta=0.99$表示的是100天内的平均数据。</p>
<h3 id="偏差矫正"><a href="#偏差矫正" class="headerlink" title="偏差矫正"></a>偏差矫正</h3><p>指数平均数存在一个问题。在刚刚初始化时，指数平均数的值可能不太正确，请看：</p>
<script type="math/tex; mode=display">
\begin{aligned}
v_1 &=  (1 - \beta)t_1 \\
v_2 &=  (1 - \beta)\beta t_1 +(1 - \beta)t_2
\end{aligned}</script><p>让我们把每一项前面的权重加起来。对于$v_1$，前面的权重和是$(1-\beta)$；对于$v_2$，前面的权重和是$(1-\beta)(\beta+1)$。显然，这两个权重和都不为1。而计算平均数时，我们希望所有数据的权重和为1，这样才能反映出数据的真实大小情况。这里出现了权重上的“偏差”。</p>
<p>为了矫正这个偏差，我们应该想办法把权重和矫正为1。观察刚才的算式可以发现，第$i$项的权重和如下：</p>
<script type="math/tex; mode=display">
w_i = (1-\beta)(1+\beta+\beta^2+...\beta^i)</script><p>根据等比数列求和公式，上式化简为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
w_i &= (1-\beta)\frac{(1-\beta^i)}{(1-\beta)} \\
w_i &= 1-\beta^i
\end{aligned}</script><p>为了令权重和为1，我们可以令每一项指数平均数都除以这个和，即用下面的式子计算矫正后的指数平均数$v_i’$:</p>
<script type="math/tex; mode=display">
v_i'=\frac{v_i}{1-\beta^i}</script><p>但是，在实践中，由于这个和$1-\beta^i$收敛得很快，我们不会特地写代码做这个矫正。</p>
<h2 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h2><p>Gradient Descent with Momentum (使用动量的梯度下降) 是一种利用梯度的指数加权移动平均数更新参数的策略。在每次更新学习率时，我们不用本轮梯度的方向作为梯度下降的方向，而是用梯度的指数加权移动平均数作为梯度下降的方向。即对于每个参数，我们用下式做梯度下降：</p>
<script type="math/tex; mode=display">
\begin{aligned}
V_{dw}&=\beta V_{dw}+ (1-\beta)dw \\
V_{db}&=\beta V_{db}+ (1-\beta)db \\
w &:= w - \alpha V_{dw} \\
b &:= b - \alpha V_{db}
\end{aligned}</script><p>也就是说，对于每个参数$p$，我们用它的指数平均值$v_{dp}$代替$dp$进行参数的更新。</p>
<p>使用梯度的平均值来更新有什么好处呢？让我们来看一个可视化的例子：</p>
<p><img src="/2022/06/15/DLS-note-6/4.jpg" alt></p>
<p>不使用 Momentum 的话，每次参数更新的方向可能变化幅度较大，如上图中的蓝线所示。而使用 Momentum 后，每次参数的更新方向都会在之前的方向上稍作修改，每次的更新方向会更加平缓一点，如上图的红线所示。这样，梯度下降算法可以更快地找到最低点。</p>
<p>在实现时，我们不用去使用偏差矫正。$\beta$取0.9在大多数情况下都适用，有余力的话这个参数也可以调一下。</p>
<h2 id="RMSProp-和-Adam"><a href="#RMSProp-和-Adam" class="headerlink" title="RMSProp 和 Adam"></a>RMSProp 和 Adam</h2><blockquote>
<p>课堂上并没有对RMSProp的原理做过多的介绍，我们只需要记住它的公式就行。我会在其他文章中介绍这几项技术的原理。</p>
</blockquote>
<p>在一个神经网络中，不同的参数需要的更新幅度可能不一样。但是，在默认情况下，所有参数的更新幅度都是一样的（即学习率）。为了平衡各个参数的更新幅度，RMSProp(Root Mean Squared Propagation)  在参数更新公式中添加了一个和参数大小相关的权重$S$。与 Momentum 类似，RMSProp使用了某种移动平均值来平滑这个权重的更新。其梯度下降公式如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
S_{dw}&=\beta S_{dw}+ (1-\beta)dw^2 \\
S_{db}&=\beta S_{db}+ (1-\beta)db^2 \\
w &:= w - \alpha \frac{dw}{\sqrt{S_{dw}}} \\
b &:= b - \alpha \frac{db}{\sqrt{S_{db}}}
\end{aligned}</script><p>在编程实现时，我们应该给分母加一个极小值$\epsilon$，防止分母出现0。</p>
<p>Adam (Adaptive Moment Estimation) 是 Momentum 与 RMSProp 的结合版。为了使用Adam，我们要先计算 Momentum 和 RMSProp 的中间变量：</p>
<script type="math/tex; mode=display">
\begin{aligned}
V_{dw}&=\beta_1 V_{dw}+ (1-\beta_1)dw \\
V_{db}&=\beta_1 V_{db}+ (1-\beta_1)db \\
S_{dw}&=\beta_2 S_{dw}+ (1-\beta_2)dw^2 \\
S_{db}&=\beta_2 S_{db}+ (1-\beta_2)db^2 
\end{aligned}</script><p>之后，根据前面的偏差矫正，获得这几个变量的矫正值：</p>
<blockquote>
<p>如前文所述，在实现时添加偏差矫正意义不大。估计这里加上偏差矫正是因为原论文加了。</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{aligned}
V_{dw}'&=\frac{V_{dw}}{1-\beta_1^t} \\
V_{db}'&=\frac{V_{db}}{1-\beta_1^t} \\
S_{dw}'&=\frac{S_{dw}}{1-\beta_2^t} \\
S_{db}'&=\frac{S_{db}}{1-\beta_2^t} \\
\end{aligned}</script><p>最后，进行参数的更新：</p>
<script type="math/tex; mode=display">
\begin{aligned}
w &:= w - \alpha \frac{V_{dw}'}{\sqrt{S_{dw}'}+\epsilon} \\
b &:= b - \alpha \frac{V_{db}'}{\sqrt{S_{db}'}+\epsilon}
\end{aligned}</script><p>和之前一样，这里的$\epsilon$是一个极小值。在编程时添加$\epsilon$，一般都是为了防止分母中出现0。</p>
<p>Adam是目前非常流行的优化算法，它的表现通常都很优秀。为了用好这个优化算法，我们要知道它的超参数该怎么调。在原论文中，这个算法的超参数取值如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\beta_1 &= 0.9 \\
\beta_2 &= 0.999 \\
\epsilon &= 10^{-8}
\end{aligned}</script><p>绝大多数情况下，我们不用手动调这三个超参数。</p>
<h2 id="学习率衰减"><a href="#学习率衰减" class="headerlink" title="学习率衰减"></a>学习率衰减</h2><p>训练时的学习率不应该是一成不变的。在优化刚开始时，参数离最优值还差很远，选较大的学习率能加快学习速度。但是，经过了一段时间的学习后，参数离最优值已经比较近了。这时，较大的学习率可能会让参数错过最优值。因此，在训练一段时间后，减小学习率往往能够加快网络的收敛速度。这种训练一段时间后减小学习率的方法叫做<strong>学习率衰减</strong>。</p>
<p>其实学习率衰减只是一种比较宏观的训练策略，并没有绝对正确的学习率衰减方法。我们可以设置初始学习率$\alpha_0$，之后按下面的公式进行学习率衰减：</p>
<script type="math/tex; mode=display">
\alpha = \frac{1}{1 + DecayRate \ast EpochNum}\alpha_0</script><p>这个公式非常简单，初始学习率会随着一个衰减率(DecayRate)和训练次数(EpochNum)衰减。</p>
<p>同样，我们还可以使用指数衰减：</p>
<script type="math/tex; mode=display">
\alpha = 0.95^{EpochNum}\alpha_0</script><p>或者其他一些奇奇怪怪的衰减方法(k是超参数）：</p>
<script type="math/tex; mode=display">
\alpha = \frac{k}{\sqrt{EpochNum}}\alpha_0</script><p>甚至我们可以手动调学习率，每训练一段时间就把学习率调整成一个更小的常数。</p>
<p>总之，学习率衰减是一条启发性的规则。我们可以有意识地在训练中后期调小学习率。</p>
<h2 id="局部最优值"><a href="#局部最优值" class="headerlink" title="局部最优值"></a>局部最优值</h2><p>在执行梯度下降算法时，局部最优值可能会影响算法的表现：在局部最优值处，各个参数的导数都是0。梯度是0（所有导数为0），意味着梯度下降法将不再更新了。</p>
<p>在待优化参数较少时，陷入局部最优值是一种比较常见的情况。而对于参数量巨大的深度学习项目来说，整个模型陷入局部最优值是一个几乎不可能发生的事情。某参数在梯度为0时，既有可能是局部最优值，也可能是局部最差值。不妨设两种情况的概率都是0.5。如果整个模型都陷入了局部最优值，那么所有参数都得处于局部最优值上。假设我们的深度学习模型有10000个参数，则一个梯度为0的点是局部最优值的概率是$0.5^{10000}$，这是一个几乎不可能发生的事件。</p>
<p>所以，在深度学习中，更常见的梯度为0的点是鞍点（某处梯度为0，但不是局部最值）。在鞍点处，有很多参数都处于局部最差值上，只要稍微对这些参数做一些扰动，参数就会往更小的方向移动。因此，鞍点不会对学习算法产生影响。</p>
<p>在深度学习中，一种会影响学习速度的情况叫做“高原”（plateau）。在高原处，梯度的值一直都很小。只有跨过了这段区域，学习的速度才会快起来。这种情况的可视化结果如下：</p>
<p><img src="/2022/06/15/DLS-note-6/5.jpg" alt></p>
<p>总而言之，深度学习问题和简单的优化问题不太一样，不用过多担心局部最优值的问题。而高原现象确实会影响学习的速度。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这周，我们围绕深度学习的优化算法，学习了许多提升梯度下降法性能的技术。让我们来捋一捋。</p>
<p>首先，我们可以在处理完一小批数据后就执行梯度下降，而不必等处理完整个数据集后再执行。这种算法叫分批梯度下降（mini-batch gradient descent)。这是一种对梯度下降法的通用改进方法，即默认情况下，这种算法都可以和其他改进方法同时使用。</p>
<p>之后，我们学习了移动平均的概念，知道移动平均值可以更平滑地反映数据在一段时间内的趋势。基于移动平均值，有 gradient descent with momentum 和 RMSProp 这两种梯度下降的改进方法。而现在非常常用的 Adam 优化算法是Momentum 和 RMSProp 的结合版。</p>
<p>最后，我们学习了学习率衰减的一些常见方法。</p>
<p>学完本课的内容后，我认为我们应该对相关知识达到下面的掌握程度：</p>
<ul>
<li>分批梯度下降<ul>
<li>了解原理</li>
<li>掌握如何选取合适的 batch size</li>
</ul>
</li>
<li>高级优化算法<ul>
<li>了解移动平均数的思想</li>
<li>了解 Adam 的公式</li>
<li>记住 Adam 超参数的常见取值</li>
<li>未来学习了编程框架后，会调用 Momentum，Adam 优化器</li>
</ul>
</li>
<li>学习率衰减<ul>
<li>掌握“学习率衰减能加速收敛”这一概念</li>
<li>在训练自己的模型时，能够有意识地去调小学习率</li>
</ul>
</li>
<li>局部最优值<ul>
<li>不用管这个问题</li>
</ul>
</li>
</ul>
<h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><p>这周，官方的编程作业还是点集分类。我觉得这个任务太简单了，还是挑战小猫分类比较有意思。</p>
<p>在这周的代码实战项目中，让我们先回顾一下整个项目的框架，再实现这周学到的技术，包括分批梯度下降(Mini-batch Gradient Descent)、高级梯度下降算法(Mini-batch Gradient Descent)、学习率衰减。</p>
<p>项目链接：<br>​<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/AdvancedOptimizer">https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/AdvancedOptimizer</a></p>
<h2 id="小猫分类项目框架"><a href="#小猫分类项目框架" class="headerlink" title="小猫分类项目框架"></a>小猫分类项目框架</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>和之前一样，我们即将使用一个 kaggle 上的<a target="_blank" rel="noopener" href="https://www.kaggle.com/datasets/fusicfenta/cat-and-dog?resource=download">猫狗分类数据集</a>。我已经写好了读取数据的函数，该函数的定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cat_set</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    data_root: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    img_shape: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>] = (<span class="params"><span class="number">224</span>, <span class="number">224</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="function">    train_size=<span class="number">1000</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    test_size=<span class="number">200</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) -&gt; <span class="type">Tuple</span>[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:</span></span><br></pre></td></tr></table></figure></p>
<p>填入数据集根目录、图像Reszie后的大小、一半训练集的大小、一半测试集的大小，我们就能得到预处理后的<code>train_X, train_Y, dev_X, dev_Y</code>。其中，X的形状是<code>(n_x, m)</code>, Y的形状是<code>(1, m)</code>。<code>n_x</code>是图像的特征数，对于一个大小为(224, 224)的图像，<code>n_x = 224*224*3</code>。m是样本数量，如果<code>train_size=1000</code>，则<code>m=2000</code>。</p>
<p>在之前的实战中，我的模型在训练集上的表现都十分糟糕，还没有用到“测试集”的机会。因此，我们之前那个“测试集”，既可以认为是开发集，也可以认为是测试集。从这周开始，出于严谨性的考虑，我准备把之前的“测试集”正式称作开发集（dev set）。</p>
<h3 id="模型类"><a href="#模型类" class="headerlink" title="模型类"></a>模型类</h3><p>和之前一样，我们用<code>BaseRegressionModel</code>来表示一个最后一层使用sigmoid，loss用交叉熵的二分类模型基类。这个基类的定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRegressionModel</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X: np.ndarray, train_mode=<span class="literal">True</span></span>) -&gt; np.ndarray:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">self, Y: np.ndarray</span>) -&gt; np.ndarray:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_grad_dict</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray]:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray]:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, state_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray]</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">self, Y: np.ndarray, Y_hat: np.ndarray</span>) -&gt; np.ndarray:</span></span><br><span class="line">        <span class="keyword">return</span> np.mean(-(Y * np.log(Y_hat) + (<span class="number">1</span> - Y) * np.log(<span class="number">1</span> - Y_hat)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span>(<span class="params">self, X: np.ndarray, Y: np.ndarray, return_loss=<span class="literal">False</span></span>):</span></span><br><span class="line">        Y_hat = self.forward(X, train_mode=<span class="literal">False</span>)</span><br><span class="line">        Y_hat_predict = np.where(Y_hat &gt; <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        accuracy = np.mean(np.where(Y_hat_predict == Y, <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">if</span> return_loss:</span><br><span class="line">            loss = self.loss(Y, Y_hat)</span><br><span class="line">            <span class="keyword">return</span> accuracy, loss</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> accuracy</span><br></pre></td></tr></table></figure>
<p>在模型类中，和训练有关的主要有<code>forward, backward, get_grad_dict</code>这三个方法，分别表示前向传播、反向传播、梯度获取。</p>
<p>这里要对<code>get_grad_dict</code>做一个说明。之前我们都是直接在模型类里实现梯度下降的，但在这周学了新的优化算法后，这种编程方式就不太方便拓展了。因此，从这周开始，我们应该用一个<code>BaseOptimizer</code>类来表示各种梯度下降算法。模型通过<code>get_grad_dict</code>把梯度传给优化器。</p>
<p>除了和训练相关的方法外，模型类通过<code>save, load</code>来把数据存入/取自一个词典，通过<code>loss, evaluate</code>来获取一些模型评测指标。</p>
<p><code>BaseRegressionModel</code>只是一个抽象基类。实际上，我在本项目使用的是第四周学习的深层神经网络（任意层数的全连接网络）<code>DeepNetwork</code>。只需要传入每一层神经元个数、每一层的激活函数，我们就能得到一个全连接分类网络：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepNetwork</span>(<span class="params">BaseRegressionModel</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, neuron_cnt: <span class="type">List</span>[<span class="built_in">int</span>], activation_func: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>在第四周代码的基础上，我修改了一下参数初始化的方法。由于隐藏层的激活函数都用的是ReLU，我打算默认使用 He Initialization:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">    self.W.append(</span><br><span class="line">        np.random.randn(neuron_cnt[i + <span class="number">1</span>], neuron_cnt[i]) *</span><br><span class="line">        np.sqrt(<span class="number">2</span> / neuron_cnt[i]))</span><br></pre></td></tr></table></figure></p>
<p>除此之外，我没有在这个模型上添加其他高级功能。我也没有添加正则化。现在网络还处于欠拟合状态，等我有资格解决过拟合问题时再去考虑正则化。</p>
<h3 id="优化器类"><a href="#优化器类" class="headerlink" title="优化器类"></a>优化器类</h3><p>看完了模型类，接下来，我们来看一看这周要实现的优化器类。所有的优化器类都继承自基类<code>BaseOptimizer</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseOptimizer</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            self,</span></span></span><br><span class="line"><span class="params"><span class="function">            param_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray],</span></span></span><br><span class="line"><span class="params"><span class="function">            learning_rate: <span class="built_in">float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            lr_scheduler: <span class="type">Callable</span>[[<span class="built_in">float</span>, <span class="built_in">int</span>], <span class="built_in">float</span>] = const_lr</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.param_dict = param_dict</span><br><span class="line">        self._epoch = <span class="number">0</span></span><br><span class="line">        self._num_step = <span class="number">0</span></span><br><span class="line">        self._learning_rate_zero = learning_rate</span><br><span class="line">        self._lr_scheduler = lr_scheduler</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">epoch</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._epoch</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learning_rate</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._lr_scheduler(self._learning_rate_zero, self.epoch)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_epoch</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._epoch += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;epoch&#x27;</span>: self._epoch, <span class="string">&#x27;num_step&#x27;</span>: self._num_step&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, state_dict: <span class="type">Dict</span></span>):</span></span><br><span class="line">        self._epoch = state_dict[<span class="string">&#x27;epoch&#x27;</span>]</span><br><span class="line">        self._num_step = state_dict[<span class="string">&#x27;num_step&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zero_grad</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.grad_dict:</span><br><span class="line">            self.grad_dict[k] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_grad</span>(<span class="params">self, grad_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray]</span>):</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.grad_dict:</span><br><span class="line">            self.grad_dict[k] += grad_dict[k]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这个优化器基类实现了以下功能：</p>
<ul>
<li>维护当前的<code>epoch</code>和<code>step</code>，以辅助其他参数的计算。</li>
<li>维护当前的学习率，并通过使用<code>_lr_scheduler</code>的方式支持学习率衰减。</li>
<li>定义了从词典中保存/读取优化器的方法<code>save, load</code>。</li>
<li>定义了维护的梯度的清空梯度方法<code>zero_grad</code>和新增梯度方法<code>add_grad</code>。</li>
<li>允许子类实现<code>step</code>方法，以使用不同策略更新参数。</li>
</ul>
<p>在后续章节中，我会介绍该如何使用这个基类实现这周学过的优化算法。</p>
<h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>基于上述的<code>BaseRegressionModel</code>和<code>BaseOptimizer</code>，我们可以写出下面的模型训练函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">model: BaseRegressionModel,</span></span></span><br><span class="line"><span class="params"><span class="function">          optimizer: BaseOptimizer,</span></span></span><br><span class="line"><span class="params"><span class="function">          X,</span></span></span><br><span class="line"><span class="params"><span class="function">          Y,</span></span></span><br><span class="line"><span class="params"><span class="function">          total_epoch,</span></span></span><br><span class="line"><span class="params"><span class="function">          batch_size,</span></span></span><br><span class="line"><span class="params"><span class="function">          model_name: <span class="built_in">str</span> = <span class="string">&#x27;model&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          save_dir: <span class="built_in">str</span> = <span class="string">&#x27;work_dirs&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          recover_from: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          print_interval: <span class="built_in">int</span> = <span class="number">100</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          dev_X=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          dev_Y=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> recover_from:</span><br><span class="line">        load_state_dict(model, optimizer, recover_from)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Prepare mini_batch</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(total_epoch):</span><br><span class="line">        <span class="keyword">for</span> mini_batch_X, mini_batch_Y <span class="keyword">in</span> mini_batch_XYs:</span><br><span class="line">            mini_batch_Y_hat = model.forward(mini_batch_X)</span><br><span class="line">            model.backward(mini_batch_Y)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            optimizer.add_grad(model.get_grad_dict())</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">        currrent_epoch = optimizer.epoch</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> currrent_epoch % print_interval == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># print loss</span></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        optimizer.increase_epoch()</span><br><span class="line"></span><br><span class="line">    save_state_dict(model, optimizer,</span><br><span class="line">                    os.path.join(save_dir, <span class="string">f&#x27;<span class="subst">&#123;model_name&#125;</span>_latest.npz&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>训练之前，我们可以从模型文件<code>recover_from</code>里读取模型状态和优化器状态。读取数据是通过<code>load_state_dict</code>实现的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_state_dict</span>(<span class="params">model: BaseRegressionModel, optimizer: BaseOptimizer,</span></span></span><br><span class="line"><span class="params"><span class="function">                    filename: <span class="built_in">str</span></span>):</span></span><br><span class="line">    state_dict = np.load(filename)</span><br><span class="line">    model.load(state_dict[<span class="string">&#x27;model&#x27;</span>])</span><br><span class="line">    optimizer.load(state_dict[<span class="string">&#x27;optimizer&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>在得到某一批训练数据<code>X, Y</code>后，我们可以用下面的代码执行一步梯度下降：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Y_hat = model.forward(X)</span><br><span class="line">model.backward(Y)</span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">optimizer.add_grad(model.get_grad_dict())</span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure>
<p>我们会先调用模型的前向传播<code>forward</code>和反向传播<code>backward</code>，令模型存下本轮的梯度。之后，我们重置优化器，把梯度从模型传到优化器，再调用优化器进行更新。</p>
<p>训练代码中，默认使用了mini-batch。我会在后续章节介绍mini-batch的具体实现方法。</p>
<p>完成了梯度的更新后，我们要维护当前的训练代数<code>epoch</code>。训练了几代后，我们可以评测模型在整个训练集和开发集上的性能指标。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">currrent_epoch = optimizer.epoch</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> currrent_epoch % print_interval == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># print loss</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">optimizer.increase_epoch()</span><br></pre></td></tr></table></figure>
<p>最后，模型训练结束后，我们要保存模型。保存模型是通过<code>save_state_dict</code>实现的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_state_dict</span>(<span class="params">model: BaseRegressionModel, optimizer: BaseOptimizer,</span></span></span><br><span class="line"><span class="params"><span class="function">                    filename: <span class="built_in">str</span></span>):</span></span><br><span class="line">    state_dict = &#123;<span class="string">&#x27;model&#x27;</span>: model.save(), <span class="string">&#x27;optimizer&#x27;</span>: optimizer.save()&#125;</span><br><span class="line">    np.savez(filename, **state_dict)</span><br></pre></td></tr></table></figure>
<p>如果你对<code>np.savez</code>函数不熟，欢迎回顾我在第四周代码实战中对其的介绍。</p>
<p>总之，基于我们定义的<code>BaseRegressionModel</code>和<code>BaseOptimizer</code>，我们可以在初始化完这个两个类的对象后，调用<code>train</code>来完成模型的训练。</p>
<h2 id="使用-Mini-batch"><a href="#使用-Mini-batch" class="headerlink" title="使用 Mini-batch"></a>使用 Mini-batch</h2><h3 id="注意-I-O-开销！"><a href="#注意-I-O-开销！" class="headerlink" title="注意 I/O 开销！"></a>注意 I/O 开销！</h3><p>重申一下，Mini-batch gradient descent 的本意是加快训练速度。如果实现了 Mini-batch 后，程序在其他地方跑得更慢了，那么使用这个算法就毫无意义了。</p>
<p>在我们这个小型的深度学习项目中，从硬盘上读取数据的开销是极大的。下图是执行包含前后处理在内的一轮训练的时间开销分布：</p>
<p><img src="/2022/06/15/DLS-note-6/6.jpg" alt></p>
<p>从图中可以看出，相对于一轮训练，读取数据的开销是极大的。读取数据的时间甚至约等于两轮训练的时间。</p>
<p>在之前的项目中，我一直默认是把训练数据全部读取到内存中，然后再进行训练。这样的好处是网络的训练速度不受硬盘读写速度限制，会加快不少，坏处是训练数据的总量受到电脑内存的限制。</p>
<p>在使用分批梯度下降算法时，为了比较算法在性能上的提升，我们应该继续使用相同的数据管理策略，即把数据放到内存中处理。如果换了算法，还换了数据管理策略，把一次性读取数据改成每次需要数据的时候再去读取，那么我们就无法观察到算法对于性能的提升。</p>
<p>事实上，在大型深度学习项目中，模型执行一轮训练的速度很慢，I/O的开销相对来说会小很多。在这种时候，我们可以仅在需要时再读取数据。不过，在这种情况下，我们依然要保证内存/显存足够支持一轮mini-batch的前向/反向传播。这里要注意一下我们这个小demo和实际深度学习项目的区别。</p>
<h3 id="mini-batch-预处理"><a href="#mini-batch-预处理" class="headerlink" title="mini-batch 预处理"></a>mini-batch 预处理</h3><p>在执行一个epoch(代)的训练时，我们应该保证训练数据是打乱的，以避免极端数据分布给训练带来的副作用。</p>
<p>epoch 与 epoch 之间 mini-batch 的划分是否相同到不是那么重要。理论上来说，数据越平均越好，最好能每个 epoch 都重新划分 mini-batch。但是，为了加速训练，同时让使用 mini-batch 的逻辑更加易懂，我打算先预处理出 mini-batch，之后每个 epoch 都使用相同的划分。</p>
<p>为了方便之后的处理，我们把每个mini-batch的X和Y都单独存入数组<code>mini_batch_XYs</code>。这样，在之后的训练循环里，每个mini-batch的数据就可以直接拿来用了。以下是预处理mini-batch的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m = X.shape[<span class="number">1</span>]</span><br><span class="line">indices = np.random.permutation(m)</span><br><span class="line">shuffle_X = X[:, indices]</span><br><span class="line">shuffle_Y = Y[:, indices]</span><br><span class="line">num_mini_batch = math.ceil(m / batch_size)</span><br><span class="line">mini_batch_XYs = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_mini_batch):</span><br><span class="line">    <span class="keyword">if</span> i == num_mini_batch - <span class="number">1</span>:</span><br><span class="line">        mini_batch_X = shuffle_X[:, i * batch_size:]</span><br><span class="line">        mini_batch_Y = shuffle_Y[:, i * batch_size:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mini_batch_X = shuffle_X[:, i * batch_size:(i + <span class="number">1</span>) * batch_size]</span><br><span class="line">        mini_batch_Y = shuffle_Y[:, i * batch_size:(i + <span class="number">1</span>) * batch_size]</span><br><span class="line">    mini_batch_XYs.append((mini_batch_X, mini_batch_Y))</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们首先用第二周编程练习中学过的<code>permutation</code>生成一个随机排列，并根据这个随机排列打乱数据。</p>
<p>之后的代码就是一段常见的数据除法分块逻辑。对于除得尽和除不尽的mini-batch，我们分开处理，提取出每个mini_batch的X和Y。</p>
<h3 id="mini-batch-训练"><a href="#mini-batch-训练" class="headerlink" title="mini-batch 训练"></a>mini-batch 训练</h3><p>预处理得当的话，用mini-batch进行训练的代码非常简洁。我们只需要在原来的训练循环里加一个对mini-batch的遍历即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(num_epoch):</span><br><span class="line">    <span class="keyword">for</span> mini_batch_X, mini_batch_Y <span class="keyword">in</span> mini_batch_XYs:</span><br><span class="line">        mini_batch_Y_hat = model.forward(mini_batch_X)</span><br><span class="line">        model.backward(mini_batch_Y)</span><br><span class="line">        model.gradient_descent(learning_rate)</span><br></pre></td></tr></table></figure>
<h3 id="mini-batch-的损失函数曲线"><a href="#mini-batch-的损失函数曲线" class="headerlink" title="mini-batch 的损失函数曲线"></a>mini-batch 的损失函数曲线</h3><p>和我们在课堂里学的一样，使用mini-batch后，损失函数的曲线可能不像之前那么平滑。这是因为我们画损失函数曲线时用的是每个mini-batch上的损失函数，而不是整个训练集的损失函数。我得到的一个mini-batch损失函数曲线如下：</p>
<p><img src="/2022/06/15/DLS-note-6/7.jpg" alt></p>
<p>在训练时，我顺手存了一下每个mini-batch的梯度，并在训练结束后对它们进行可视化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mini_batch_loss_list = []</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(num_epoch):</span><br><span class="line">    <span class="keyword">for</span> mini_batch_X, mini_batch_Y <span class="keyword">in</span> mini_batch_XYs:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> plot_mini_batch:</span><br><span class="line">            loss = model.loss(mini_batch_Y, mini_batch_Y_hat)</span><br><span class="line">            mini_batch_loss_list.append(loss)</span><br><span class="line"><span class="keyword">if</span> plot_mini_batch:</span><br><span class="line">    plot_length = <span class="built_in">len</span>(mini_batch_loss_list)</span><br><span class="line">    plot_x = np.linspace(<span class="number">0</span>, plot_length, plot_length)</span><br><span class="line">    plot_y = np.array(mini_batch_loss_list)</span><br><span class="line">    plt.plot(plot_x, plot_y)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="实现高级优化算法"><a href="#实现高级优化算法" class="headerlink" title="实现高级优化算法"></a>实现高级优化算法</h2><p>有了基类<code>BaseOptimizer</code>后，我们只需要实现子类的构造函数和更新函数，就可以实现各种各样的改进梯度下降算法了。让我们看一下这周学习的Momentum, RMSProp, Adam该如何实现。</p>
<h3 id="Momentum-1"><a href="#Momentum-1" class="headerlink" title="Momentum"></a>Momentum</h3><p>Momentum的主要实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Momentum</span>(<span class="params">BaseOptimizer</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="params"><span class="function">                 param_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray],</span></span></span><br><span class="line"><span class="params"><span class="function">                 learning_rate: <span class="built_in">float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 beta: <span class="built_in">float</span> = <span class="number">0.9</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 from_scratch=<span class="literal">False</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(param_dict, learning_rate)</span><br><span class="line">        self.beta = beta</span><br><span class="line">        self.grad_dict = deepcopy(self.param_dict)</span><br><span class="line">        <span class="keyword">if</span> from_scratch:</span><br><span class="line">            self.velocity_dict = deepcopy(self.param_dict)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> self.velocity_dict:</span><br><span class="line">                self.velocity_dict[k] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._num_step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.param_dict:</span><br><span class="line">            self.velocity_dict[k] = self.beta * self.velocity_dict[k] + \</span><br><span class="line">                (<span class="number">1</span> - self.beta) * self.grad_dict[k]</span><br><span class="line">            self.param_dict[k] -= self.learning_rate * self.velocity_dict[k]</span><br></pre></td></tr></table></figure>
<p>在Momentum中，我们主要是维护<code>velocity_dict</code>这个变量。根据课堂里学过的知识，这个变量的值等于梯度的指数移动平均值。因此，我们只需要在<code>step</code>里维护一个指数平均数即可。</p>
<p>为了保存优化器的状态，我们应该在<code>save, load</code>里保存<code>velocity_dict</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>:</span></span><br><span class="line">    state_dict = <span class="built_in">super</span>().save()</span><br><span class="line">    state_dict[<span class="string">&#x27;velocity_dict&#x27;</span>] = self.velocity_dict</span><br><span class="line">    <span class="keyword">return</span> state_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, state_dict: <span class="type">Dict</span></span>):</span></span><br><span class="line">    self.velocity_dict = state_dict.get(<span class="string">&#x27;velocity_dict&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> self.velocity_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.velocity_dict = deepcopy(self.param_dict)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.velocity_dict:</span><br><span class="line">            self.velocity_dict[k] = <span class="number">0</span></span><br><span class="line">    <span class="built_in">super</span>().load(state_dict)</span><br></pre></td></tr></table></figure>
<h3 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h3><p>RMSProp的主要实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMSProp</span>(<span class="params">BaseOptimizer</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="params"><span class="function">                 param_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray],</span></span></span><br><span class="line"><span class="params"><span class="function">                 learning_rate: <span class="built_in">float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 beta: <span class="built_in">float</span> = <span class="number">0.9</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 eps: <span class="built_in">float</span> = <span class="number">1e-6</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 from_scratch=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 correct_param=<span class="literal">True</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(param_dict, learning_rate)</span><br><span class="line">        self.beta = beta</span><br><span class="line">        self.eps = eps</span><br><span class="line">        self.grad_dict = deepcopy(self.param_dict)</span><br><span class="line">        self.correct_param = correct_param</span><br><span class="line">        <span class="keyword">if</span> from_scratch:</span><br><span class="line">            self.s_dict = deepcopy(self.param_dict)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> self.s_dict:</span><br><span class="line">                self.s_dict[k] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._num_step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.param_dict:</span><br><span class="line">            self.s_dict[k] = self.beta * self.s_dict[k] + \</span><br><span class="line">                (<span class="number">1</span> - self.beta) * np.square(self.grad_dict[k])</span><br><span class="line">            <span class="keyword">if</span> self.correct_param:</span><br><span class="line">                s = self.s_dict[k] / (<span class="number">1</span> - self.beta**self._num_step)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s = self.s_dict[k]</span><br><span class="line">            self.param_dict[k] -= self.learning_rate * self.grad_dict[k] / (</span><br><span class="line">                np.sqrt(s + self.eps))</span><br></pre></td></tr></table></figure>
<p>和Momentum类似，我们要维护一个指数平均数权重<code>s_dict</code>，并在更新参数时算上这个权重。由于RMSProp是除法运算，为了防止偶尔出现的除以0现象，我们要在分母里加一个极小值<code>eps</code>。</p>
<p>我在这个优化器中加入了偏差校准功能。如果开启了校准，指数平均数会除以一个<code>(1 - self.beta**self._num_step)</code>。</p>
<p>类似地，RMSProp中也用<code>save, load</code>来保存状态<code>s_dict</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>:</span></span><br><span class="line">    state_dict = <span class="built_in">super</span>().save()</span><br><span class="line">    state_dict[<span class="string">&#x27;s_dict&#x27;</span>] = self.s_dict</span><br><span class="line">    <span class="keyword">return</span> state_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, state_dict: <span class="type">Dict</span></span>):</span></span><br><span class="line">    self.s_dict = state_dict.get(<span class="string">&#x27;s_dict&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> self.s_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.s_dict = deepcopy(self.param_dict)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.s_dict:</span><br><span class="line">            self.s_dict[k] = <span class="number">0</span></span><br><span class="line">    <span class="built_in">super</span>().load(state_dict)</span><br></pre></td></tr></table></figure>
<p>注意，RMSProp实际上是对学习率进行了一个放缩。在把模型的优化算法从Momentum改成RMSProp后，学习率要从头调整。一般来说，RMSProp里的权重<code>s_dict</code>是一个小于1的数。这个数做了分母，等价于放大了学习率。因此，使用RMSProp后，可以先尝试把学习率调小100倍左右，再做进一步的调整。</p>
<h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><p>Adam 的主要实现代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adam</span>(<span class="params">BaseOptimizer</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="params"><span class="function">                 param_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray],</span></span></span><br><span class="line"><span class="params"><span class="function">                 learning_rate: <span class="built_in">float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 beta1: <span class="built_in">float</span> = <span class="number">0.9</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 beta2: <span class="built_in">float</span> = <span class="number">0.999</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 eps: <span class="built_in">float</span> = <span class="number">1e-8</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 from_scratch=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 correct_param=<span class="literal">True</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(param_dict, learning_rate)</span><br><span class="line">        self.beta1 = beta1</span><br><span class="line">        self.beta2 = beta2</span><br><span class="line">        self.eps = eps</span><br><span class="line">        self.grad_dict = deepcopy(self.param_dict)</span><br><span class="line">        self.correct_param = correct_param</span><br><span class="line">        <span class="keyword">if</span> from_scratch:</span><br><span class="line">            self.v_dict = deepcopy(self.param_dict)</span><br><span class="line">            self.s_dict = deepcopy(self.param_dict)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> self.v_dict:</span><br><span class="line">                self.v_dict[k] = <span class="number">0</span></span><br><span class="line">                self.s_dict[k] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._num_step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.param_dict:</span><br><span class="line">            self.v_dict[k] = self.beta1 * self.v_dict[k] + \</span><br><span class="line">                (<span class="number">1</span> - self.beta1) * self.grad_dict[k]</span><br><span class="line">            self.s_dict[k] = self.beta2 * self.s_dict[k] + \</span><br><span class="line">                (<span class="number">1</span> - self.beta2) * (self.grad_dict[k] ** <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> self.correct_param:</span><br><span class="line">                v = self.v_dict[k] / (<span class="number">1</span> - self.beta1**self._num_step)</span><br><span class="line">                s = self.s_dict[k] / (<span class="number">1</span> - self.beta2**self._num_step)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v = self.v_dict[k]</span><br><span class="line">                s = self.s_dict[k]</span><br><span class="line">            self.param_dict[k] -= self.learning_rate * v / (np.sqrt(s) +</span><br><span class="line">                                                            self.eps)</span><br></pre></td></tr></table></figure></p>
<p>Adam 就是把 Momentum 和 RMSProp 结合一下。在Adam中，我们维护<code>v_dict</code>和<code>s_dict</code>两个变量，并根据公式利用这两个变量更新参数。</p>
<blockquote>
<p>这里有一个小细节：在Adam中，<code>eps</code>是写在根号外的，而RMSProp中<code>eps</code>是在根号里面的。这是为了与原论文统一。其实<code>eps</code>写哪都差不多，只要不让分母为0即可。</p>
</blockquote>
<p>类似地，Adam要在状态词典里保存两个变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>:</span></span><br><span class="line">    state_dict = <span class="built_in">super</span>().save()</span><br><span class="line">    state_dict[<span class="string">&#x27;v_dict&#x27;</span>] = self.v_dict</span><br><span class="line">    state_dict[<span class="string">&#x27;s_dict&#x27;</span>] = self.s_dict</span><br><span class="line">    <span class="keyword">return</span> state_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, state_dict: <span class="type">Dict</span></span>):</span></span><br><span class="line">    self.v_dict = state_dict.get(<span class="string">&#x27;v_dict&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    self.s_dict = state_dict.get(<span class="string">&#x27;s_dict&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> self.v_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.v_dict = deepcopy(self.param_dict)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.v_dict:</span><br><span class="line">            self.v_dict[k] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> self.s_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.s_dict = deepcopy(self.param_dict)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.s_dict:</span><br><span class="line">            self.s_dict[k] = <span class="number">0</span></span><br><span class="line">    <span class="built_in">super</span>().load(state_dict)</span><br></pre></td></tr></table></figure>
<p>Adam使用的学习率和RMSProp差不多。如果有一个在RMSProp上调好的学习率，可以直接从那个学习率开始调。</p>
<h2 id="学习率衰减-1"><a href="#学习率衰减-1" class="headerlink" title="学习率衰减"></a>学习率衰减</h2><p>要实现学习率衰减非常容易，我们只需要用一个实时计算学习率的学习率<code>getter</code>来代替静态的学习率即可。在<code>BaseOptimizer</code>中，我们可以这样实现学习率衰减：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseOptimizer</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            self,</span></span></span><br><span class="line"><span class="params"><span class="function">            param_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray],</span></span></span><br><span class="line"><span class="params"><span class="function">            learning_rate: <span class="built_in">float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            lr_scheduler: <span class="type">Callable</span>[[<span class="built_in">float</span>, <span class="built_in">int</span>], <span class="built_in">float</span>] = const_lr</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.param_dict = param_dict</span><br><span class="line">        self._epoch = <span class="number">0</span></span><br><span class="line">        self._num_step = <span class="number">0</span></span><br><span class="line">        self._learning_rate_zero = learning_rate</span><br><span class="line">        self._lr_scheduler = lr_scheduler</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learning_rate</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._lr_scheduler(self._learning_rate_zero, self.epoch)</span><br></pre></td></tr></table></figure>
<p>在<code>BaseOptimizer</code>类中，我们用<code>@property</code>装饰器装饰一个<code>learning_rate</code>方法，以实现一个<code>getter</code>函数。这样，我们在获取<code>optimizer.learning_rate</code>这个属性时，实际上是在调用<code>learning_rate</code>这个函数。</p>
<p>在<code>getter</code>中，我们用<code>_lr_scheduler</code>来实时计算一个学习率。<code>_lr_scheduler</code>是一个函数，该函数应该接受初始学习率、当前的epoch这两个变量，返回一个当前学习率。通过修改这个<code>_lr_scheduler</code>，我们就能使用不同的学习率衰减算法。</p>
<p>在代码中，我只实现了两个简单的学习率衰减函数。首先是常数学习率：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">const_lr</span>(<span class="params">learning_rate_zero: <span class="built_in">float</span>, epoch: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">    <span class="keyword">return</span> learning_rate_zero</span><br></pre></td></tr></table></figure>
<p>之后是课堂上学过的双曲线衰减函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hyperbola_func</span>(<span class="params">decay_rate: <span class="built_in">float</span></span>) -&gt; <span class="type">Callable</span>[[<span class="built_in">float</span>, <span class="built_in">int</span>], <span class="built_in">float</span>]:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scheduler</span>(<span class="params">learning_rate_zero: <span class="built_in">float</span>, epoch: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> learning_rate_zero / (<span class="number">1</span> + epoch * decay_rate)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scheduler</span><br></pre></td></tr></table></figure>
<p><code>get_hyperbola_func</code>是一个返回函数的函数。我们可以用<code>get_hyperbola_func(decay_rate)</code>生成一个某衰减率的学习率衰减函数。</p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>经实验，高级优化技术确实令训练速度有显著的提升。为了比较不同优化技术的性能，我使用2000个小猫分类样本作为训练集，使用了下图所示的全连接网络，比较了<strong>不同batch size</strong>、<strong>不同优化算法</strong>、<strong>不同学习率衰减方法</strong>下整个数据集的损失函数变化趋势。</p>
<p><img src="/2022/06/15/DLS-note-6/8.jpg" alt></p>
<p>以下是实验的结果：</p>
<p>首先，我比较了不同batch size下的mini-batch梯度下降。</p>
<p><img src="/2022/06/15/DLS-note-6/9.jpg" alt></p>
<p>从理论上来看，对于同一个数据集，执行相同的epoch，batch size越小，执行优化的次数越多，优化的效果越好。但是，batch size越小，执行一个epoch花的时间就越多。batch size过小的话，计算单元的向量化计算无法得到充分利用，算法的优化效率（单位时间内的优化量）反而下降了。</p>
<p>上面的实验结果和理论一致。执行相同的epoch，batch size越小，优化的效果越好。同时，batch size越小，误差也更容易出现震荡。虽然看上去batch size越小效果就越好，但由于向量化计算的原因，batch size为64,128,2000时跑一个epoch都差不多快，batch size为8时跑一个epoch就很慢了。我还尝试了batch size为1的随机梯度下降，算法跑一个epoch的速度奇慢无比，程序运行效率极低。最终，我把64作为所有优化算法的batch size。</p>
<p>之后，我比较了普通梯度下降、Momentum、RMSProp、Adam的优化结果。在普通梯度下降和Momentum中，我的学习率为1e-3；在RMSProp和Adam中，我的学习率为1e-5。</p>
<p><img src="/2022/06/15/DLS-note-6/10.jpg" alt></p>
<p>由于不同算法的学习率“尺度”不一样，因此，应该去比较普通梯度下降和Momentum，RMSProp和Adam这两组学习率尺度一样的实验。</p>
<p>对比普通梯度下降和Momentum，可以看出Momentum能够显著地提升梯度下降的性能，并且让误差的变化更加平滑。</p>
<p>对比RMSProp和Adam，可以看出学习率相同且偏小的情况下，Adam优于RMSProp。</p>
<p>感觉Adam的性能还是最优秀的。如果把Adam的学习率再调一调，优化效果应该能够超过其他算法。</p>
<p>最后，我还尝试了三个学习率衰减策略实验。每次实验都使用Adam优化器，初始学习率都是1e-5。第一次实验固定学习率，之后的两次实验分别使用衰减系数0.2，0.005的双曲线衰减公式。以下是实验结果：</p>
<p><img src="/2022/06/15/DLS-note-6/11.jpg" alt></p>
<p>从图中可以看出，由于初始学习率较低，在使用了比较大的衰减系数（=0.2）时，虽然学习的过程很平滑，但是学习速度较慢。而如果使用了恰当的衰减系数，虽然学习率在缓缓降低，但学习的步伐可能更加恰当，学习的速度反而变快了。</p>
<p>不过，RMSProp本身就自带调度学习率的效果。主动使用学习率衰减的效果可能没有那么明显。相比mini-batch和高级优化算法，学习率衰减确实只能算是一种可选的策略。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>我的实验还做得不是很充分。理论上可以再调一调学习率，更加公平地比较不同的学习算法。但是，我已经没有动力去进一步优化超参数了——由于目前学习算法的性能过于优秀，模型已经在训练集上过拟合了，训练准确率达到了80%多，远大于58%的开发准确率。因此，根据上一周学的知识，我的下一步任务不是继续降低训练误差，而是应该使用正则化方法或者其他手段，提高模型的泛化能力。在后续的课程中，我们还会接着学习改进深度学习项目的方法，届时我将继续改进这个小猫分类模型。</p>
<p>其实，过拟合对我来说是一件可喜可贺的事情。前两周，仅使用普通梯度下降时，模型的训练准确率和测试准确率都很低，我还在怀疑是不是我的代码写错了。现在看来，这完全是梯度下降算法的锅。朴素的梯度下降算法的性能实在是太差了。稍微使用了mini-batch、高级优化算法等技术后，模型的训练速度就能有一个质的飞跃。在深度学习项目中，mini-batch, Adam优化器应该成为优化算法的默认配置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/06/11/DLS-note-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/11/DLS-note-5/" class="post-title-link" itemprop="url">吴恩达《深度学习专项》笔记+代码实战（五）：深度学习的实践层面</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-11 15:56:46" itemprop="dateCreated datePublished" datetime="2022-06-11T15:56:46+08:00">2022-06-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="学习提示"><a href="#学习提示" class="headerlink" title="学习提示"></a>学习提示</h1><p>第二门课的知识点比较分散，开始展示每周的笔记之前，我会先梳理一下每周涉及的知识。</p>
<p>这一周会先介绍改进机器学习模型的基本方法。为了介绍这项知识，我们会学习两个新的概念：数据集的划分、偏差与方差问题。知道这两个概念后，我们就能够诊断当前机器学习模型存在的问题，进而找出改进的方法。</p>
<p>之后，我们会针对“高方差问题”，学习一系列解决此问题的方法。这些方法成为“正则化方法”。这周介绍的正则化方法有：添加正则化项、dropout、数据增强、提前停止。</p>
<p>最后，我们会学习几项和神经网络相关的技术。我们会学习用于加速训练的输入归一化，用于防止梯度计算出现问题的参数带权初始化，以及用于程序调试的梯度检查。</p>
<h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="数据集的划分：训练集-开发集-测试集"><a href="#数据集的划分：训练集-开发集-测试集" class="headerlink" title="数据集的划分：训练集/开发集/测试集"></a>数据集的划分：训练集/开发集/测试集</h2><p>在使用机器学习的数据集时，我们一般把数据集分成三份：训练集、开发集、测试集。</p>
<blockquote>
<p>机器学习是比深度学习的父集，表示一个更大的人工智能算法的集合。</p>
<p>开发集（Development Set）另一种常见的称呼是验证集(Validation Set)，即保留交叉验证（Hold-out Cross Validation)。</p>
</blockquote>
<h3 id="三种数据集的定义"><a href="#三种数据集的定义" class="headerlink" title="三种数据集的定义"></a>三种数据集的定义</h3><p>它们三者的区别如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>训练集</th>
<th>开发集</th>
<th>测试集</th>
</tr>
</thead>
<tbody>
<tr>
<td>用于优化参数</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>训练时可见？</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>最终测试时可见？</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
</div>
<p>训练集就是令模型去拟合的数据。对于神经网络来说，我们把某类数据集输入进网络，之后用反向传播来优化网络的参数。这个过程中用的数据集就是训练集。</p>
<p>开发集是我们在训练时调整超参数时用到的数据集。我们会测试不同的超参数，看看模型在开发集上的性能，并选择令模型在开发集上最优的一组超参数。</p>
<p>测试集是我们最终用来评估模型的数据集。当模型在测试集上评测时，我们的模型已经不允许修改了。我们一般把模型在测试集上的评测结果作为模型的性能评估标准。</p>
<blockquote>
<p>在我们之前实现的小猫分类项目中，准确来说，我们使用的不叫测试集，而叫做开发集，因为我们是根据那个”testing set”优化网络超参数的。</p>
<p>有人把训练集比作上课，开发集比作作业，测试集比作考试。如果你理解了这三个数据集的原理，会发现这个比喻还是挺贴切的。事实上，由于测试集不参与训练，一个机器学习项目可以没有测试集，就像我们哪怕不经过考试，也可以学到知识一样。</p>
<p>人们很容易混淆开发集/测试集。很多论文甚至把开发集作为最终的性能评估结果。但是很多时候审稿人对这些细节并不在意。作为有操守的研究者，应该严肃地区分开发集与测试集。</p>
</blockquote>
<h3 id="通过划分数据得到训练-测试集"><a href="#通过划分数据得到训练-测试集" class="headerlink" title="通过划分数据得到训练/测试集"></a>通过划分数据得到训练/测试集</h3><p>在前一个机器学习纪元，人们通常会拿到一批数据，按7:3的比例划分训练集/测试集（对于没有超参数要调的模型），或者按6:2:2的比例划分训练集/开发集/测试集。</p>
<p>而在深度学习时代，数据量大大增加。实际上，开发集和测试集的目的都是评估模型，而评估模型所需的数据没有训练需要得那么多。所以，当整体的数据规模达到百万级，甚至更多时，我们只需要各取10000组数据作为开发集和测试集即可。</p>
<h3 id="收集来自不同分布的数据集"><a href="#收集来自不同分布的数据集" class="headerlink" title="收集来自不同分布的数据集"></a>收集来自不同分布的数据集</h3><p>除了从同一批数据中划分出不同的数据集，还有另一种得到训练集、测试集的方式——从不同分布中收集数据集。</p>
<blockquote>
<p><strong>分布</strong>是统计学里的概念，这里可以理解成不同来源，内容的“平均值”差别很大的数据。</p>
</blockquote>
<p>比如，假如我们要为某个小猫分类器收集小猫的图片，我们的训练图片可以是来自互联网，而开发和验证的数据来自用户用收集拍摄的图片。</p>
<p>注意，由于开发集和验证集都是用来评估的，它们应该来自同一个分布。</p>
<h2 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h2><p>机器学习中，我们的模型会出现高偏差或/和高误差的问题。我们需要设法判断我们的模型是否有这些问题。</p>
<p>偏差(bias)与方差(variance)是统计学里的概念，前者表示一组数据离期待的平均值的差距，后者表示数据的离散程度。</p>
<blockquote>
<p>试想一个射击运动员在打靶。偏差与打靶的总分数有关，因为总分越高，意味着每次射击都很靠近靶心；方差与选手的发挥稳定性有关，比如一个不稳定的选手可能一次9环，一次6环。</p>
</blockquote>
<p>高偏差意味着模型总是不能得到很好的结果，高方差意味着模型不能很好地在所有数据集上取得好的结果（即只能在某些特定数据集上表现较好，在其他数据集上都表现较差）。</p>
<p>我们把高偏差的情况叫做“欠拟合”（可能模型还没有训练完，所以表现不够好），把高方差的情况叫做“过拟合”（模型在训练集上训练过头了，结果模型只能在训练集上有很好的表现，在其他数据集上表现偶读不好）。</p>
<p>让我们看课件里的一个点集分类的例子：</p>
<p><img src="/2022/06/11/DLS-note-5/2.jpg" alt></p>
<p>上图显示了欠拟合、“恰好”、过拟合这三种情况。</p>
<p>对于欠拟合的情况来说，一条直线并不足以把两类点分开，这个模型的整体表现较差。</p>
<p>对于过拟合的情况来说，模型过分追求训练集上的正确，结果产生了一条很奇怪的曲线。由于训练数据是有噪声（数据的标签不完全正确）的，这样的模型在真正的测试上可能表现不佳。</p>
<p>让我们人类来划分的话，最有可能给出的是中间那种划分结果。在这个模型中，虽然有些训练集中的点划分错了，但我们会认为这个模型在绝大多数数据上更合适。当我们用更多的测试数据来测试这个模型时，中间那幅图的测试结果肯定是这三种中最好的。</p>
<p>要判断机器学习模型是否存在高偏差或高方差的现象，可以去观察模型的训练集误差和开发集误差。以下是一个判断示例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>情况</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>训练集误差</td>
<td>1%</td>
<td>15%</td>
<td>0.5%</td>
<td>15%</td>
</tr>
<tr>
<td>开发集误差</td>
<td>11%</td>
<td>16%</td>
<td>1%</td>
<td>30%</td>
</tr>
<tr>
<td>诊断结果</td>
<td>高方差</td>
<td>高偏差</td>
<td>低误差、低方差</td>
<td>高误差、高方差</td>
</tr>
</tbody>
</table>
</div>
<p>也就是说，如果开发集和训练集的表现差很多，就说明是高方差；如果训练集上的表现都很差，就是高偏差。</p>
<blockquote>
<p>上面这些结论建立在最优误差——贝叶斯误差(Beyas Error)是0%的基础上下的判断。很多时候，仅通过输入数据中的信息，是不足以下判断的。比如告诉一个人是长头发，虽然这个人大概率是女生，但我们没有100%的把握说这是女生。如果我们知道人群中留长发的90%是女生，10%是男生，那么在这个“长头发分辨性别”的任务里的贝叶斯误差就是10%。</p>
<p>假如上面那个任务的贝叶斯误差是15%，那么我们认为情况2也是一个低误差的情况，因为它几乎做到了最优的准确率。</p>
</blockquote>
<h2 id="改进机器学习的基本方法"><a href="#改进机器学习的基本方法" class="headerlink" title="改进机器学习的基本方法"></a>改进机器学习的基本方法</h2><p>通过上一节介绍的看训练误差、测试误差的方式，我们能够诊断出我们的模型当前是否存在高偏差或高误差的问题。这一节我们来讨论如何解决这些问题。</p>
<p>首先检查高偏差问题。如果模型存在<strong>高偏差</strong>，则应该尝试使用<strong>更复杂的网络</strong>、<strong>更多增加训练时间</strong>。</p>
<p>确保模型没有高偏差问题后，才应该开始检查模型的方差。如果模型存在<strong>高方差</strong>，则应该<strong>增加数据</strong>或<strong>使用正则化</strong>。</p>
<p>此外，使用更合理的网络架构，往往对降低误差和方差都有效。</p>
<h2 id="正则化-Regularization"><a href="#正则化-Regularization" class="headerlink" title="正则化 (Regularization)"></a>正则化 (Regularization)</h2><p>其实正则化的意思就是“为防止过拟合而添加额外信息的过程”。在机器学习中，一种正则化方法是给损失函数添加一些<strong>与参数有关的额外项</strong>，以调整参数在梯度下降中的更新过程。正则化的数学原理我们会在下一节里学习，这一节先认识一下正则化是怎么操作的。</p>
<p>先看一下，对于简单的逻辑回归，我们应该怎么加正则化项。</p>
<p>原来，逻辑回归的损失函数是:</p>
<script type="math/tex; mode=display">
J(w, b) = \frac{1}{m}\Sigma_{i=1}^{m}L(\hat{y}, y)</script><p>现在我们给它加一个和参数$w$有关的项</p>
<script type="math/tex; mode=display">
J(w, b) = \frac{1}{m}\Sigma_{i=1}^{m}L(\hat{y}, y) + \frac{\lambda}{2m}||w^2||_2</script><p>最右边那个 $\frac{\lambda}{2m}||w||^2_2$ 就是额外加进来的正则项。其中$\lambda$是一个可调的超参数，$||w||^2_2$表示计算向量$w$的l2范数，即:</p>
<script type="math/tex; mode=display">
||w||^2_2 = \Sigma_{j=1}^{n_x}w_j^2</script><p>也就是说，某向量的l2范数就是它所有分量平方再求和。</p>
<p>类似地，其实向量也有1范数，也可以用来做正则化：</p>
<script type="math/tex; mode=display">
||w||_1 = \Sigma_{j=1}^{n_x}|w_j|</script><p>1范数就是向量所有分量取绝对值再求和。</p>
<p>使用1范数做正则化会导致参数中出现很多0。人们还是倾向使用l2范数做正则化。</p>
<p>看到这里，大家或许会有问题：$b$也是逻辑回归的参数，为什么$w$有正则项，$b$就没有？实际上，要给$b$加正则项也可以。但是在大多数情况下，参数$w$的数量远多于$b$, 和$b$相关的正则项几乎不会影响到最终的损失函数。为了让整个过程更简洁一些，$b$的正则项就被省略了。（其实就是程序员们偷懒了，顺便让计算机也偷个懒）</p>
<p>当情况推广到神经网络时，添加正则项的方法是类似的，只不过参数$W$变成了矩阵而已。对应的正则项如下：</p>
<script type="math/tex; mode=display">
\frac{\lambda}{2m}\Sigma_{l=1}^{L}||W^{[l]}||_F^2</script><p>其中,</p>
<script type="math/tex; mode=display">
||W^{[l]}||_F^2 = \Sigma_{i=1}^{n^{[l]}}\Sigma_{j=1}^{n^{[l-1]}}(W_{ij}^{[l]})^2</script><p>这种矩阵范数叫做Frobenius范数，叫它F-范数就行了。</p>
<p>如之前的文章所述，对于梯度下降算法来说，定义损失函数的根本目的是为了对参数求导。当参数$W$在损失函数里多了一项后，它的导数会有怎样的变化呢？</p>
<p>对于某参数向量$w$来说，其实它的导数就多了一项：</p>
<script type="math/tex; mode=display">
\begin{align*}
& (\frac{\lambda}{2m}w^2)' \\
=& \frac{\lambda}{m}w
\end{align*}</script><blockquote>
<p>大家知道为什么正则项分母里有一个2了吗？没错，这是为了让求出来的导数更简洁一点。反正有超参数$\lambda$，分母多个2少个2没有任何区别。</p>
</blockquote>
<p>最终，参数向量$w$会按如下的方式更新：</p>
<script type="math/tex; mode=display">
\begin{align*}
w &:= w - \alpha (dw +\frac{\lambda}{m}w) \\
\Rightarrow w &:=(1-\frac{\alpha\lambda}{m})w-\alpha dw
\end{align*}</script><p>仔细一看，其实相较之前的梯度更新公式，只是$w$的系数从$1$变成了$1-\frac{\alpha\lambda}{m}$。因此，用l2范数做正则化的方法会被称为 <strong>“权重衰减(Weight Decay)”</strong> ,$\lambda$在某些编程框架中直接就被叫做<code>weight decay</code>。</p>
<h2 id="为什么正则项能减少方差"><a href="#为什么正则项能减少方差" class="headerlink" title="为什么正则项能减少方差"></a>为什么正则项能减少方差</h2><p>回忆前面见过的“高方差”的拟合曲线：</p>
<p><img src="/2022/06/11/DLS-note-5/3.jpg" alt></p>
<p>这个曲线之所以能够那么精确地过拟合，是因为这个曲线的参数过多。如果这个曲线的参数少一点，那么它就不会有那么复杂的形状，过拟合现象也会得到缓解。</p>
<p>也就是说，如果神经网络简单一点，每个参数对网络的影响小一点，那么网络就更难去过拟合那些极端的数据。</p>
<p>添加了正则项后，网络的参数都受到了一定的“惩罚”。因此，参数会倾向于变得更小，从而产生刚刚提到的减轻过拟合的效果。</p>
<h2 id="Dropout-失活"><a href="#Dropout-失活" class="headerlink" title="Dropout (失活)"></a>Dropout (失活)</h2><blockquote>
<p>Dropout 怎么翻译都不好听，直接保持英文吧。</p>
</blockquote>
<p>还有一种常用的正则化方法叫做 dropout，即随机使神经网络中的一些神经元“失活”。如下图所示：</p>
<p><img src="/2022/06/11/DLS-note-5/4.jpg" alt></p>
<p>我们可以令所有神经元<strong>在每轮训练中</strong>有50%的几率失活。在某轮训练中，神经网络的失活情况可能会像上图中下半部分所示：那些打叉的神经元不参与计算和，整个神经网络变得简单了许多。</p>
<p>在实现时，我们常常使用一种叫做”Inverted dropout”的实现方法。Inverted dropout 的思想是：<strong>对于神经网络的每一层</strong>，生成一个表示有哪些神经元失活的“失活矩阵”，再用这个矩阵去乘上这一层的激活输出（做乘法即令没有失效的激活保持原值，失效的激活取0）</p>
<p>其实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = np.random.rand(a.shape[<span class="number">0</span>], a.shape[<span class="number">1</span>]) &lt; keep_prob</span><br><span class="line">a = a * d</span><br><span class="line">a /= keep_prob</span><br></pre></td></tr></table></figure>
<p>这段代码中，<code>d</code>是失活矩阵。该矩阵通过一个随机数矩阵和一个保留概率<code>keep_prob</code>做小于运算生成。<code>np.random.rand</code>可以生成一个矩阵，其中矩阵中每个数都会均匀地随机出现在0~1之间。这样，每个数小于<code>keep_prob</code>的概率都是<code>keep_prob</code>。比如<code>keep_prob=0.8</code>,那么每个神经元都有80%的几率得到保留，20%的几率被丢弃。</p>
<p>做完小于运算后，<code>d</code>其实是一个bool值矩阵。拿bool矩阵和一个普通矩阵做逐对乘法，就等于bool矩阵为True的地方取普通矩阵的原值，bool矩阵为False的地方取0。</p>
<p>最后，得到了丢弃掉某些神经元的激活输出a后，我们还要做一个操作<code>a /= keep_prob</code>。可以想象，如果我们丢掉了一些神经元，那么整个激活输出的“总和”的期望会变小。比如<code>keep_prob</code>为0.8，那么整个输出的大小都近似会变为原来的0.8倍。为了让输出的期望不变，我们要把激活输出除以<code>keep_prob</code>。</p>
<p>如前文所强调的，dropout一次是对一层而言的。也就是说，每一层可以有不同的<code>keep_prob</code>。</p>
<p>dropout可能对损失函数变化曲线产生影响。一般调试时，如果损失函数一直在降，就说明训练算法没什么问题。但是，加入dropout后，由于每次优化的参数不太一样了，损失函数可能不会单调递减。因此，为了调试神经网络，可以先关闭dropout。确定损失函数确实在下降后，再开启它。</p>
<blockquote>
<p>由于在CV（计算机视觉）中，图像的输入规模都很大，数据不足而引起过拟合是一件常见的事。因此，dropout在CV中被广泛应用。</p>
</blockquote>
<p>注意，dropout是一种训练策略。在测试的时候，不需要使用dropout。</p>
<p>和刚才一样，我们再来探讨一下为什么dropout能够生效。有了dropout，意味着神经网络的权重不能集中在部分神经元上，因为某个神经元随时都可能会失效。因此，神经网络的权重会更加平均。更加平均，意味着计算参数平方的l2范数会更小。也就是说，dropout令参数更平均，起到了和刚刚添加l2正则类似的效果。</p>
<h2 id="其他正则化方法"><a href="#其他正则化方法" class="headerlink" title="其他正则化方法"></a>其他正则化方法</h2><ol>
<li>数据增强</li>
</ol>
<p><img src="/2022/06/11/DLS-note-5/5.jpg" alt></p>
<p>比如对于一幅图片，我们可以翻转、旋转、缩进，以生成“更多”的训练数据。</p>
<ol>
<li>提前停止 (early stopping)</li>
</ol>
<p><img src="/2022/06/11/DLS-note-5/6.jpg" alt></p>
<p>随着训练的进行，网络的损失函数可能越来越小，但开发集上的精度会越来越高。只是因为训练得越久，参数就会越来越大，即越来越倾向于过拟合。提早结束训练，能够让参数取到一个合适的值。</p>
<p>提前中止也有一些不好的地方。在机器学习中，训练模型可以分成两部分：让损失函数更小、防止模型过拟合。我们通常会对这两部分独立地进行优化，即控制优化方法不变，改变正则化方法；或者改变减小梯度的算法，保证模型不进行任何正则化操作。而提前中止实际上混淆了减小损失函数和防止模型过拟合这两件事，不利于采取更多的调试策略。</p>
<blockquote>
<p>独立地看待问题的两个变量，这种方法叫做 <strong>“正交化”</strong>。这种控制变量的思想在科研、编程，甚至是处理人生中各种各样的问题时都很适用。</p>
</blockquote>
<h2 id="输入归一化-Normalization"><a href="#输入归一化-Normalization" class="headerlink" title="输入归一化(Normalization)"></a>输入归一化(Normalization)</h2><blockquote>
<p>参考网上的翻译，我把 Normalization 翻译为归一化，Standardization 翻译成标准化。其实这两个中文翻译经常会混着用，翻译上的区别不用太在意。</p>
</blockquote>
<p>我们应该尽可能让输入向量的每一个分量都满足标准正态分布。如果你对数学不熟，我们可以来看一个例子:</p>
<p><img src="/2022/06/11/DLS-note-5/7.jpg" alt></p>
<p>假设我们每个输出张量长度为2，即有两个分量:$x_1, x_2$。我们可以认为每个输入向量就是一个二维平面上的点。统计完了所有样本，我们或许可以发现所有样本的$x_1$位于[0, 5]这个区间，$x_2$位于[0, 3]这个区间，两个区间长度不一。而且，数据在$x_1$上比较分散,$x_2$上比较靠拢。这个训练样本显得非常凌乱。</p>
<p>如果我们让输入归一化，使输入向量的每一个分量都满足了正态分布，难么这些数据可能会长得这样:</p>
<p><img src="/2022/06/11/DLS-note-5/8.jpg" alt></p>
<p>这样，数据分布的区间不仅长度相同，而且离散的程度也相同了。</p>
<p>归一化可以通过以下方式实现：</p>
<script type="math/tex; mode=display">
\mu=\frac{1}{m}\Sigma_{i=1}^{m}x^{(i)} \\
x := (x - \mu) \\
\sigma^2=\frac{1}{m}\Sigma_{i=1}^{m}(x^{(i)})^2 \\
x := x / \sigma</script><blockquote>
<p>注意，上式中我们计算方差时没有减均值，这是因为第二步更新的时候均值已经被减掉了。</p>
</blockquote>
<p>简单概括这个数学公式，就是“减均值，除方差”。</p>
<p>如果输入数据在各个分量上更加均匀，梯度下降的优化会更加便捷。</p>
<blockquote>
<p>这里直接记住这个结论，不用过于在意它的数学原理。一种比较直观的解释是：如果分量大小不一，则参数w的每个分量的“作用”也会大小不一。如果w的每个分量都按差不多的“步伐”进行更新，那些“影响力更大”的w分量就会更新得过头，而“影响力更小”的w分量就更新得不足。这样，梯度下降法要耗费更多步才能找到最优值。<br><img src="/2022/06/11/DLS-note-5/9.jpg" alt></p>
</blockquote>
<h2 id="梯度爆炸-弥散"><a href="#梯度爆炸-弥散" class="headerlink" title="梯度爆炸/弥散"></a>梯度爆炸/弥散</h2><p>如果一个神经网络的层数过深，可能会出现梯度极大或极小的情况，让我们看看这是怎么回事。</p>
<p><img src="/2022/06/11/DLS-note-5/10.jpg" alt></p>
<p>假设我们有上图这样一个“很深”的神经网络。我们取消所有的激活函数（即$g(x)=x$），取消所有参数$b$（即$b=0$），那么这个网络的公式就是</p>
<script type="math/tex; mode=display">
\hat{Y}=A=W^W^NaN...W^1X</script><p>其中$W^NaN…W^1$都是2x2的矩阵。我们不妨假设它们都是同样的矩阵，那么上式可以写成</p>
<script type="math/tex; mode=display">
\hat{Y}=A=W^(W')^{L-1}X</script><p>如果$W’$长这个样子：</p>
<script type="math/tex; mode=display">
W'=\left[
  \begin{matrix}
  &1.5  &0 \\
  &0  &1.5 \\
  \end{matrix}
\right]</script><p>那么经过$L-1$次矩阵乘法后，这个矩阵就变成这个样子：</p>
<script type="math/tex; mode=display">
W'^{L-1}=\left[
  \begin{matrix}
  &1.5^{L-1}  &0 \\
  &0  &1.5^{L-1}  \\
  \end{matrix}
\right]</script><p>由于这里的数值是随着$L$成指数增长的，$L$稍微取一个大一点的值，最后算出来的$A$就会特别大。回顾一下前面的知识，最后一层的$dZ=A-Y$，而$dW$又是和$dZ$相关的。最后的$A$很大，会导致所有算出来的梯度都很大。</p>
<blockquote>
<p>这里要批评一下这门课。课堂里有一个地方讲得不够清楚：为什么$A$很大，参数的梯度$dW$就很大。课堂里只是带了一句，说可以用类似的方法得出$dW$的增长规律和$A$类似。但这里漏了一条逻辑链：算梯度的时候，$A$和$dW$有关联性（$dZ$和$A$有关，$dW$和$dZ$有关）。直观上来看，$A$很大，不能推出梯度就很大。中间还是欠缺了一步逻辑推理的。学东西和看东西一定要养成批判性思维，考据每一步推理的合理性。</p>
</blockquote>
<p>同理，如果矩阵里的数不是1.5，而是0.5，那么整个公式的数值就会指数级下降，从而导致梯度近乎“消失”。</p>
<h2 id="梯度问题的解决方法——加权初始化"><a href="#梯度问题的解决方法——加权初始化" class="headerlink" title="梯度问题的解决方法——加权初始化"></a>梯度问题的解决方法——加权初始化</h2><blockquote>
<p>推荐一篇讲这个知识点的英文文章：<a target="_blank" rel="noopener" href="https://towardsdatascience.com/weight-initialization-in-neural-networks-a-journey-from-the-basics-to-kaiming-954fb9b47c79">https://towardsdatascience.com/weight-initialization-in-neural-networks-a-journey-from-the-basics-to-kaiming-954fb9b47c79</a>.</p>
</blockquote>
<p>刚刚我们讲到，梯度会爆炸或者弥散，本质原因是矩阵$W$的“大小”大于了1或者小于了1，从而使最后的计算结果过大或过小。但反过来想，如果我们令每一层的输出$A^{[l]}$的“大小”都在1附近，那么是不是就不会有梯度指数级变化的问题了呢？</p>
<p>让我们来看看该如何让每层输出$A^{[l]}$都保持一个合适的值。我们考察</p>
<script type="math/tex; mode=display">Z=w_1x_1+w_2x_2...+w_nx_n</script><p>这个简单的网络。从直觉上看，如果$n$越大，则公式里的项越多，$Z$也越大。事实上，用统计学知识计算过后，能知道：若$w_i$都是满足标准正态分布的，则$Z$的方差是$n$。我们不希望$Z$的值太大或太小，希望能通过修改$w_i$的大小，让$Z$的方差尽可能等于1。</p>
<p>为了做到这一点，我们可以在$w$的初始化方法上做一点文章。我们可以改变$w$的方差，以改变$Z$的方差。其实，我们只要令$w$的方差为$\frac{1}{n}$就行了。用代码表示就是这样的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W_l = np.random.randn(shape) * np.sqrt(<span class="number">1</span> / n[l-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>别忘了哦，这里<code>n[l-1]</code>是第l层参数矩阵<code>W_l</code>的长度，即每个参数向量$w$的长度。</p>
<p>但由于每一层的输入不是$Z$，而是$A=g(Z)$，我们在算方差时还要考虑到激活函数$g$的影响。</p>
<p>经 Kaiming He 等人的研究，使用 Relu 时，初始化的权重用<code>np.sqrt(2/ n[l-1])</code>比较好，即用下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W_l = np.random.randn(shape) * np.sqrt(<span class="number">2</span> / n[l-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>对于 tanh 函数，令权重为 <code>np.sqrt(1 / n[l-1])</code>就行，这叫做 Xavier Initialization。还有研究表明用 <code>np.sqrt(2 / (n[l-1]+n[l]))</code>也行。</p>
<p>总结一下，为了<strong>缓解</strong>梯度爆炸或梯度弥散的问题，可以对参数使用加权初始化。只需要初始化时多乘一个小系数，这个问题就能很大程度上有所缓解。</p>
<h2 id="梯度检查"><a href="#梯度检查" class="headerlink" title="梯度检查"></a>梯度检查</h2><p>进行深度学习编程时，梯度计算是比较容易出BUG的地方。我们可以用一种简单的方法来<strong>近似估计</strong>一个函数的导数，并将其与我们算出来的导数做一个对比，看看我们的导数计算函数有没有写错。</p>
<p>导数估计公式如下：</p>
<script type="math/tex; mode=display">
f'(\theta) \approx \frac{f(\theta+\epsilon)-f(\theta+\epsilon)}{2\epsilon}</script><p>这个式子随$\epsilon$收敛得较块，准确来说:</p>
<script type="math/tex; mode=display">
\begin{align}
f(\theta+\epsilon)&\approx f(\theta)+\epsilon f'(\theta)+\frac{1}{2}\epsilon^2f''(\theta) + \frac{1}{6}\epsilon^3f'''(\theta)+... \\
\frac{f(\theta+\epsilon)-f(\theta)}{\epsilon} &\approx  f'(\theta)+\frac{1}{2}\epsilon f''(\theta) \\
\frac{f(\theta+\epsilon)-f(\theta-\epsilon)}{2\epsilon} &\approx  f'(\theta)+\frac{1}{6}\epsilon^2 f'''(\theta)
\end{align}</script><p>当$lim_{\epsilon \to 0}$时，上面(2)式的收敛速度是$O(\epsilon)$，(3)式的收敛速度是$O(\epsilon^2)$。选用(3)式估计导数是一个更好的选择。</p>
<p>我们可以利用上面的公式调试深度学习中的梯度计算。其步骤如下：</p>
<ol>
<li>把所有参数$W^{[1]}, b^{[1]}…$ reshape 成向量，再把所有向量拼接(concatenate) 成一个新向量$\theta$。</li>
<li>现在，我们有损失函数$J(\theta)$和导数$d\theta$。</li>
<li>对于某一个参数$\theta_i$，计算其导数估计值：</li>
</ol>
<script type="math/tex; mode=display">
\hat{d_{\theta_i}}=\frac{J(\theta_0, ..., \theta_i+\epsilon, ...)-J(\theta_0, ..., \theta_i-\epsilon, ...)}{2\epsilon}</script><ol>
<li>比较$\hat{d_{\theta_i}}, d_{\theta_i}$，计算误差值：</li>
</ol>
<script type="math/tex; mode=display">
error=\frac{||\hat{d_{\theta_i}}-d_{\theta_i}||_2}{||\hat{d_{\theta_i}}||_2\cdot||d_{\theta_i}||_2}</script><ol>
<li>遍历所有$\theta_i$，做这个检查。</li>
</ol>
<p>一般可以令$\epsilon=10^{-7}$。如果error在$10^{-7}$这个量级，则说明导数计算得没什么问题。$10^{-5}$可能要注意一下，而$10^{-3}$则大概率说明这里的导数算得有问题。</p>
<p>使用此梯度检查法时，有一些小提示：</p>
<ul>
<li>不要每次训练的都用，只在训练前调试用。</li>
</ul>
<blockquote>
<p>梯度检查确实很慢，计算复杂度是$\Omega(|\theta|^2)$（这里没有用大O标记，因为复杂度的下界是那个值，而不是上界）（这个复杂度是$|\theta|$乘上算一遍推理的运算量得来的。推理至少遍历每个参数一遍，所以推理的复杂度是$\Omega(|\theta|)$）。</p>
</blockquote>
<ul>
<li><p>如果梯度检查出现了问题，尝试debug具体出错的参数。</p>
</li>
<li><p>别忘记损失函数中的正则化项。</p>
</li>
<li><p>无法调试 dropout.</p>
</li>
<li><p>有时候，当$W, b$过大时导数的计算才会出现较大的误差。可以尝试先训练几轮网络，等参数大了，再做一次梯度检查。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这堂课的信息量十分大。让我们总结一下：</p>
<ul>
<li>数据集划分<ul>
<li>训练集/开发集/测试集的意义</li>
<li>怎么去根据数据规模划分不同的数据集</li>
</ul>
</li>
<li>偏差与方差<ul>
<li>如何分辨高偏差与高方差问题</li>
<li>高偏差与高方差问题的一般解决思路</li>
</ul>
</li>
<li>正则化<ul>
<li>权重衰减</li>
<li>dropout</li>
<li>数据增强</li>
<li>提前停止</li>
</ul>
</li>
<li>梯度问题<ul>
<li>梯度问题的产生原因</li>
<li>缓解梯度问题的方法</li>
</ul>
</li>
<li>梯度检查的实现</li>
</ul>
<p>这堂课中，<strong>正则化</strong>和<strong>参数带权初始化</strong>是两个很重要的话题，展开来的话有很多东西要学。过段时间，我会在课堂内容的基础上，对这些知识进行拓展介绍。</p>
<h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><p>在本周的代码实战中，我们将继续以点集分类任务为例，完成<strong>参数初始化</strong>和<strong>正则化</strong>两项任务。</p>
<h2 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/Initialization">https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/Initialization</a></p>
<p>在参数初始化问题中，我们要探究不同初始化方法对梯度更新的影响。假设我们有下面这样一个点集分类数据集：</p>
<p><img src="/2022/06/11/DLS-note-5/11.jpg" alt></p>
<p>我们分别用下面三种方法去初始化参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> initialization == <span class="string">&#x27;zeros&#x27;</span>:</span><br><span class="line">    self.W.append(np.zeros((neuron_cnt[i + <span class="number">1</span>], neuron_cnt[i])))</span><br><span class="line"><span class="keyword">elif</span> initialization == <span class="string">&#x27;random&#x27;</span>:</span><br><span class="line">    self.W.append(</span><br><span class="line">        np.random.randn(neuron_cnt[i + <span class="number">1</span>], neuron_cnt[i]) * <span class="number">5</span>)</span><br><span class="line"><span class="keyword">elif</span> initialization == <span class="string">&#x27;he&#x27;</span>:</span><br><span class="line">    self.W.append(</span><br><span class="line">        np.random.randn(neuron_cnt[i + <span class="number">1</span>], neuron_cnt[i]) *</span><br><span class="line">        np.sqrt(<span class="number">2</span> / neuron_cnt[i]))</span><br><span class="line">self.b.append(np.zeros((neuron_cnt[i + <span class="number">1</span>], <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
<p>如果使用0初始化的话，就会出现之前学过的“参数对称性”问题。这个网络几乎学不到任何东西：</p>
<p><img src="/2022/06/11/DLS-note-5/12.jpg" alt></p>
<p>如果用比较大的值初始化的话，网络的梯度一直会很高，半天降不下来，学习速度极慢：</p>
<p><img src="/2022/06/11/DLS-note-5/13.jpg" alt></p>
<p>最后，我们使用比较高端的He Initialization.网络能够顺利学到东西了。</p>
<p><img src="/2022/06/11/DLS-note-5/14.jpg" alt></p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/Regularization">https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/Regularization</a></p>
<p>正则化要解决的是过拟合。为了“迫使”网络产生过拟合，我“精心”构造一个点集分类数据集：</p>
<p><img src="/2022/06/11/DLS-note-5/15.jpg" alt></p>
<p>在这个分类任务中，比较理想的分类结果是一条直线。但是，由于表示噪声的蓝点比较多，网络可能会过拟合训练数据。</p>
<p>在这项实验中，我们将分别测试在“不使用正则化”、“使用正则项”、“使用dropout”这三种配置下网络的表现情况。</p>
<p>如我们所预计地，不使用正则化策略的网络会过拟合训练数据：</p>
<p><img src="/2022/06/11/DLS-note-5/16.jpg" alt></p>
<p>之后，我们按照公式，尝试给网络添加正则化项：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span>(<span class="params">self, learning_rate</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">        <span class="keyword">if</span> self.weight_decay:</span><br><span class="line">            LAMBDA = <span class="number">4</span></span><br><span class="line">            self.W[i] = (<span class="number">1</span> - learning_rate * LAMBDA / self.m</span><br><span class="line">                          ) * self.W[i] - learning_rate * self.dW_cache[i]</span><br><span class="line">            self.b[i] -= learning_rate * self.db_cache[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.W[i] -= learning_rate * self.dW_cache[i]</span><br><span class="line">            self.b[i] -= learning_rate * self.db_cache[i]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">self, Y: np.ndarray, Y_hat: np.ndarray</span>) -&gt; np.ndarray:</span></span><br><span class="line">    <span class="keyword">if</span> self.weight_decay:</span><br><span class="line">        LAMBDA = <span class="number">4</span></span><br><span class="line">        tot = np.mean(-(Y * np.log(Y_hat) + (<span class="number">1</span> - Y) * np.log(<span class="number">1</span> - Y_hat)))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">            tot += np.<span class="built_in">sum</span>(self.W[i] * self.W[i]) * LAMBDA / <span class="number">2</span> / self.m</span><br><span class="line">        <span class="keyword">return</span> tot</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> np.mean(-(Y * np.log(Y_hat) + (<span class="number">1</span> - Y) * np.log(<span class="number">1</span> - Y_hat)))</span><br></pre></td></tr></table></figure>
<p>网络成功规避了过拟合。</p>
<p><img src="/2022/06/11/DLS-note-5/17.jpg" alt></p>
<p>接下来，我们来尝试使用dropout策略。在训练时，我们每层有50%的概率丢掉训练结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, train_mode=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> train_mode:</span><br><span class="line">        self.m = X.shape[<span class="number">1</span>]</span><br><span class="line">    A = X</span><br><span class="line">    self.A_cache[<span class="number">0</span>] = A</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">        Z = np.dot(self.W[i], A) + self.b[i]</span><br><span class="line">        <span class="keyword">if</span> i == self.num_layer - <span class="number">1</span>:</span><br><span class="line">            A = sigmoid(Z)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A = get_activation_func(self.activation_func[i])(Z)</span><br><span class="line">        <span class="keyword">if</span> train_mode <span class="keyword">and</span> self.dropout <span class="keyword">and</span> i &lt; self.num_layer - <span class="number">1</span>:</span><br><span class="line">            keep_prob = <span class="number">0.5</span></span><br><span class="line">            d = np.random.rand(*A.shape) &lt; keep_prob</span><br><span class="line">            A = A * d / keep_prob</span><br><span class="line">        <span class="keyword">if</span> train_mode:</span><br><span class="line">            self.Z_cache[i] = Z</span><br><span class="line">            self.A_cache[i + <span class="number">1</span>] = A</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<p>同样，使用dropout后，我们也得到了一个比较满意的分类结果：</p>
<p><img src="/2022/06/11/DLS-note-5/18.jpg" alt></p>
<p>欢迎大家自行调试这两个项目~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhou Yifan</p>
  <div class="site-description" itemprop="description">A foresighted strategist with big-picture thinking. 大局观选手。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Yifan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
