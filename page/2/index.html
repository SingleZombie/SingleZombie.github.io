<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhouyifan.net","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
<meta property="og:type" content="website">
<meta property="og:title" content="周弈帆的博客">
<meta property="og:url" content="https://zhouyifan.net/page/2/index.html">
<meta property="og:site_name" content="周弈帆的博客">
<meta property="og:description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zhou Yifan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zhouyifan.net/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>周弈帆的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">周弈帆的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/06/15/DLS-note-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/15/DLS-note-6/" class="post-title-link" itemprop="url">吴恩达《深度学习专项》笔记+代码实战（六）：改进梯度下降算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-15 17:31:30" itemprop="dateCreated datePublished" datetime="2022-06-15T17:31:30+08:00">2022-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="学习提示"><a href="#学习提示" class="headerlink" title="学习提示"></a>学习提示</h1><p>一直以来，我们都用梯度下降法作为神经网络的优化算法。但是，这个优化算法还有很多的改进空间。这周，我们将学习一些更高级的优化技术，希望能够从各个方面改进普通的梯度下降算法。</p>
<p>我们要学习的改进技术有三大项：分批梯度下降、高级更新方法、学习率衰减。这三项是平行的，可以同时使用。</p>
<p>分批梯度下降是从数据集的角度改进梯度下降。我们没必要等遍历完了整个数据集后再进行参数更新，而是可以遍历完一小批数据后就进行更新。</p>
<p>高级更新方法指不使用参数的梯度值，而是使用一些和梯度相关的中间结果来更新参数。通过使用这些更高级的优化算法，我们能够令参数的更新更加平滑，更加容易收敛到最优值。这些高级的算法包括gradient descent with momentum, RMSProp, Adam。其中Adam是前两种算法的结合版，这是目前最流行的优化器之一。</p>
<p>学习率衰减指的是随着训练的进行，我们可以想办法减小学习率的值，从而减少参数的震荡，令参数更快地靠近最优值。</p>
<p>在这周的课里，我们要更关注每种优化算法的单独、组合使用方法，以及应该在什么场合用什么算法，最后再去关注算法的实现原理。对于多数技术，“会用”一般要优先于“会写”。</p>
<h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="分批梯度下降"><a href="#分批梯度下降" class="headerlink" title="分批梯度下降"></a>分批梯度下降</h2><blockquote>
<p>这项技术的英文名称取得极其糟糕。之前我们使用的方法被称为”batch gradient descent”, 改进后的方法被称为”mini-batch gradient descent”。但是，这两种方法的本质区别是是否把整个数据集分成多个子集。因此，我们认为我的中文翻译“分批梯度下降”、“整批梯度下降”比原来的英文名词或者“小批量梯度下降”等中文翻译要更贴切名词本身的意思。</p>
</blockquote>
<h3 id="使用mini-batch"><a href="#使用mini-batch" class="headerlink" title="使用mini-batch"></a>使用mini-batch</h3><p>在之前的学习中，我们都是用整个训练集的平均梯度来更新模型参数的。而如果训练集特别大的话，遍历整个数据集要花很长时间，梯度下降的速度将十分缓慢。</p>
<p>其实，我们不一定要等遍历完了整个数据集再做梯度下降。相较于每次遍历完所有$m$个训练样本再更新，我们可以遍历完一小批次(mini-batch)的样本就更新。让我们来看课件里的一个例子：</p>
<p><img src="/2022/06/15/DLS-note-6/1.jpg" alt></p>
<p>假设整个数据集大小$m=5,000,000$。我们可以把数据集划分成5000个mini-batch，其中每一个batch包含1000个数据。做梯度下降时，我们每跑完一个batch里的1000个数据，就用它们的平均梯度去更新参数，再去跑下一个batch。</p>
<p>这里要介绍一个新的标记。设整个数据集$X$的形状是$(n_x, m)(m=5,000,000)$，则第<strong>$i$个数据集的标记</strong>为 $X^{\lbrace i \rbrace}$ ,形状为$(n_x, 1000)$。</p>
<p>再次总结一下标记：$x^{(i)[j]\lbrace k\rbrace}$中的上标分别表示和第i个样本相关、和第j层相关、和第k个批次的样本集相关。实际上这三个标记几乎不会同时出现。</p>
<p>使用了分批梯度下降后，算法的写法由</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    update parameters</span><br></pre></td></tr></table></figure>
<p>变成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m / batch_size)</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(batch_size):</span><br><span class="line">      update parameters</span><br></pre></td></tr></table></figure>
<p>。现在的梯度下降法每进行一次内层循环，就更新一次参数。我们还是把一次内层循环称为一个”step（步）”。此外，我们把一次外层循环称为一个”epoch(直译为’时代’，简称‘代’)”，因为每完成一次外层循环就意味着训练集被遍历了一次。</p>
<h3 id="mini-batch-的损失函数变化趋势"><a href="#mini-batch-的损失函数变化趋势" class="headerlink" title="mini-batch 的损失函数变化趋势"></a>mini-batch 的损失函数变化趋势</h3><p>使用分批梯度下降后，损失函数的变化趋势会有所不同:</p>
<p><img src="/2022/06/15/DLS-note-6/2.jpg" alt></p>
<p>如图所示，如果是使用整批梯度下降，则损失函数会一直下降。但是，使用分批梯度下降后，损失函数可能会时升时降，但总体趋势保持下降。</p>
<p>这种现象主要是因为之前我们计算的是整个训练集的损失函数，而现在计算的是每个mini-batch的损失函数。每个mini-batch的损失函数时高时低，可以理解为：某批数据比较简单，损失函数较低；另一批数据难度较大，损失函数较大。</p>
<h3 id="选择批次大小"><a href="#选择批次大小" class="headerlink" title="选择批次大小"></a>选择批次大小</h3><p>批次大小(batch size)对训练速度有很大的影响。</p>
<p>如果批次过大，甚至极端情况下<code>batch_size=m</code>，那么这等价于整批梯度下降。我们刚刚也学过了，如果数据集过大，整批梯度下降是很慢的。</p>
<p>如果批次过小，甚至小到<code>batch_size=1</code>（这种梯度下降法有一个特别的名字：随机梯度下降（Stochastic Gradient Descent）），那么这种计算方法又会失去向量化计算带来的加速效果。</p>
<blockquote>
<p>回想一下第二周的内容：向量化计算指的是一次对多个数据做加法、乘法等运算。这种计算方式比用循环对每个数据做计算要快。</p>
</blockquote>
<p>出于折中的考虑，我们一般会选用一个介于<code>1-m</code>之间的数作为批次大小。</p>
<p>如果数据集过小(<code>m&lt;2000</code>)，那就没必要使用分批梯度下降，直接拿整个数据集做整批梯度下降即可。</p>
<p>如果数据集再大一点，就可以考虑使用<strong>64, 128, 256, 512</strong>这些数作为<code>batch_size</code>。这几个数都是2的次幂。由于电脑的硬件容量经常和2的次幂相关，把<code>batch_size</code>恰好设成2的次幂往往能提速。</p>
<p>当然，刚刚也讲了，使用较大<code>batch_size</code>的一个目的是充分利用向量化计算。而向量化计算要求参与运算的数据全部在CPU/GPU内存上。如果设备的内存不够，则设过大的<code>batch_size</code>也没有意义。</p>
<h2 id="一段数据的平均值"><a href="#一段数据的平均值" class="headerlink" title="一段数据的平均值"></a>一段数据的平均值</h2><blockquote>
<p>在课堂上，这段内容是从数学的角度切入介绍的。我认为这种介绍方式比较突兀。我将从计算机科学的角度切入，用更好理解的方式介绍“指数加权移动平均”。</p>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>假设我们绘制了某年每日气温的散点图：</p>
<p><img src="/2022/06/15/DLS-note-6/3.jpg" alt></p>
<p>假如让你来描述全年气温的趋势，你会怎么描述呢？</p>
<p>作为人类，我们肯定会说：“这一年里，冬天的气温较低。随后气温逐渐升高，在夏天来到最高值。夏天过后，气温又逐渐下降，直至冬天的最低值。”</p>
<p>但是，要让计算机看懂天气的变化趋势，应该怎么办呢？直接拿相邻的天气的差作为趋势可不行。冬天也会出现第二天气温突然升高的情况，夏天也会出现第二天气温突然降低的情况。我们需要一个能够概括<strong>一段时间内</strong>气温情况的指标。</p>
<h3 id="移动平均数"><a href="#移动平均数" class="headerlink" title="移动平均数"></a>移动平均数</h3><p>一段时间里的值，其实就是几天内多个值的总体情况。多个值的总体情况，可以用平均数表示。严谨地来说，假如这一年有365天，我们用$t$表示这一年每天的天气，那么：</p>
<script type="math/tex; mode=display">
t_i=\left\{
\begin{aligned}
&第i天的天气 &(1 \leq i \leq 365) \\
&0 &(i取其他值)
\end{aligned}
\right.</script><p>我们可以定义一种叫做<strong>移动平均数(Moving Averages)</strong> 的指标，表示某天及其前几天温度的平均值。比如对于5天移动平均数$ma$，其定义如下：</p>
<script type="math/tex; mode=display">
ma_i=\frac{t_i+t_{i-1}+t_{i-2}+t_{i-3}+t_{i-4}}{5} (1 \leq i \leq 365)</script><p>假如要让计算机<strong>依次输出</strong>每天的移动平均数，该怎么编写算法呢？我们来看几个移动平均数的例子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
ma_5=(t_5+t_4+t_3+t_2+t_1)/5 \\
ma_6=(t_6+t_5+t_4+t_3+t_2)/5 \\
ma_7=(t_7+t_6+t_5+t_4+t_3)/5
\end{aligned}</script><p>通过观察，我们可以发现$ma_6=ma_5+(t_6-t_1)/5$，$ma_7=ma_6+(t_7-t_2)/5$。</p>
<p>也就是说，在算n天里的m天移动平均数（我们刚刚计算的是5天移动平均数）时，我们不用在n次的外层循环里再写一个m次的循环，只需要根据前一天的移动平均数，减一个值加一个值即可。这种依次输出移动平均数的算法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> temperature[<span class="number">0</span>:n]</span><br><span class="line"><span class="built_in">input</span> m</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_temperature</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">return</span> temperature[i] <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> i &lt; n <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">ma = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    ma += (get_temperature(i) - get_temperature(i - m)) / m</span><br><span class="line">    ma_i = ma</span><br><span class="line">    output ma_i</span><br></pre></td></tr></table></figure>
<p>这种求移动平均数的方法确实很高效。但是，我们上面这个算法是基于所有温度值<strong>一次性给出</strong>的情况。假如我们正在算今年每天温度的移动平均数，每天的温度是一天一天给出的，而不是一次性给出的，上面的算法应该怎么修改呢？让我们来看修改后的算法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> m</span><br><span class="line">temp_i_day_ago = zeros((m))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_temperature</span>(<span class="params">t</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>):</span><br><span class="line">        temp_i_day_ago[i+<span class="number">1</span>] = temp_i_day_ago[i]</span><br><span class="line">    temp_i_day_ago[<span class="number">0</span>] = t</span><br><span class="line"></span><br><span class="line">ma = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="built_in">input</span> t_i</span><br><span class="line">    update_temperature(t_i)</span><br><span class="line">    ma += (temp_i_day_ago[<span class="number">0</span>] - temp_i_day_ago[m]) / m</span><br><span class="line">    ma_i = ma</span><br><span class="line">    output ma_i</span><br></pre></td></tr></table></figure>
<p>由于我们不能提前知道每天的天气，我们需要一个大小为m的数组<code>temp_i_day_ago</code>记录前几天的天气，以计算m天移动平均数。</p>
<p>上述代码的时间复杂度还是有优化空间的。可以用更好的写法去掉<code>update_temperature</code>里的循环，把计算每天移动平均数的时间复杂度变为$O(1)$。但是，这份代码的空间复杂度是无法优化的。为了算m天移动平均数，我们必须要维护一个长度为m的数组，空间复杂度一定是$O(m)$。</p>
<p>对于一个变量的m移动平均数，$O(m)$的空间复杂度还算不大。但假如我们要同时维护l个变量的m移动平均数，整个算法的空间复杂度就是$O(ml)$。在l很大的情况下，m对空间的影响是很大的。哪怕m取5这种很小的数，也意味着要多花4倍的空间去存储额外的数据。空间复杂度里这多出来的这个$m$是不能接受的。</p>
<h3 id="指数加权移动平均"><a href="#指数加权移动平均" class="headerlink" title="指数加权移动平均"></a>指数加权移动平均</h3><p>作为移动平均数的替代，人们提出了<strong>指数加权移动平均数（Exponential Weighted Moving Average）</strong> 这种表示一段时期内数据平均值的指标。其计算公式为：</p>
<script type="math/tex; mode=display">
v_i=\beta v_{i-1} + (1 - \beta)t_i</script><p>这个公式直观上的意义为：一段时间内的平均温度，等于上一段时间的平均温度与当日温度的加权和。</p>
<p>相比普通的移动平均数，指数平均数最大的好处就是减小了空间复杂度。在迭代更新这个新的移动平均数时，我们只需要维护一个当前平均数$v_i$，一个当前的温度$t_i$即可，空间复杂度为$O(1)$。</p>
<p>让我们进一步理解公式中的参数$\beta$。把公式展开可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
v_i&=(1 - \beta)t_i + \beta v_{i-1} \\
v_i&=(1 - \beta)t_i + (1 - \beta)\beta t_{i-1} +\beta^2 v_{i-2} \\ 
v_i&=(1 - \beta)t_i + (1 - \beta)\beta t_{i-1} + (1 - \beta)\beta ^2t_{i-2}+ \beta^3 v_{i-2} \\
...
\end{aligned}</script><p>从这个式子可以看出，之前数据的权重都在以$\beta$的速度指数衰减。根据$(1-\epsilon)^{\frac{1}{\epsilon}} \approx \frac{1}{e}$，并且我们可以认为一个数到了$\frac{1}{e}$就小到可以忽视了，那么指数平均数表示的就是$\frac{1}{1-\beta}$天内数据的平均情况。比如$\beta=0.9$表示的是10天内的平均数据，$\beta=0.99$表示的是100天内的平均数据。</p>
<h3 id="偏差矫正"><a href="#偏差矫正" class="headerlink" title="偏差矫正"></a>偏差矫正</h3><p>指数平均数存在一个问题。在刚刚初始化时，指数平均数的值可能不太正确，请看：</p>
<script type="math/tex; mode=display">
\begin{aligned}
v_1 &=  (1 - \beta)t_1 \\
v_2 &=  (1 - \beta)\beta t_1 +(1 - \beta)t_2
\end{aligned}</script><p>让我们把每一项前面的权重加起来。对于$v_1$，前面的权重和是$(1-\beta)$；对于$v_2$，前面的权重和是$(1-\beta)(\beta+1)$。显然，这两个权重和都不为1。而计算平均数时，我们希望所有数据的权重和为1，这样才能反映出数据的真实大小情况。这里出现了权重上的“偏差”。</p>
<p>为了矫正这个偏差，我们应该想办法把权重和矫正为1。观察刚才的算式可以发现，第$i$项的权重和如下：</p>
<script type="math/tex; mode=display">
w_i = (1-\beta)(1+\beta+\beta^2+...\beta^i)</script><p>根据等比数列求和公式，上式化简为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
w_i &= (1-\beta)\frac{(1-\beta^i)}{(1-\beta)} \\
w_i &= 1-\beta^i
\end{aligned}</script><p>为了令权重和为1，我们可以令每一项指数平均数都除以这个和，即用下面的式子计算矫正后的指数平均数$v_i’$:</p>
<script type="math/tex; mode=display">
v_i'=\frac{v_i}{1-\beta^i}</script><p>但是，在实践中，由于这个和$1-\beta^i$收敛得很快，我们不会特地写代码做这个矫正。</p>
<h2 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h2><p>Gradient Descent with Momentum (使用动量的梯度下降) 是一种利用梯度的指数加权移动平均数更新参数的策略。在每次更新学习率时，我们不用本轮梯度的方向作为梯度下降的方向，而是用梯度的指数加权移动平均数作为梯度下降的方向。即对于每个参数，我们用下式做梯度下降：</p>
<script type="math/tex; mode=display">
\begin{aligned}
V_{dw}&=\beta V_{dw}+ (1-\beta)dw \\
V_{db}&=\beta V_{db}+ (1-\beta)db \\
w &:= w - \alpha V_{dw} \\
b &:= b - \alpha V_{db}
\end{aligned}</script><p>也就是说，对于每个参数$p$，我们用它的指数平均值$v_{dp}$代替$dp$进行参数的更新。</p>
<p>使用梯度的平均值来更新有什么好处呢？让我们来看一个可视化的例子：</p>
<p><img src="/2022/06/15/DLS-note-6/4.jpg" alt></p>
<p>不使用 Momentum 的话，每次参数更新的方向可能变化幅度较大，如上图中的蓝线所示。而使用 Momentum 后，每次参数的更新方向都会在之前的方向上稍作修改，每次的更新方向会更加平缓一点，如上图的红线所示。这样，梯度下降算法可以更快地找到最低点。</p>
<p>在实现时，我们不用去使用偏差矫正。$\beta$取0.9在大多数情况下都适用，有余力的话这个参数也可以调一下。</p>
<h2 id="RMSProp-和-Adam"><a href="#RMSProp-和-Adam" class="headerlink" title="RMSProp 和 Adam"></a>RMSProp 和 Adam</h2><blockquote>
<p>课堂上并没有对RMSProp的原理做过多的介绍，我们只需要记住它的公式就行。我会在其他文章中介绍这几项技术的原理。</p>
</blockquote>
<p>在一个神经网络中，不同的参数需要的更新幅度可能不一样。但是，在默认情况下，所有参数的更新幅度都是一样的（即学习率）。为了平衡各个参数的更新幅度，RMSProp(Root Mean Squared Propagation)  在参数更新公式中添加了一个和参数大小相关的权重$S$。与 Momentum 类似，RMSProp使用了某种移动平均值来平滑这个权重的更新。其梯度下降公式如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
S_{dw}&=\beta S_{dw}+ (1-\beta)dw^2 \\
S_{db}&=\beta S_{db}+ (1-\beta)db^2 \\
w &:= w - \alpha \frac{dw}{\sqrt{S_{dw}}} \\
b &:= b - \alpha \frac{db}{\sqrt{S_{db}}}
\end{aligned}</script><p>在编程实现时，我们应该给分母加一个极小值$\epsilon$，防止分母出现0。</p>
<p>Adam (Adaptive Moment Estimation) 是 Momentum 与 RMSProp 的结合版。为了使用Adam，我们要先计算 Momentum 和 RMSProp 的中间变量：</p>
<script type="math/tex; mode=display">
\begin{aligned}
V_{dw}&=\beta_1 V_{dw}+ (1-\beta_1)dw \\
V_{db}&=\beta_1 V_{db}+ (1-\beta_1)db \\
S_{dw}&=\beta_2 S_{dw}+ (1-\beta_2)dw^2 \\
S_{db}&=\beta_2 S_{db}+ (1-\beta_2)db^2 
\end{aligned}</script><p>之后，根据前面的偏差矫正，获得这几个变量的矫正值：</p>
<blockquote>
<p>如前文所述，在实现时添加偏差矫正意义不大。估计这里加上偏差矫正是因为原论文加了。</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{aligned}
V_{dw}'&=\frac{V_{dw}}{1-\beta_1^t} \\
V_{db}'&=\frac{V_{db}}{1-\beta_1^t} \\
S_{dw}'&=\frac{S_{dw}}{1-\beta_2^t} \\
S_{db}'&=\frac{S_{db}}{1-\beta_2^t} \\
\end{aligned}</script><p>最后，进行参数的更新：</p>
<script type="math/tex; mode=display">
\begin{aligned}
w &:= w - \alpha \frac{V_{dw}'}{\sqrt{S_{dw}'}+\epsilon} \\
b &:= b - \alpha \frac{V_{db}'}{\sqrt{S_{db}'}+\epsilon}
\end{aligned}</script><p>和之前一样，这里的$\epsilon$是一个极小值。在编程时添加$\epsilon$，一般都是为了防止分母中出现0。</p>
<p>Adam是目前非常流行的优化算法，它的表现通常都很优秀。为了用好这个优化算法，我们要知道它的超参数该怎么调。在原论文中，这个算法的超参数取值如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\beta_1 &= 0.9 \\
\beta_2 &= 0.999 \\
\epsilon &= 10^{-8}
\end{aligned}</script><p>绝大多数情况下，我们不用手动调这三个超参数。</p>
<h2 id="学习率衰减"><a href="#学习率衰减" class="headerlink" title="学习率衰减"></a>学习率衰减</h2><p>训练时的学习率不应该是一成不变的。在优化刚开始时，参数离最优值还差很远，选较大的学习率能加快学习速度。但是，经过了一段时间的学习后，参数离最优值已经比较近了。这时，较大的学习率可能会让参数错过最优值。因此，在训练一段时间后，减小学习率往往能够加快网络的收敛速度。这种训练一段时间后减小学习率的方法叫做<strong>学习率衰减</strong>。</p>
<p>其实学习率衰减只是一种比较宏观的训练策略，并没有绝对正确的学习率衰减方法。我们可以设置初始学习率$\alpha_0$，之后按下面的公式进行学习率衰减：</p>
<script type="math/tex; mode=display">
\alpha = \frac{1}{1 + DecayRate \ast EpochNum}\alpha_0</script><p>这个公式非常简单，初始学习率会随着一个衰减率(DecayRate)和训练次数(EpochNum)衰减。</p>
<p>同样，我们还可以使用指数衰减：</p>
<script type="math/tex; mode=display">
\alpha = 0.95^{EpochNum}\alpha_0</script><p>或者其他一些奇奇怪怪的衰减方法(k是超参数）：</p>
<script type="math/tex; mode=display">
\alpha = \frac{k}{\sqrt{EpochNum}}\alpha_0</script><p>甚至我们可以手动调学习率，每训练一段时间就把学习率调整成一个更小的常数。</p>
<p>总之，学习率衰减是一条启发性的规则。我们可以有意识地在训练中后期调小学习率。</p>
<h2 id="局部最优值"><a href="#局部最优值" class="headerlink" title="局部最优值"></a>局部最优值</h2><p>在执行梯度下降算法时，局部最优值可能会影响算法的表现：在局部最优值处，各个参数的导数都是0。梯度是0（所有导数为0），意味着梯度下降法将不再更新了。</p>
<p>在待优化参数较少时，陷入局部最优值是一种比较常见的情况。而对于参数量巨大的深度学习项目来说，整个模型陷入局部最优值是一个几乎不可能发生的事情。某参数在梯度为0时，既有可能是局部最优值，也可能是局部最差值。不妨设两种情况的概率都是0.5。如果整个模型都陷入了局部最优值，那么所有参数都得处于局部最优值上。假设我们的深度学习模型有10000个参数，则一个梯度为0的点是局部最优值的概率是$0.5^{10000}$，这是一个几乎不可能发生的事件。</p>
<p>所以，在深度学习中，更常见的梯度为0的点是鞍点（某处梯度为0，但不是局部最值）。在鞍点处，有很多参数都处于局部最差值上，只要稍微对这些参数做一些扰动，参数就会往更小的方向移动。因此，鞍点不会对学习算法产生影响。</p>
<p>在深度学习中，一种会影响学习速度的情况叫做“高原”（plateau）。在高原处，梯度的值一直都很小。只有跨过了这段区域，学习的速度才会快起来。这种情况的可视化结果如下：</p>
<p><img src="/2022/06/15/DLS-note-6/5.jpg" alt></p>
<p>总而言之，深度学习问题和简单的优化问题不太一样，不用过多担心局部最优值的问题。而高原现象确实会影响学习的速度。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这周，我们围绕深度学习的优化算法，学习了许多提升梯度下降法性能的技术。让我们来捋一捋。</p>
<p>首先，我们可以在处理完一小批数据后就执行梯度下降，而不必等处理完整个数据集后再执行。这种算法叫分批梯度下降（mini-batch gradient descent)。这是一种对梯度下降法的通用改进方法，即默认情况下，这种算法都可以和其他改进方法同时使用。</p>
<p>之后，我们学习了移动平均的概念，知道移动平均值可以更平滑地反映数据在一段时间内的趋势。基于移动平均值，有 gradient descent with momentum 和 RMSProp 这两种梯度下降的改进方法。而现在非常常用的 Adam 优化算法是Momentum 和 RMSProp 的结合版。</p>
<p>最后，我们学习了学习率衰减的一些常见方法。</p>
<p>学完本课的内容后，我认为我们应该对相关知识达到下面的掌握程度：</p>
<ul>
<li>分批梯度下降<ul>
<li>了解原理</li>
<li>掌握如何选取合适的 batch size</li>
</ul>
</li>
<li>高级优化算法<ul>
<li>了解移动平均数的思想</li>
<li>了解 Adam 的公式</li>
<li>记住 Adam 超参数的常见取值</li>
<li>未来学习了编程框架后，会调用 Momentum，Adam 优化器</li>
</ul>
</li>
<li>学习率衰减<ul>
<li>掌握“学习率衰减能加速收敛”这一概念</li>
<li>在训练自己的模型时，能够有意识地去调小学习率</li>
</ul>
</li>
<li>局部最优值<ul>
<li>不用管这个问题</li>
</ul>
</li>
</ul>
<h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><p>这周，官方的编程作业还是点集分类。我觉得这个任务太简单了，还是挑战小猫分类比较有意思。</p>
<p>在这周的代码实战项目中，让我们先回顾一下整个项目的框架，再实现这周学到的技术，包括分批梯度下降(Mini-batch Gradient Descent)、高级梯度下降算法(Mini-batch Gradient Descent)、学习率衰减。</p>
<p>项目链接：<br>​<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/AdvancedOptimizer">https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/AdvancedOptimizer</a></p>
<h2 id="小猫分类项目框架"><a href="#小猫分类项目框架" class="headerlink" title="小猫分类项目框架"></a>小猫分类项目框架</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>和之前一样，我们即将使用一个 kaggle 上的<a target="_blank" rel="noopener" href="https://www.kaggle.com/datasets/fusicfenta/cat-and-dog?resource=download">猫狗分类数据集</a>。我已经写好了读取数据的函数，该函数的定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cat_set</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    data_root: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    img_shape: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>] = (<span class="params"><span class="number">224</span>, <span class="number">224</span></span>),</span></span></span><br><span class="line"><span class="params"><span class="function">    train_size=<span class="number">1000</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    test_size=<span class="number">200</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) -&gt; <span class="type">Tuple</span>[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:</span></span><br></pre></td></tr></table></figure></p>
<p>填入数据集根目录、图像Reszie后的大小、一半训练集的大小、一半测试集的大小，我们就能得到预处理后的<code>train_X, train_Y, dev_X, dev_Y</code>。其中，X的形状是<code>(n_x, m)</code>, Y的形状是<code>(1, m)</code>。<code>n_x</code>是图像的特征数，对于一个大小为(224, 224)的图像，<code>n_x = 224*224*3</code>。m是样本数量，如果<code>train_size=1000</code>，则<code>m=2000</code>。</p>
<p>在之前的实战中，我的模型在训练集上的表现都十分糟糕，还没有用到“测试集”的机会。因此，我们之前那个“测试集”，既可以认为是开发集，也可以认为是测试集。从这周开始，出于严谨性的考虑，我准备把之前的“测试集”正式称作开发集（dev set）。</p>
<h3 id="模型类"><a href="#模型类" class="headerlink" title="模型类"></a>模型类</h3><p>和之前一样，我们用<code>BaseRegressionModel</code>来表示一个最后一层使用sigmoid，loss用交叉熵的二分类模型基类。这个基类的定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRegressionModel</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X: np.ndarray, train_mode=<span class="literal">True</span></span>) -&gt; np.ndarray:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">self, Y: np.ndarray</span>) -&gt; np.ndarray:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_grad_dict</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray]:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray]:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, state_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray]</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">self, Y: np.ndarray, Y_hat: np.ndarray</span>) -&gt; np.ndarray:</span></span><br><span class="line">        <span class="keyword">return</span> np.mean(-(Y * np.log(Y_hat) + (<span class="number">1</span> - Y) * np.log(<span class="number">1</span> - Y_hat)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span>(<span class="params">self, X: np.ndarray, Y: np.ndarray, return_loss=<span class="literal">False</span></span>):</span></span><br><span class="line">        Y_hat = self.forward(X, train_mode=<span class="literal">False</span>)</span><br><span class="line">        Y_hat_predict = np.where(Y_hat &gt; <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        accuracy = np.mean(np.where(Y_hat_predict == Y, <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">if</span> return_loss:</span><br><span class="line">            loss = self.loss(Y, Y_hat)</span><br><span class="line">            <span class="keyword">return</span> accuracy, loss</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> accuracy</span><br></pre></td></tr></table></figure>
<p>在模型类中，和训练有关的主要有<code>forward, backward, get_grad_dict</code>这三个方法，分别表示前向传播、反向传播、梯度获取。</p>
<p>这里要对<code>get_grad_dict</code>做一个说明。之前我们都是直接在模型类里实现梯度下降的，但在这周学了新的优化算法后，这种编程方式就不太方便拓展了。因此，从这周开始，我们应该用一个<code>BaseOptimizer</code>类来表示各种梯度下降算法。模型通过<code>get_grad_dict</code>把梯度传给优化器。</p>
<p>除了和训练相关的方法外，模型类通过<code>save, load</code>来把数据存入/取自一个词典，通过<code>loss, evaluate</code>来获取一些模型评测指标。</p>
<p><code>BaseRegressionModel</code>只是一个抽象基类。实际上，我在本项目使用的是第四周学习的深层神经网络（任意层数的全连接网络）<code>DeepNetwork</code>。只需要传入每一层神经元个数、每一层的激活函数，我们就能得到一个全连接分类网络：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepNetwork</span>(<span class="params">BaseRegressionModel</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, neuron_cnt: <span class="type">List</span>[<span class="built_in">int</span>], activation_func: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>在第四周代码的基础上，我修改了一下参数初始化的方法。由于隐藏层的激活函数都用的是ReLU，我打算默认使用 He Initialization:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">    self.W.append(</span><br><span class="line">        np.random.randn(neuron_cnt[i + <span class="number">1</span>], neuron_cnt[i]) *</span><br><span class="line">        np.sqrt(<span class="number">2</span> / neuron_cnt[i]))</span><br></pre></td></tr></table></figure></p>
<p>除此之外，我没有在这个模型上添加其他高级功能。我也没有添加正则化。现在网络还处于欠拟合状态，等我有资格解决过拟合问题时再去考虑正则化。</p>
<h3 id="优化器类"><a href="#优化器类" class="headerlink" title="优化器类"></a>优化器类</h3><p>看完了模型类，接下来，我们来看一看这周要实现的优化器类。所有的优化器类都继承自基类<code>BaseOptimizer</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseOptimizer</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            self,</span></span></span><br><span class="line"><span class="params"><span class="function">            param_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray],</span></span></span><br><span class="line"><span class="params"><span class="function">            learning_rate: <span class="built_in">float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            lr_scheduler: <span class="type">Callable</span>[[<span class="built_in">float</span>, <span class="built_in">int</span>], <span class="built_in">float</span>] = const_lr</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.param_dict = param_dict</span><br><span class="line">        self._epoch = <span class="number">0</span></span><br><span class="line">        self._num_step = <span class="number">0</span></span><br><span class="line">        self._learning_rate_zero = learning_rate</span><br><span class="line">        self._lr_scheduler = lr_scheduler</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">epoch</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._epoch</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learning_rate</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._lr_scheduler(self._learning_rate_zero, self.epoch)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_epoch</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._epoch += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;epoch&#x27;</span>: self._epoch, <span class="string">&#x27;num_step&#x27;</span>: self._num_step&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, state_dict: <span class="type">Dict</span></span>):</span></span><br><span class="line">        self._epoch = state_dict[<span class="string">&#x27;epoch&#x27;</span>]</span><br><span class="line">        self._num_step = state_dict[<span class="string">&#x27;num_step&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zero_grad</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.grad_dict:</span><br><span class="line">            self.grad_dict[k] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_grad</span>(<span class="params">self, grad_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray]</span>):</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.grad_dict:</span><br><span class="line">            self.grad_dict[k] += grad_dict[k]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这个优化器基类实现了以下功能：</p>
<ul>
<li>维护当前的<code>epoch</code>和<code>step</code>，以辅助其他参数的计算。</li>
<li>维护当前的学习率，并通过使用<code>_lr_scheduler</code>的方式支持学习率衰减。</li>
<li>定义了从词典中保存/读取优化器的方法<code>save, load</code>。</li>
<li>定义了维护的梯度的清空梯度方法<code>zero_grad</code>和新增梯度方法<code>add_grad</code>。</li>
<li>允许子类实现<code>step</code>方法，以使用不同策略更新参数。</li>
</ul>
<p>在后续章节中，我会介绍该如何使用这个基类实现这周学过的优化算法。</p>
<h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>基于上述的<code>BaseRegressionModel</code>和<code>BaseOptimizer</code>，我们可以写出下面的模型训练函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">model: BaseRegressionModel,</span></span></span><br><span class="line"><span class="params"><span class="function">          optimizer: BaseOptimizer,</span></span></span><br><span class="line"><span class="params"><span class="function">          X,</span></span></span><br><span class="line"><span class="params"><span class="function">          Y,</span></span></span><br><span class="line"><span class="params"><span class="function">          total_epoch,</span></span></span><br><span class="line"><span class="params"><span class="function">          batch_size,</span></span></span><br><span class="line"><span class="params"><span class="function">          model_name: <span class="built_in">str</span> = <span class="string">&#x27;model&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          save_dir: <span class="built_in">str</span> = <span class="string">&#x27;work_dirs&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          recover_from: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          print_interval: <span class="built_in">int</span> = <span class="number">100</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          dev_X=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          dev_Y=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> recover_from:</span><br><span class="line">        load_state_dict(model, optimizer, recover_from)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Prepare mini_batch</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(total_epoch):</span><br><span class="line">        <span class="keyword">for</span> mini_batch_X, mini_batch_Y <span class="keyword">in</span> mini_batch_XYs:</span><br><span class="line">            mini_batch_Y_hat = model.forward(mini_batch_X)</span><br><span class="line">            model.backward(mini_batch_Y)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            optimizer.add_grad(model.get_grad_dict())</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">        currrent_epoch = optimizer.epoch</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> currrent_epoch % print_interval == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># print loss</span></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        optimizer.increase_epoch()</span><br><span class="line"></span><br><span class="line">    save_state_dict(model, optimizer,</span><br><span class="line">                    os.path.join(save_dir, <span class="string">f&#x27;<span class="subst">&#123;model_name&#125;</span>_latest.npz&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>训练之前，我们可以从模型文件<code>recover_from</code>里读取模型状态和优化器状态。读取数据是通过<code>load_state_dict</code>实现的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_state_dict</span>(<span class="params">model: BaseRegressionModel, optimizer: BaseOptimizer,</span></span></span><br><span class="line"><span class="params"><span class="function">                    filename: <span class="built_in">str</span></span>):</span></span><br><span class="line">    state_dict = np.load(filename)</span><br><span class="line">    model.load(state_dict[<span class="string">&#x27;model&#x27;</span>])</span><br><span class="line">    optimizer.load(state_dict[<span class="string">&#x27;optimizer&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>在得到某一批训练数据<code>X, Y</code>后，我们可以用下面的代码执行一步梯度下降：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Y_hat = model.forward(X)</span><br><span class="line">model.backward(Y)</span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">optimizer.add_grad(model.get_grad_dict())</span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure>
<p>我们会先调用模型的前向传播<code>forward</code>和反向传播<code>backward</code>，令模型存下本轮的梯度。之后，我们重置优化器，把梯度从模型传到优化器，再调用优化器进行更新。</p>
<p>训练代码中，默认使用了mini-batch。我会在后续章节介绍mini-batch的具体实现方法。</p>
<p>完成了梯度的更新后，我们要维护当前的训练代数<code>epoch</code>。训练了几代后，我们可以评测模型在整个训练集和开发集上的性能指标。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">currrent_epoch = optimizer.epoch</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> currrent_epoch % print_interval == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># print loss</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">optimizer.increase_epoch()</span><br></pre></td></tr></table></figure>
<p>最后，模型训练结束后，我们要保存模型。保存模型是通过<code>save_state_dict</code>实现的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_state_dict</span>(<span class="params">model: BaseRegressionModel, optimizer: BaseOptimizer,</span></span></span><br><span class="line"><span class="params"><span class="function">                    filename: <span class="built_in">str</span></span>):</span></span><br><span class="line">    state_dict = &#123;<span class="string">&#x27;model&#x27;</span>: model.save(), <span class="string">&#x27;optimizer&#x27;</span>: optimizer.save()&#125;</span><br><span class="line">    np.savez(filename, **state_dict)</span><br></pre></td></tr></table></figure>
<p>如果你对<code>np.savez</code>函数不熟，欢迎回顾我在第四周代码实战中对其的介绍。</p>
<p>总之，基于我们定义的<code>BaseRegressionModel</code>和<code>BaseOptimizer</code>，我们可以在初始化完这个两个类的对象后，调用<code>train</code>来完成模型的训练。</p>
<h2 id="使用-Mini-batch"><a href="#使用-Mini-batch" class="headerlink" title="使用 Mini-batch"></a>使用 Mini-batch</h2><h3 id="注意-I-O-开销！"><a href="#注意-I-O-开销！" class="headerlink" title="注意 I/O 开销！"></a>注意 I/O 开销！</h3><p>重申一下，Mini-batch gradient descent 的本意是加快训练速度。如果实现了 Mini-batch 后，程序在其他地方跑得更慢了，那么使用这个算法就毫无意义了。</p>
<p>在我们这个小型的深度学习项目中，从硬盘上读取数据的开销是极大的。下图是执行包含前后处理在内的一轮训练的时间开销分布：</p>
<p><img src="/2022/06/15/DLS-note-6/6.jpg" alt></p>
<p>从图中可以看出，相对于一轮训练，读取数据的开销是极大的。读取数据的时间甚至约等于两轮训练的时间。</p>
<p>在之前的项目中，我一直默认是把训练数据全部读取到内存中，然后再进行训练。这样的好处是网络的训练速度不受硬盘读写速度限制，会加快不少，坏处是训练数据的总量受到电脑内存的限制。</p>
<p>在使用分批梯度下降算法时，为了比较算法在性能上的提升，我们应该继续使用相同的数据管理策略，即把数据放到内存中处理。如果换了算法，还换了数据管理策略，把一次性读取数据改成每次需要数据的时候再去读取，那么我们就无法观察到算法对于性能的提升。</p>
<p>事实上，在大型深度学习项目中，模型执行一轮训练的速度很慢，I/O的开销相对来说会小很多。在这种时候，我们可以仅在需要时再读取数据。不过，在这种情况下，我们依然要保证内存/显存足够支持一轮mini-batch的前向/反向传播。这里要注意一下我们这个小demo和实际深度学习项目的区别。</p>
<h3 id="mini-batch-预处理"><a href="#mini-batch-预处理" class="headerlink" title="mini-batch 预处理"></a>mini-batch 预处理</h3><p>在执行一个epoch(代)的训练时，我们应该保证训练数据是打乱的，以避免极端数据分布给训练带来的副作用。</p>
<p>epoch 与 epoch 之间 mini-batch 的划分是否相同到不是那么重要。理论上来说，数据越平均越好，最好能每个 epoch 都重新划分 mini-batch。但是，为了加速训练，同时让使用 mini-batch 的逻辑更加易懂，我打算先预处理出 mini-batch，之后每个 epoch 都使用相同的划分。</p>
<p>为了方便之后的处理，我们把每个mini-batch的X和Y都单独存入数组<code>mini_batch_XYs</code>。这样，在之后的训练循环里，每个mini-batch的数据就可以直接拿来用了。以下是预处理mini-batch的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m = X.shape[<span class="number">1</span>]</span><br><span class="line">indices = np.random.permutation(m)</span><br><span class="line">shuffle_X = X[:, indices]</span><br><span class="line">shuffle_Y = Y[:, indices]</span><br><span class="line">num_mini_batch = math.ceil(m / batch_size)</span><br><span class="line">mini_batch_XYs = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_mini_batch):</span><br><span class="line">    <span class="keyword">if</span> i == num_mini_batch - <span class="number">1</span>:</span><br><span class="line">        mini_batch_X = shuffle_X[:, i * batch_size:]</span><br><span class="line">        mini_batch_Y = shuffle_Y[:, i * batch_size:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mini_batch_X = shuffle_X[:, i * batch_size:(i + <span class="number">1</span>) * batch_size]</span><br><span class="line">        mini_batch_Y = shuffle_Y[:, i * batch_size:(i + <span class="number">1</span>) * batch_size]</span><br><span class="line">    mini_batch_XYs.append((mini_batch_X, mini_batch_Y))</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们首先用第二周编程练习中学过的<code>permutation</code>生成一个随机排列，并根据这个随机排列打乱数据。</p>
<p>之后的代码就是一段常见的数据除法分块逻辑。对于除得尽和除不尽的mini-batch，我们分开处理，提取出每个mini_batch的X和Y。</p>
<h3 id="mini-batch-训练"><a href="#mini-batch-训练" class="headerlink" title="mini-batch 训练"></a>mini-batch 训练</h3><p>预处理得当的话，用mini-batch进行训练的代码非常简洁。我们只需要在原来的训练循环里加一个对mini-batch的遍历即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(num_epoch):</span><br><span class="line">    <span class="keyword">for</span> mini_batch_X, mini_batch_Y <span class="keyword">in</span> mini_batch_XYs:</span><br><span class="line">        mini_batch_Y_hat = model.forward(mini_batch_X)</span><br><span class="line">        model.backward(mini_batch_Y)</span><br><span class="line">        model.gradient_descent(learning_rate)</span><br></pre></td></tr></table></figure>
<h3 id="mini-batch-的损失函数曲线"><a href="#mini-batch-的损失函数曲线" class="headerlink" title="mini-batch 的损失函数曲线"></a>mini-batch 的损失函数曲线</h3><p>和我们在课堂里学的一样，使用mini-batch后，损失函数的曲线可能不像之前那么平滑。这是因为我们画损失函数曲线时用的是每个mini-batch上的损失函数，而不是整个训练集的损失函数。我得到的一个mini-batch损失函数曲线如下：</p>
<p><img src="/2022/06/15/DLS-note-6/7.jpg" alt></p>
<p>在训练时，我顺手存了一下每个mini-batch的梯度，并在训练结束后对它们进行可视化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mini_batch_loss_list = []</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(num_epoch):</span><br><span class="line">    <span class="keyword">for</span> mini_batch_X, mini_batch_Y <span class="keyword">in</span> mini_batch_XYs:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> plot_mini_batch:</span><br><span class="line">            loss = model.loss(mini_batch_Y, mini_batch_Y_hat)</span><br><span class="line">            mini_batch_loss_list.append(loss)</span><br><span class="line"><span class="keyword">if</span> plot_mini_batch:</span><br><span class="line">    plot_length = <span class="built_in">len</span>(mini_batch_loss_list)</span><br><span class="line">    plot_x = np.linspace(<span class="number">0</span>, plot_length, plot_length)</span><br><span class="line">    plot_y = np.array(mini_batch_loss_list)</span><br><span class="line">    plt.plot(plot_x, plot_y)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="实现高级优化算法"><a href="#实现高级优化算法" class="headerlink" title="实现高级优化算法"></a>实现高级优化算法</h2><p>有了基类<code>BaseOptimizer</code>后，我们只需要实现子类的构造函数和更新函数，就可以实现各种各样的改进梯度下降算法了。让我们看一下这周学习的Momentum, RMSProp, Adam该如何实现。</p>
<h3 id="Momentum-1"><a href="#Momentum-1" class="headerlink" title="Momentum"></a>Momentum</h3><p>Momentum的主要实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Momentum</span>(<span class="params">BaseOptimizer</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="params"><span class="function">                 param_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray],</span></span></span><br><span class="line"><span class="params"><span class="function">                 learning_rate: <span class="built_in">float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 beta: <span class="built_in">float</span> = <span class="number">0.9</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 from_scratch=<span class="literal">False</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(param_dict, learning_rate)</span><br><span class="line">        self.beta = beta</span><br><span class="line">        self.grad_dict = deepcopy(self.param_dict)</span><br><span class="line">        <span class="keyword">if</span> from_scratch:</span><br><span class="line">            self.velocity_dict = deepcopy(self.param_dict)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> self.velocity_dict:</span><br><span class="line">                self.velocity_dict[k] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._num_step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.param_dict:</span><br><span class="line">            self.velocity_dict[k] = self.beta * self.velocity_dict[k] + \</span><br><span class="line">                (<span class="number">1</span> - self.beta) * self.grad_dict[k]</span><br><span class="line">            self.param_dict[k] -= self.learning_rate * self.velocity_dict[k]</span><br></pre></td></tr></table></figure>
<p>在Momentum中，我们主要是维护<code>velocity_dict</code>这个变量。根据课堂里学过的知识，这个变量的值等于梯度的指数移动平均值。因此，我们只需要在<code>step</code>里维护一个指数平均数即可。</p>
<p>为了保存优化器的状态，我们应该在<code>save, load</code>里保存<code>velocity_dict</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>:</span></span><br><span class="line">    state_dict = <span class="built_in">super</span>().save()</span><br><span class="line">    state_dict[<span class="string">&#x27;velocity_dict&#x27;</span>] = self.velocity_dict</span><br><span class="line">    <span class="keyword">return</span> state_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, state_dict: <span class="type">Dict</span></span>):</span></span><br><span class="line">    self.velocity_dict = state_dict.get(<span class="string">&#x27;velocity_dict&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> self.velocity_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.velocity_dict = deepcopy(self.param_dict)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.velocity_dict:</span><br><span class="line">            self.velocity_dict[k] = <span class="number">0</span></span><br><span class="line">    <span class="built_in">super</span>().load(state_dict)</span><br></pre></td></tr></table></figure>
<h3 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h3><p>RMSProp的主要实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMSProp</span>(<span class="params">BaseOptimizer</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="params"><span class="function">                 param_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray],</span></span></span><br><span class="line"><span class="params"><span class="function">                 learning_rate: <span class="built_in">float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 beta: <span class="built_in">float</span> = <span class="number">0.9</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 eps: <span class="built_in">float</span> = <span class="number">1e-6</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 from_scratch=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 correct_param=<span class="literal">True</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(param_dict, learning_rate)</span><br><span class="line">        self.beta = beta</span><br><span class="line">        self.eps = eps</span><br><span class="line">        self.grad_dict = deepcopy(self.param_dict)</span><br><span class="line">        self.correct_param = correct_param</span><br><span class="line">        <span class="keyword">if</span> from_scratch:</span><br><span class="line">            self.s_dict = deepcopy(self.param_dict)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> self.s_dict:</span><br><span class="line">                self.s_dict[k] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._num_step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.param_dict:</span><br><span class="line">            self.s_dict[k] = self.beta * self.s_dict[k] + \</span><br><span class="line">                (<span class="number">1</span> - self.beta) * np.square(self.grad_dict[k])</span><br><span class="line">            <span class="keyword">if</span> self.correct_param:</span><br><span class="line">                s = self.s_dict[k] / (<span class="number">1</span> - self.beta**self._num_step)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s = self.s_dict[k]</span><br><span class="line">            self.param_dict[k] -= self.learning_rate * self.grad_dict[k] / (</span><br><span class="line">                np.sqrt(s + self.eps))</span><br></pre></td></tr></table></figure>
<p>和Momentum类似，我们要维护一个指数平均数权重<code>s_dict</code>，并在更新参数时算上这个权重。由于RMSProp是除法运算，为了防止偶尔出现的除以0现象，我们要在分母里加一个极小值<code>eps</code>。</p>
<p>我在这个优化器中加入了偏差校准功能。如果开启了校准，指数平均数会除以一个<code>(1 - self.beta**self._num_step)</code>。</p>
<p>类似地，RMSProp中也用<code>save, load</code>来保存状态<code>s_dict</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>:</span></span><br><span class="line">    state_dict = <span class="built_in">super</span>().save()</span><br><span class="line">    state_dict[<span class="string">&#x27;s_dict&#x27;</span>] = self.s_dict</span><br><span class="line">    <span class="keyword">return</span> state_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, state_dict: <span class="type">Dict</span></span>):</span></span><br><span class="line">    self.s_dict = state_dict.get(<span class="string">&#x27;s_dict&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> self.s_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.s_dict = deepcopy(self.param_dict)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.s_dict:</span><br><span class="line">            self.s_dict[k] = <span class="number">0</span></span><br><span class="line">    <span class="built_in">super</span>().load(state_dict)</span><br></pre></td></tr></table></figure>
<p>注意，RMSProp实际上是对学习率进行了一个放缩。在把模型的优化算法从Momentum改成RMSProp后，学习率要从头调整。一般来说，RMSProp里的权重<code>s_dict</code>是一个小于1的数。这个数做了分母，等价于放大了学习率。因此，使用RMSProp后，可以先尝试把学习率调小100倍左右，再做进一步的调整。</p>
<h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><p>Adam 的主要实现代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adam</span>(<span class="params">BaseOptimizer</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="params"><span class="function">                 param_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray],</span></span></span><br><span class="line"><span class="params"><span class="function">                 learning_rate: <span class="built_in">float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 beta1: <span class="built_in">float</span> = <span class="number">0.9</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 beta2: <span class="built_in">float</span> = <span class="number">0.999</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 eps: <span class="built_in">float</span> = <span class="number">1e-8</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 from_scratch=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 correct_param=<span class="literal">True</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(param_dict, learning_rate)</span><br><span class="line">        self.beta1 = beta1</span><br><span class="line">        self.beta2 = beta2</span><br><span class="line">        self.eps = eps</span><br><span class="line">        self.grad_dict = deepcopy(self.param_dict)</span><br><span class="line">        self.correct_param = correct_param</span><br><span class="line">        <span class="keyword">if</span> from_scratch:</span><br><span class="line">            self.v_dict = deepcopy(self.param_dict)</span><br><span class="line">            self.s_dict = deepcopy(self.param_dict)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> self.v_dict:</span><br><span class="line">                self.v_dict[k] = <span class="number">0</span></span><br><span class="line">                self.s_dict[k] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._num_step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.param_dict:</span><br><span class="line">            self.v_dict[k] = self.beta1 * self.v_dict[k] + \</span><br><span class="line">                (<span class="number">1</span> - self.beta1) * self.grad_dict[k]</span><br><span class="line">            self.s_dict[k] = self.beta2 * self.s_dict[k] + \</span><br><span class="line">                (<span class="number">1</span> - self.beta2) * (self.grad_dict[k] ** <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> self.correct_param:</span><br><span class="line">                v = self.v_dict[k] / (<span class="number">1</span> - self.beta1**self._num_step)</span><br><span class="line">                s = self.s_dict[k] / (<span class="number">1</span> - self.beta2**self._num_step)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v = self.v_dict[k]</span><br><span class="line">                s = self.s_dict[k]</span><br><span class="line">            self.param_dict[k] -= self.learning_rate * v / (np.sqrt(s) +</span><br><span class="line">                                                            self.eps)</span><br></pre></td></tr></table></figure></p>
<p>Adam 就是把 Momentum 和 RMSProp 结合一下。在Adam中，我们维护<code>v_dict</code>和<code>s_dict</code>两个变量，并根据公式利用这两个变量更新参数。</p>
<blockquote>
<p>这里有一个小细节：在Adam中，<code>eps</code>是写在根号外的，而RMSProp中<code>eps</code>是在根号里面的。这是为了与原论文统一。其实<code>eps</code>写哪都差不多，只要不让分母为0即可。</p>
</blockquote>
<p>类似地，Adam要在状态词典里保存两个变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>:</span></span><br><span class="line">    state_dict = <span class="built_in">super</span>().save()</span><br><span class="line">    state_dict[<span class="string">&#x27;v_dict&#x27;</span>] = self.v_dict</span><br><span class="line">    state_dict[<span class="string">&#x27;s_dict&#x27;</span>] = self.s_dict</span><br><span class="line">    <span class="keyword">return</span> state_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, state_dict: <span class="type">Dict</span></span>):</span></span><br><span class="line">    self.v_dict = state_dict.get(<span class="string">&#x27;v_dict&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    self.s_dict = state_dict.get(<span class="string">&#x27;s_dict&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> self.v_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.v_dict = deepcopy(self.param_dict)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.v_dict:</span><br><span class="line">            self.v_dict[k] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> self.s_dict <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.s_dict = deepcopy(self.param_dict)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.s_dict:</span><br><span class="line">            self.s_dict[k] = <span class="number">0</span></span><br><span class="line">    <span class="built_in">super</span>().load(state_dict)</span><br></pre></td></tr></table></figure>
<p>Adam使用的学习率和RMSProp差不多。如果有一个在RMSProp上调好的学习率，可以直接从那个学习率开始调。</p>
<h2 id="学习率衰减-1"><a href="#学习率衰减-1" class="headerlink" title="学习率衰减"></a>学习率衰减</h2><p>要实现学习率衰减非常容易，我们只需要用一个实时计算学习率的学习率<code>getter</code>来代替静态的学习率即可。在<code>BaseOptimizer</code>中，我们可以这样实现学习率衰减：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseOptimizer</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            self,</span></span></span><br><span class="line"><span class="params"><span class="function">            param_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, np.ndarray],</span></span></span><br><span class="line"><span class="params"><span class="function">            learning_rate: <span class="built_in">float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            lr_scheduler: <span class="type">Callable</span>[[<span class="built_in">float</span>, <span class="built_in">int</span>], <span class="built_in">float</span>] = const_lr</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.param_dict = param_dict</span><br><span class="line">        self._epoch = <span class="number">0</span></span><br><span class="line">        self._num_step = <span class="number">0</span></span><br><span class="line">        self._learning_rate_zero = learning_rate</span><br><span class="line">        self._lr_scheduler = lr_scheduler</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learning_rate</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._lr_scheduler(self._learning_rate_zero, self.epoch)</span><br></pre></td></tr></table></figure>
<p>在<code>BaseOptimizer</code>类中，我们用<code>@property</code>装饰器装饰一个<code>learning_rate</code>方法，以实现一个<code>getter</code>函数。这样，我们在获取<code>optimizer.learning_rate</code>这个属性时，实际上是在调用<code>learning_rate</code>这个函数。</p>
<p>在<code>getter</code>中，我们用<code>_lr_scheduler</code>来实时计算一个学习率。<code>_lr_scheduler</code>是一个函数，该函数应该接受初始学习率、当前的epoch这两个变量，返回一个当前学习率。通过修改这个<code>_lr_scheduler</code>，我们就能使用不同的学习率衰减算法。</p>
<p>在代码中，我只实现了两个简单的学习率衰减函数。首先是常数学习率：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">const_lr</span>(<span class="params">learning_rate_zero: <span class="built_in">float</span>, epoch: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">    <span class="keyword">return</span> learning_rate_zero</span><br></pre></td></tr></table></figure>
<p>之后是课堂上学过的双曲线衰减函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hyperbola_func</span>(<span class="params">decay_rate: <span class="built_in">float</span></span>) -&gt; <span class="type">Callable</span>[[<span class="built_in">float</span>, <span class="built_in">int</span>], <span class="built_in">float</span>]:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scheduler</span>(<span class="params">learning_rate_zero: <span class="built_in">float</span>, epoch: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> learning_rate_zero / (<span class="number">1</span> + epoch * decay_rate)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scheduler</span><br></pre></td></tr></table></figure>
<p><code>get_hyperbola_func</code>是一个返回函数的函数。我们可以用<code>get_hyperbola_func(decay_rate)</code>生成一个某衰减率的学习率衰减函数。</p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>经实验，高级优化技术确实令训练速度有显著的提升。为了比较不同优化技术的性能，我使用2000个小猫分类样本作为训练集，使用了下图所示的全连接网络，比较了<strong>不同batch size</strong>、<strong>不同优化算法</strong>、<strong>不同学习率衰减方法</strong>下整个数据集的损失函数变化趋势。</p>
<p><img src="/2022/06/15/DLS-note-6/8.jpg" alt></p>
<p>以下是实验的结果：</p>
<p>首先，我比较了不同batch size下的mini-batch梯度下降。</p>
<p><img src="/2022/06/15/DLS-note-6/9.jpg" alt></p>
<p>从理论上来看，对于同一个数据集，执行相同的epoch，batch size越小，执行优化的次数越多，优化的效果越好。但是，batch size越小，执行一个epoch花的时间就越多。batch size过小的话，计算单元的向量化计算无法得到充分利用，算法的优化效率（单位时间内的优化量）反而下降了。</p>
<p>上面的实验结果和理论一致。执行相同的epoch，batch size越小，优化的效果越好。同时，batch size越小，误差也更容易出现震荡。虽然看上去batch size越小效果就越好，但由于向量化计算的原因，batch size为64,128,2000时跑一个epoch都差不多快，batch size为8时跑一个epoch就很慢了。我还尝试了batch size为1的随机梯度下降，算法跑一个epoch的速度奇慢无比，程序运行效率极低。最终，我把64作为所有优化算法的batch size。</p>
<p>之后，我比较了普通梯度下降、Momentum、RMSProp、Adam的优化结果。在普通梯度下降和Momentum中，我的学习率为1e-3；在RMSProp和Adam中，我的学习率为1e-5。</p>
<p><img src="/2022/06/15/DLS-note-6/10.jpg" alt></p>
<p>由于不同算法的学习率“尺度”不一样，因此，应该去比较普通梯度下降和Momentum，RMSProp和Adam这两组学习率尺度一样的实验。</p>
<p>对比普通梯度下降和Momentum，可以看出Momentum能够显著地提升梯度下降的性能，并且让误差的变化更加平滑。</p>
<p>对比RMSProp和Adam，可以看出学习率相同且偏小的情况下，Adam优于RMSProp。</p>
<p>感觉Adam的性能还是最优秀的。如果把Adam的学习率再调一调，优化效果应该能够超过其他算法。</p>
<p>最后，我还尝试了三个学习率衰减策略实验。每次实验都使用Adam优化器，初始学习率都是1e-5。第一次实验固定学习率，之后的两次实验分别使用衰减系数0.2，0.005的双曲线衰减公式。以下是实验结果：</p>
<p><img src="/2022/06/15/DLS-note-6/11.jpg" alt></p>
<p>从图中可以看出，由于初始学习率较低，在使用了比较大的衰减系数（=0.2）时，虽然学习的过程很平滑，但是学习速度较慢。而如果使用了恰当的衰减系数，虽然学习率在缓缓降低，但学习的步伐可能更加恰当，学习的速度反而变快了。</p>
<p>不过，RMSProp本身就自带调度学习率的效果。主动使用学习率衰减的效果可能没有那么明显。相比mini-batch和高级优化算法，学习率衰减确实只能算是一种可选的策略。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>我的实验还做得不是很充分。理论上可以再调一调学习率，更加公平地比较不同的学习算法。但是，我已经没有动力去进一步优化超参数了——由于目前学习算法的性能过于优秀，模型已经在训练集上过拟合了，训练准确率达到了80%多，远大于58%的开发准确率。因此，根据上一周学的知识，我的下一步任务不是继续降低训练误差，而是应该使用正则化方法或者其他手段，提高模型的泛化能力。在后续的课程中，我们还会接着学习改进深度学习项目的方法，届时我将继续改进这个小猫分类模型。</p>
<p>其实，过拟合对我来说是一件可喜可贺的事情。前两周，仅使用普通梯度下降时，模型的训练准确率和测试准确率都很低，我还在怀疑是不是我的代码写错了。现在看来，这完全是梯度下降算法的锅。朴素的梯度下降算法的性能实在是太差了。稍微使用了mini-batch、高级优化算法等技术后，模型的训练速度就能有一个质的飞跃。在深度学习项目中，mini-batch, Adam优化器应该成为优化算法的默认配置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/06/11/DLS-note-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/11/DLS-note-5/" class="post-title-link" itemprop="url">吴恩达《深度学习专项》笔记+代码实战（五）：深度学习的实践层面</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-11 15:56:46" itemprop="dateCreated datePublished" datetime="2022-06-11T15:56:46+08:00">2022-06-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="学习提示"><a href="#学习提示" class="headerlink" title="学习提示"></a>学习提示</h1><p>第二门课的知识点比较分散，开始展示每周的笔记之前，我会先梳理一下每周涉及的知识。</p>
<p>这一周会先介绍改进机器学习模型的基本方法。为了介绍这项知识，我们会学习两个新的概念：数据集的划分、偏差与方差问题。知道这两个概念后，我们就能够诊断当前机器学习模型存在的问题，进而找出改进的方法。</p>
<p>之后，我们会针对“高方差问题”，学习一系列解决此问题的方法。这些方法成为“正则化方法”。这周介绍的正则化方法有：添加正则化项、dropout、数据增强、提前停止。</p>
<p>最后，我们会学习几项和神经网络相关的技术。我们会学习用于加速训练的输入归一化，用于防止梯度计算出现问题的参数带权初始化，以及用于程序调试的梯度检查。</p>
<h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="数据集的划分：训练集-开发集-测试集"><a href="#数据集的划分：训练集-开发集-测试集" class="headerlink" title="数据集的划分：训练集/开发集/测试集"></a>数据集的划分：训练集/开发集/测试集</h2><p>在使用机器学习的数据集时，我们一般把数据集分成三份：训练集、开发集、测试集。</p>
<blockquote>
<p>机器学习是比深度学习的父集，表示一个更大的人工智能算法的集合。</p>
<p>开发集（Development Set）另一种常见的称呼是验证集(Validation Set)，即保留交叉验证（Hold-out Cross Validation)。</p>
</blockquote>
<h3 id="三种数据集的定义"><a href="#三种数据集的定义" class="headerlink" title="三种数据集的定义"></a>三种数据集的定义</h3><p>它们三者的区别如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>训练集</th>
<th>开发集</th>
<th>测试集</th>
</tr>
</thead>
<tbody>
<tr>
<td>用于优化参数</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>训练时可见？</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>最终测试时可见？</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
</div>
<p>训练集就是令模型去拟合的数据。对于神经网络来说，我们把某类数据集输入进网络，之后用反向传播来优化网络的参数。这个过程中用的数据集就是训练集。</p>
<p>开发集是我们在训练时调整超参数时用到的数据集。我们会测试不同的超参数，看看模型在开发集上的性能，并选择令模型在开发集上最优的一组超参数。</p>
<p>测试集是我们最终用来评估模型的数据集。当模型在测试集上评测时，我们的模型已经不允许修改了。我们一般把模型在测试集上的评测结果作为模型的性能评估标准。</p>
<blockquote>
<p>在我们之前实现的小猫分类项目中，准确来说，我们使用的不叫测试集，而叫做开发集，因为我们是根据那个”testing set”优化网络超参数的。</p>
<p>有人把训练集比作上课，开发集比作作业，测试集比作考试。如果你理解了这三个数据集的原理，会发现这个比喻还是挺贴切的。事实上，由于测试集不参与训练，一个机器学习项目可以没有测试集，就像我们哪怕不经过考试，也可以学到知识一样。</p>
<p>人们很容易混淆开发集/测试集。很多论文甚至把开发集作为最终的性能评估结果。但是很多时候审稿人对这些细节并不在意。作为有操守的研究者，应该严肃地区分开发集与测试集。</p>
</blockquote>
<h3 id="通过划分数据得到训练-测试集"><a href="#通过划分数据得到训练-测试集" class="headerlink" title="通过划分数据得到训练/测试集"></a>通过划分数据得到训练/测试集</h3><p>在前一个机器学习纪元，人们通常会拿到一批数据，按7:3的比例划分训练集/测试集（对于没有超参数要调的模型），或者按6:2:2的比例划分训练集/开发集/测试集。</p>
<p>而在深度学习时代，数据量大大增加。实际上，开发集和测试集的目的都是评估模型，而评估模型所需的数据没有训练需要得那么多。所以，当整体的数据规模达到百万级，甚至更多时，我们只需要各取10000组数据作为开发集和测试集即可。</p>
<h3 id="收集来自不同分布的数据集"><a href="#收集来自不同分布的数据集" class="headerlink" title="收集来自不同分布的数据集"></a>收集来自不同分布的数据集</h3><p>除了从同一批数据中划分出不同的数据集，还有另一种得到训练集、测试集的方式——从不同分布中收集数据集。</p>
<blockquote>
<p><strong>分布</strong>是统计学里的概念，这里可以理解成不同来源，内容的“平均值”差别很大的数据。</p>
</blockquote>
<p>比如，假如我们要为某个小猫分类器收集小猫的图片，我们的训练图片可以是来自互联网，而开发和验证的数据来自用户用收集拍摄的图片。</p>
<p>注意，由于开发集和验证集都是用来评估的，它们应该来自同一个分布。</p>
<h2 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h2><p>机器学习中，我们的模型会出现高偏差或/和高误差的问题。我们需要设法判断我们的模型是否有这些问题。</p>
<p>偏差(bias)与方差(variance)是统计学里的概念，前者表示一组数据离期待的平均值的差距，后者表示数据的离散程度。</p>
<blockquote>
<p>试想一个射击运动员在打靶。偏差与打靶的总分数有关，因为总分越高，意味着每次射击都很靠近靶心；方差与选手的发挥稳定性有关，比如一个不稳定的选手可能一次9环，一次6环。</p>
</blockquote>
<p>高偏差意味着模型总是不能得到很好的结果，高方差意味着模型不能很好地在所有数据集上取得好的结果（即只能在某些特定数据集上表现较好，在其他数据集上都表现较差）。</p>
<p>我们把高偏差的情况叫做“欠拟合”（可能模型还没有训练完，所以表现不够好），把高方差的情况叫做“过拟合”（模型在训练集上训练过头了，结果模型只能在训练集上有很好的表现，在其他数据集上表现偶读不好）。</p>
<p>让我们看课件里的一个点集分类的例子：</p>
<p><img src="/2022/06/11/DLS-note-5/2.jpg" alt></p>
<p>上图显示了欠拟合、“恰好”、过拟合这三种情况。</p>
<p>对于欠拟合的情况来说，一条直线并不足以把两类点分开，这个模型的整体表现较差。</p>
<p>对于过拟合的情况来说，模型过分追求训练集上的正确，结果产生了一条很奇怪的曲线。由于训练数据是有噪声（数据的标签不完全正确）的，这样的模型在真正的测试上可能表现不佳。</p>
<p>让我们人类来划分的话，最有可能给出的是中间那种划分结果。在这个模型中，虽然有些训练集中的点划分错了，但我们会认为这个模型在绝大多数数据上更合适。当我们用更多的测试数据来测试这个模型时，中间那幅图的测试结果肯定是这三种中最好的。</p>
<p>要判断机器学习模型是否存在高偏差或高方差的现象，可以去观察模型的训练集误差和开发集误差。以下是一个判断示例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>情况</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>训练集误差</td>
<td>1%</td>
<td>15%</td>
<td>0.5%</td>
<td>15%</td>
</tr>
<tr>
<td>开发集误差</td>
<td>11%</td>
<td>16%</td>
<td>1%</td>
<td>30%</td>
</tr>
<tr>
<td>诊断结果</td>
<td>高方差</td>
<td>高偏差</td>
<td>低误差、低方差</td>
<td>高误差、高方差</td>
</tr>
</tbody>
</table>
</div>
<p>也就是说，如果开发集和训练集的表现差很多，就说明是高方差；如果训练集上的表现都很差，就是高偏差。</p>
<blockquote>
<p>上面这些结论建立在最优误差——贝叶斯误差(Beyas Error)是0%的基础上下的判断。很多时候，仅通过输入数据中的信息，是不足以下判断的。比如告诉一个人是长头发，虽然这个人大概率是女生，但我们没有100%的把握说这是女生。如果我们知道人群中留长发的90%是女生，10%是男生，那么在这个“长头发分辨性别”的任务里的贝叶斯误差就是10%。</p>
<p>假如上面那个任务的贝叶斯误差是15%，那么我们认为情况2也是一个低误差的情况，因为它几乎做到了最优的准确率。</p>
</blockquote>
<h2 id="改进机器学习的基本方法"><a href="#改进机器学习的基本方法" class="headerlink" title="改进机器学习的基本方法"></a>改进机器学习的基本方法</h2><p>通过上一节介绍的看训练误差、测试误差的方式，我们能够诊断出我们的模型当前是否存在高偏差或高误差的问题。这一节我们来讨论如何解决这些问题。</p>
<p>首先检查高偏差问题。如果模型存在<strong>高偏差</strong>，则应该尝试使用<strong>更复杂的网络</strong>、<strong>更多增加训练时间</strong>。</p>
<p>确保模型没有高偏差问题后，才应该开始检查模型的方差。如果模型存在<strong>高方差</strong>，则应该<strong>增加数据</strong>或<strong>使用正则化</strong>。</p>
<p>此外，使用更合理的网络架构，往往对降低误差和方差都有效。</p>
<h2 id="正则化-Regularization"><a href="#正则化-Regularization" class="headerlink" title="正则化 (Regularization)"></a>正则化 (Regularization)</h2><p>其实正则化的意思就是“为防止过拟合而添加额外信息的过程”。在机器学习中，一种正则化方法是给损失函数添加一些<strong>与参数有关的额外项</strong>，以调整参数在梯度下降中的更新过程。正则化的数学原理我们会在下一节里学习，这一节先认识一下正则化是怎么操作的。</p>
<p>先看一下，对于简单的逻辑回归，我们应该怎么加正则化项。</p>
<p>原来，逻辑回归的损失函数是:</p>
<script type="math/tex; mode=display">
J(w, b) = \frac{1}{m}\Sigma_{i=1}^{m}L(\hat{y}, y)</script><p>现在我们给它加一个和参数$w$有关的项</p>
<script type="math/tex; mode=display">
J(w, b) = \frac{1}{m}\Sigma_{i=1}^{m}L(\hat{y}, y) + \frac{\lambda}{2m}||w^2||_2</script><p>最右边那个 $\frac{\lambda}{2m}||w||^2_2$ 就是额外加进来的正则项。其中$\lambda$是一个可调的超参数，$||w||^2_2$表示计算向量$w$的l2范数，即:</p>
<script type="math/tex; mode=display">
||w||^2_2 = \Sigma_{j=1}^{n_x}w_j^2</script><p>也就是说，某向量的l2范数就是它所有分量平方再求和。</p>
<p>类似地，其实向量也有1范数，也可以用来做正则化：</p>
<script type="math/tex; mode=display">
||w||_1 = \Sigma_{j=1}^{n_x}|w_j|</script><p>1范数就是向量所有分量取绝对值再求和。</p>
<p>使用1范数做正则化会导致参数中出现很多0。人们还是倾向使用l2范数做正则化。</p>
<p>看到这里，大家或许会有问题：$b$也是逻辑回归的参数，为什么$w$有正则项，$b$就没有？实际上，要给$b$加正则项也可以。但是在大多数情况下，参数$w$的数量远多于$b$, 和$b$相关的正则项几乎不会影响到最终的损失函数。为了让整个过程更简洁一些，$b$的正则项就被省略了。（其实就是程序员们偷懒了，顺便让计算机也偷个懒）</p>
<p>当情况推广到神经网络时，添加正则项的方法是类似的，只不过参数$W$变成了矩阵而已。对应的正则项如下：</p>
<script type="math/tex; mode=display">
\frac{\lambda}{2m}\Sigma_{l=1}^{L}||W^{[l]}||_F^2</script><p>其中,</p>
<script type="math/tex; mode=display">
||W^{[l]}||_F^2 = \Sigma_{i=1}^{n^{[l]}}\Sigma_{j=1}^{n^{[l-1]}}(W_{ij}^{[l]})^2</script><p>这种矩阵范数叫做Frobenius范数，叫它F-范数就行了。</p>
<p>如之前的文章所述，对于梯度下降算法来说，定义损失函数的根本目的是为了对参数求导。当参数$W$在损失函数里多了一项后，它的导数会有怎样的变化呢？</p>
<p>对于某参数向量$w$来说，其实它的导数就多了一项：</p>
<script type="math/tex; mode=display">
\begin{align*}
& (\frac{\lambda}{2m}w^2)' \\
=& \frac{\lambda}{m}w
\end{align*}</script><blockquote>
<p>大家知道为什么正则项分母里有一个2了吗？没错，这是为了让求出来的导数更简洁一点。反正有超参数$\lambda$，分母多个2少个2没有任何区别。</p>
</blockquote>
<p>最终，参数向量$w$会按如下的方式更新：</p>
<script type="math/tex; mode=display">
\begin{align*}
w &:= w - \alpha (dw +\frac{\lambda}{m}w) \\
\Rightarrow w &:=(1-\frac{\alpha\lambda}{m})w-\alpha dw
\end{align*}</script><p>仔细一看，其实相较之前的梯度更新公式，只是$w$的系数从$1$变成了$1-\frac{\alpha\lambda}{m}$。因此，用l2范数做正则化的方法会被称为 <strong>“权重衰减(Weight Decay)”</strong> ,$\lambda$在某些编程框架中直接就被叫做<code>weight decay</code>。</p>
<h2 id="为什么正则项能减少方差"><a href="#为什么正则项能减少方差" class="headerlink" title="为什么正则项能减少方差"></a>为什么正则项能减少方差</h2><p>回忆前面见过的“高方差”的拟合曲线：</p>
<p><img src="/2022/06/11/DLS-note-5/3.jpg" alt></p>
<p>这个曲线之所以能够那么精确地过拟合，是因为这个曲线的参数过多。如果这个曲线的参数少一点，那么它就不会有那么复杂的形状，过拟合现象也会得到缓解。</p>
<p>也就是说，如果神经网络简单一点，每个参数对网络的影响小一点，那么网络就更难去过拟合那些极端的数据。</p>
<p>添加了正则项后，网络的参数都受到了一定的“惩罚”。因此，参数会倾向于变得更小，从而产生刚刚提到的减轻过拟合的效果。</p>
<h2 id="Dropout-失活"><a href="#Dropout-失活" class="headerlink" title="Dropout (失活)"></a>Dropout (失活)</h2><blockquote>
<p>Dropout 怎么翻译都不好听，直接保持英文吧。</p>
</blockquote>
<p>还有一种常用的正则化方法叫做 dropout，即随机使神经网络中的一些神经元“失活”。如下图所示：</p>
<p><img src="/2022/06/11/DLS-note-5/4.jpg" alt></p>
<p>我们可以令所有神经元<strong>在每轮训练中</strong>有50%的几率失活。在某轮训练中，神经网络的失活情况可能会像上图中下半部分所示：那些打叉的神经元不参与计算和，整个神经网络变得简单了许多。</p>
<p>在实现时，我们常常使用一种叫做”Inverted dropout”的实现方法。Inverted dropout 的思想是：<strong>对于神经网络的每一层</strong>，生成一个表示有哪些神经元失活的“失活矩阵”，再用这个矩阵去乘上这一层的激活输出（做乘法即令没有失效的激活保持原值，失效的激活取0）</p>
<p>其实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = np.random.rand(a.shape[<span class="number">0</span>], a.shape[<span class="number">1</span>]) &lt; keep_prob</span><br><span class="line">a = a * d</span><br><span class="line">a /= keep_prob</span><br></pre></td></tr></table></figure>
<p>这段代码中，<code>d</code>是失活矩阵。该矩阵通过一个随机数矩阵和一个保留概率<code>keep_prob</code>做小于运算生成。<code>np.random.rand</code>可以生成一个矩阵，其中矩阵中每个数都会均匀地随机出现在0~1之间。这样，每个数小于<code>keep_prob</code>的概率都是<code>keep_prob</code>。比如<code>keep_prob=0.8</code>,那么每个神经元都有80%的几率得到保留，20%的几率被丢弃。</p>
<p>做完小于运算后，<code>d</code>其实是一个bool值矩阵。拿bool矩阵和一个普通矩阵做逐对乘法，就等于bool矩阵为True的地方取普通矩阵的原值，bool矩阵为False的地方取0。</p>
<p>最后，得到了丢弃掉某些神经元的激活输出a后，我们还要做一个操作<code>a /= keep_prob</code>。可以想象，如果我们丢掉了一些神经元，那么整个激活输出的“总和”的期望会变小。比如<code>keep_prob</code>为0.8，那么整个输出的大小都近似会变为原来的0.8倍。为了让输出的期望不变，我们要把激活输出除以<code>keep_prob</code>。</p>
<p>如前文所强调的，dropout一次是对一层而言的。也就是说，每一层可以有不同的<code>keep_prob</code>。</p>
<p>dropout可能对损失函数变化曲线产生影响。一般调试时，如果损失函数一直在降，就说明训练算法没什么问题。但是，加入dropout后，由于每次优化的参数不太一样了，损失函数可能不会单调递减。因此，为了调试神经网络，可以先关闭dropout。确定损失函数确实在下降后，再开启它。</p>
<blockquote>
<p>由于在CV（计算机视觉）中，图像的输入规模都很大，数据不足而引起过拟合是一件常见的事。因此，dropout在CV中被广泛应用。</p>
</blockquote>
<p>注意，dropout是一种训练策略。在测试的时候，不需要使用dropout。</p>
<p>和刚才一样，我们再来探讨一下为什么dropout能够生效。有了dropout，意味着神经网络的权重不能集中在部分神经元上，因为某个神经元随时都可能会失效。因此，神经网络的权重会更加平均。更加平均，意味着计算参数平方的l2范数会更小。也就是说，dropout令参数更平均，起到了和刚刚添加l2正则类似的效果。</p>
<h2 id="其他正则化方法"><a href="#其他正则化方法" class="headerlink" title="其他正则化方法"></a>其他正则化方法</h2><ol>
<li>数据增强</li>
</ol>
<p><img src="/2022/06/11/DLS-note-5/5.jpg" alt></p>
<p>比如对于一幅图片，我们可以翻转、旋转、缩进，以生成“更多”的训练数据。</p>
<ol>
<li>提前停止 (early stopping)</li>
</ol>
<p><img src="/2022/06/11/DLS-note-5/6.jpg" alt></p>
<p>随着训练的进行，网络的损失函数可能越来越小，但开发集上的精度会越来越高。只是因为训练得越久，参数就会越来越大，即越来越倾向于过拟合。提早结束训练，能够让参数取到一个合适的值。</p>
<p>提前中止也有一些不好的地方。在机器学习中，训练模型可以分成两部分：让损失函数更小、防止模型过拟合。我们通常会对这两部分独立地进行优化，即控制优化方法不变，改变正则化方法；或者改变减小梯度的算法，保证模型不进行任何正则化操作。而提前中止实际上混淆了减小损失函数和防止模型过拟合这两件事，不利于采取更多的调试策略。</p>
<blockquote>
<p>独立地看待问题的两个变量，这种方法叫做 <strong>“正交化”</strong>。这种控制变量的思想在科研、编程，甚至是处理人生中各种各样的问题时都很适用。</p>
</blockquote>
<h2 id="输入归一化-Normalization"><a href="#输入归一化-Normalization" class="headerlink" title="输入归一化(Normalization)"></a>输入归一化(Normalization)</h2><blockquote>
<p>参考网上的翻译，我把 Normalization 翻译为归一化，Standardization 翻译成标准化。其实这两个中文翻译经常会混着用，翻译上的区别不用太在意。</p>
</blockquote>
<p>我们应该尽可能让输入向量的每一个分量都满足标准正态分布。如果你对数学不熟，我们可以来看一个例子:</p>
<p><img src="/2022/06/11/DLS-note-5/7.jpg" alt></p>
<p>假设我们每个输出张量长度为2，即有两个分量:$x_1, x_2$。我们可以认为每个输入向量就是一个二维平面上的点。统计完了所有样本，我们或许可以发现所有样本的$x_1$位于[0, 5]这个区间，$x_2$位于[0, 3]这个区间，两个区间长度不一。而且，数据在$x_1$上比较分散,$x_2$上比较靠拢。这个训练样本显得非常凌乱。</p>
<p>如果我们让输入归一化，使输入向量的每一个分量都满足了正态分布，难么这些数据可能会长得这样:</p>
<p><img src="/2022/06/11/DLS-note-5/8.jpg" alt></p>
<p>这样，数据分布的区间不仅长度相同，而且离散的程度也相同了。</p>
<p>归一化可以通过以下方式实现：</p>
<script type="math/tex; mode=display">
\mu=\frac{1}{m}\Sigma_{i=1}^{m}x^{(i)} \\
x := (x - \mu) \\
\sigma^2=\frac{1}{m}\Sigma_{i=1}^{m}(x^{(i)})^2 \\
x := x / \sigma</script><blockquote>
<p>注意，上式中我们计算方差时没有减均值，这是因为第二步更新的时候均值已经被减掉了。</p>
</blockquote>
<p>简单概括这个数学公式，就是“减均值，除方差”。</p>
<p>如果输入数据在各个分量上更加均匀，梯度下降的优化会更加便捷。</p>
<blockquote>
<p>这里直接记住这个结论，不用过于在意它的数学原理。一种比较直观的解释是：如果分量大小不一，则参数w的每个分量的“作用”也会大小不一。如果w的每个分量都按差不多的“步伐”进行更新，那些“影响力更大”的w分量就会更新得过头，而“影响力更小”的w分量就更新得不足。这样，梯度下降法要耗费更多步才能找到最优值。<br><img src="/2022/06/11/DLS-note-5/9.jpg" alt></p>
</blockquote>
<h2 id="梯度爆炸-弥散"><a href="#梯度爆炸-弥散" class="headerlink" title="梯度爆炸/弥散"></a>梯度爆炸/弥散</h2><p>如果一个神经网络的层数过深，可能会出现梯度极大或极小的情况，让我们看看这是怎么回事。</p>
<p><img src="/2022/06/11/DLS-note-5/10.jpg" alt></p>
<p>假设我们有上图这样一个“很深”的神经网络。我们取消所有的激活函数（即$g(x)=x$），取消所有参数$b$（即$b=0$），那么这个网络的公式就是</p>
<script type="math/tex; mode=display">
\hat{Y}=A=W^W^NaN...W^1X</script><p>其中$W^NaN…W^1$都是2x2的矩阵。我们不妨假设它们都是同样的矩阵，那么上式可以写成</p>
<script type="math/tex; mode=display">
\hat{Y}=A=W^(W')^{L-1}X</script><p>如果$W’$长这个样子：</p>
<script type="math/tex; mode=display">
W'=\left[
  \begin{matrix}
  &1.5  &0 \\
  &0  &1.5 \\
  \end{matrix}
\right]</script><p>那么经过$L-1$次矩阵乘法后，这个矩阵就变成这个样子：</p>
<script type="math/tex; mode=display">
W'^{L-1}=\left[
  \begin{matrix}
  &1.5^{L-1}  &0 \\
  &0  &1.5^{L-1}  \\
  \end{matrix}
\right]</script><p>由于这里的数值是随着$L$成指数增长的，$L$稍微取一个大一点的值，最后算出来的$A$就会特别大。回顾一下前面的知识，最后一层的$dZ=A-Y$，而$dW$又是和$dZ$相关的。最后的$A$很大，会导致所有算出来的梯度都很大。</p>
<blockquote>
<p>这里要批评一下这门课。课堂里有一个地方讲得不够清楚：为什么$A$很大，参数的梯度$dW$就很大。课堂里只是带了一句，说可以用类似的方法得出$dW$的增长规律和$A$类似。但这里漏了一条逻辑链：算梯度的时候，$A$和$dW$有关联性（$dZ$和$A$有关，$dW$和$dZ$有关）。直观上来看，$A$很大，不能推出梯度就很大。中间还是欠缺了一步逻辑推理的。学东西和看东西一定要养成批判性思维，考据每一步推理的合理性。</p>
</blockquote>
<p>同理，如果矩阵里的数不是1.5，而是0.5，那么整个公式的数值就会指数级下降，从而导致梯度近乎“消失”。</p>
<h2 id="梯度问题的解决方法——加权初始化"><a href="#梯度问题的解决方法——加权初始化" class="headerlink" title="梯度问题的解决方法——加权初始化"></a>梯度问题的解决方法——加权初始化</h2><blockquote>
<p>推荐一篇讲这个知识点的英文文章：<a target="_blank" rel="noopener" href="https://towardsdatascience.com/weight-initialization-in-neural-networks-a-journey-from-the-basics-to-kaiming-954fb9b47c79">https://towardsdatascience.com/weight-initialization-in-neural-networks-a-journey-from-the-basics-to-kaiming-954fb9b47c79</a>.</p>
</blockquote>
<p>刚刚我们讲到，梯度会爆炸或者弥散，本质原因是矩阵$W$的“大小”大于了1或者小于了1，从而使最后的计算结果过大或过小。但反过来想，如果我们令每一层的输出$A^{[l]}$的“大小”都在1附近，那么是不是就不会有梯度指数级变化的问题了呢？</p>
<p>让我们来看看该如何让每层输出$A^{[l]}$都保持一个合适的值。我们考察</p>
<script type="math/tex; mode=display">Z=w_1x_1+w_2x_2...+w_nx_n</script><p>这个简单的网络。从直觉上看，如果$n$越大，则公式里的项越多，$Z$也越大。事实上，用统计学知识计算过后，能知道：若$w_i$都是满足标准正态分布的，则$Z$的方差是$n$。我们不希望$Z$的值太大或太小，希望能通过修改$w_i$的大小，让$Z$的方差尽可能等于1。</p>
<p>为了做到这一点，我们可以在$w$的初始化方法上做一点文章。我们可以改变$w$的方差，以改变$Z$的方差。其实，我们只要令$w$的方差为$\frac{1}{n}$就行了。用代码表示就是这样的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W_l = np.random.randn(shape) * np.sqrt(<span class="number">1</span> / n[l-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>别忘了哦，这里<code>n[l-1]</code>是第l层参数矩阵<code>W_l</code>的长度，即每个参数向量$w$的长度。</p>
<p>但由于每一层的输入不是$Z$，而是$A=g(Z)$，我们在算方差时还要考虑到激活函数$g$的影响。</p>
<p>经 Kaiming He 等人的研究，使用 Relu 时，初始化的权重用<code>np.sqrt(2/ n[l-1])</code>比较好，即用下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W_l = np.random.randn(shape) * np.sqrt(<span class="number">2</span> / n[l-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>对于 tanh 函数，令权重为 <code>np.sqrt(1 / n[l-1])</code>就行，这叫做 Xavier Initialization。还有研究表明用 <code>np.sqrt(2 / (n[l-1]+n[l]))</code>也行。</p>
<p>总结一下，为了<strong>缓解</strong>梯度爆炸或梯度弥散的问题，可以对参数使用加权初始化。只需要初始化时多乘一个小系数，这个问题就能很大程度上有所缓解。</p>
<h2 id="梯度检查"><a href="#梯度检查" class="headerlink" title="梯度检查"></a>梯度检查</h2><p>进行深度学习编程时，梯度计算是比较容易出BUG的地方。我们可以用一种简单的方法来<strong>近似估计</strong>一个函数的导数，并将其与我们算出来的导数做一个对比，看看我们的导数计算函数有没有写错。</p>
<p>导数估计公式如下：</p>
<script type="math/tex; mode=display">
f'(\theta) \approx \frac{f(\theta+\epsilon)-f(\theta+\epsilon)}{2\epsilon}</script><p>这个式子随$\epsilon$收敛得较块，准确来说:</p>
<script type="math/tex; mode=display">
\begin{align}
f(\theta+\epsilon)&\approx f(\theta)+\epsilon f'(\theta)+\frac{1}{2}\epsilon^2f''(\theta) + \frac{1}{6}\epsilon^3f'''(\theta)+... \\
\frac{f(\theta+\epsilon)-f(\theta)}{\epsilon} &\approx  f'(\theta)+\frac{1}{2}\epsilon f''(\theta) \\
\frac{f(\theta+\epsilon)-f(\theta-\epsilon)}{2\epsilon} &\approx  f'(\theta)+\frac{1}{6}\epsilon^2 f'''(\theta)
\end{align}</script><p>当$lim_{\epsilon \to 0}$时，上面(2)式的收敛速度是$O(\epsilon)$，(3)式的收敛速度是$O(\epsilon^2)$。选用(3)式估计导数是一个更好的选择。</p>
<p>我们可以利用上面的公式调试深度学习中的梯度计算。其步骤如下：</p>
<ol>
<li>把所有参数$W^{[1]}, b^{[1]}…$ reshape 成向量，再把所有向量拼接(concatenate) 成一个新向量$\theta$。</li>
<li>现在，我们有损失函数$J(\theta)$和导数$d\theta$。</li>
<li>对于某一个参数$\theta_i$，计算其导数估计值：</li>
</ol>
<script type="math/tex; mode=display">
\hat{d_{\theta_i}}=\frac{J(\theta_0, ..., \theta_i+\epsilon, ...)-J(\theta_0, ..., \theta_i-\epsilon, ...)}{2\epsilon}</script><ol>
<li>比较$\hat{d<em>{\theta_i}}, d</em>{\theta_i}$，计算误差值：</li>
</ol>
<script type="math/tex; mode=display">
error=\frac{||\hat{d_{\theta_i}}-d_{\theta_i}||_2}{||\hat{d_{\theta_i}}||_2\cdot||d_{\theta_i}||_2}</script><ol>
<li>遍历所有$\theta_i$，做这个检查。</li>
</ol>
<p>一般可以令$\epsilon=10^{-7}$。如果error在$10^{-7}$这个量级，则说明导数计算得没什么问题。$10^{-5}$可能要注意一下，而$10^{-3}$则大概率说明这里的导数算得有问题。</p>
<p>使用此梯度检查法时，有一些小提示：</p>
<ul>
<li>不要每次训练的都用，只在训练前调试用。</li>
</ul>
<blockquote>
<p>梯度检查确实很慢，计算复杂度是$\Omega(|\theta|^2)$（这里没有用大O标记，因为复杂度的下界是那个值，而不是上界）（这个复杂度是$|\theta|$乘上算一遍推理的运算量得来的。推理至少遍历每个参数一遍，所以推理的复杂度是$\Omega(|\theta|)$）。</p>
</blockquote>
<ul>
<li><p>如果梯度检查出现了问题，尝试debug具体出错的参数。</p>
</li>
<li><p>别忘记损失函数中的正则化项。</p>
</li>
<li><p>无法调试 dropout.</p>
</li>
<li><p>有时候，当$W, b$过大时导数的计算才会出现较大的误差。可以尝试先训练几轮网络，等参数大了，再做一次梯度检查。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这堂课的信息量十分大。让我们总结一下：</p>
<ul>
<li>数据集划分<ul>
<li>训练集/开发集/测试集的意义</li>
<li>怎么去根据数据规模划分不同的数据集</li>
</ul>
</li>
<li>偏差与方差<ul>
<li>如何分辨高偏差与高方差问题</li>
<li>高偏差与高方差问题的一般解决思路</li>
</ul>
</li>
<li>正则化<ul>
<li>权重衰减</li>
<li>dropout</li>
<li>数据增强</li>
<li>提前停止</li>
</ul>
</li>
<li>梯度问题<ul>
<li>梯度问题的产生原因</li>
<li>缓解梯度问题的方法</li>
</ul>
</li>
<li>梯度检查的实现</li>
</ul>
<p>这堂课中，<strong>正则化</strong>和<strong>参数带权初始化</strong>是两个很重要的话题，展开来的话有很多东西要学。过段时间，我会在课堂内容的基础上，对这些知识进行拓展介绍。</p>
<h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><p>在本周的代码实战中，我们将继续以点集分类任务为例，完成<strong>参数初始化</strong>和<strong>正则化</strong>两项任务。</p>
<h2 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/Initialization">https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/Initialization</a></p>
<p>在参数初始化问题中，我们要探究不同初始化方法对梯度更新的影响。假设我们有下面这样一个点集分类数据集：</p>
<p><img src="/2022/06/11/DLS-note-5/11.jpg" alt></p>
<p>我们分别用下面三种方法去初始化参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> initialization == <span class="string">&#x27;zeros&#x27;</span>:</span><br><span class="line">    self.W.append(np.zeros((neuron_cnt[i + <span class="number">1</span>], neuron_cnt[i])))</span><br><span class="line"><span class="keyword">elif</span> initialization == <span class="string">&#x27;random&#x27;</span>:</span><br><span class="line">    self.W.append(</span><br><span class="line">        np.random.randn(neuron_cnt[i + <span class="number">1</span>], neuron_cnt[i]) * <span class="number">5</span>)</span><br><span class="line"><span class="keyword">elif</span> initialization == <span class="string">&#x27;he&#x27;</span>:</span><br><span class="line">    self.W.append(</span><br><span class="line">        np.random.randn(neuron_cnt[i + <span class="number">1</span>], neuron_cnt[i]) *</span><br><span class="line">        np.sqrt(<span class="number">2</span> / neuron_cnt[i]))</span><br><span class="line">self.b.append(np.zeros((neuron_cnt[i + <span class="number">1</span>], <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
<p>如果使用0初始化的话，就会出现之前学过的“参数对称性”问题。这个网络几乎学不到任何东西：</p>
<p><img src="/2022/06/11/DLS-note-5/12.jpg" alt></p>
<p>如果用比较大的值初始化的话，网络的梯度一直会很高，半天降不下来，学习速度极慢：</p>
<p><img src="/2022/06/11/DLS-note-5/13.jpg" alt></p>
<p>最后，我们使用比较高端的He Initialization.网络能够顺利学到东西了。</p>
<p><img src="/2022/06/11/DLS-note-5/14.jpg" alt></p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/Regularization">https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/Regularization</a></p>
<p>正则化要解决的是过拟合。为了“迫使”网络产生过拟合，我“精心”构造一个点集分类数据集：</p>
<p><img src="/2022/06/11/DLS-note-5/15.jpg" alt></p>
<p>在这个分类任务中，比较理想的分类结果是一条直线。但是，由于表示噪声的蓝点比较多，网络可能会过拟合训练数据。</p>
<p>在这项实验中，我们将分别测试在“不使用正则化”、“使用正则项”、“使用dropout”这三种配置下网络的表现情况。</p>
<p>如我们所预计地，不使用正则化策略的网络会过拟合训练数据：</p>
<p><img src="/2022/06/11/DLS-note-5/16.jpg" alt></p>
<p>之后，我们按照公式，尝试给网络添加正则化项：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span>(<span class="params">self, learning_rate</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">        <span class="keyword">if</span> self.weight_decay:</span><br><span class="line">            LAMBDA = <span class="number">4</span></span><br><span class="line">            self.W[i] = (<span class="number">1</span> - learning_rate * LAMBDA / self.m</span><br><span class="line">                          ) * self.W[i] - learning_rate * self.dW_cache[i]</span><br><span class="line">            self.b[i] -= learning_rate * self.db_cache[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.W[i] -= learning_rate * self.dW_cache[i]</span><br><span class="line">            self.b[i] -= learning_rate * self.db_cache[i]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">self, Y: np.ndarray, Y_hat: np.ndarray</span>) -&gt; np.ndarray:</span></span><br><span class="line">    <span class="keyword">if</span> self.weight_decay:</span><br><span class="line">        LAMBDA = <span class="number">4</span></span><br><span class="line">        tot = np.mean(-(Y * np.log(Y_hat) + (<span class="number">1</span> - Y) * np.log(<span class="number">1</span> - Y_hat)))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">            tot += np.<span class="built_in">sum</span>(self.W[i] * self.W[i]) * LAMBDA / <span class="number">2</span> / self.m</span><br><span class="line">        <span class="keyword">return</span> tot</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> np.mean(-(Y * np.log(Y_hat) + (<span class="number">1</span> - Y) * np.log(<span class="number">1</span> - Y_hat)))</span><br></pre></td></tr></table></figure>
<p>网络成功规避了过拟合。</p>
<p><img src="/2022/06/11/DLS-note-5/17.jpg" alt></p>
<p>接下来，我们来尝试使用dropout策略。在训练时，我们每层有50%的概率丢掉训练结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, train_mode=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> train_mode:</span><br><span class="line">        self.m = X.shape[<span class="number">1</span>]</span><br><span class="line">    A = X</span><br><span class="line">    self.A_cache[<span class="number">0</span>] = A</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">        Z = np.dot(self.W[i], A) + self.b[i]</span><br><span class="line">        <span class="keyword">if</span> i == self.num_layer - <span class="number">1</span>:</span><br><span class="line">            A = sigmoid(Z)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A = get_activation_func(self.activation_func[i])(Z)</span><br><span class="line">        <span class="keyword">if</span> train_mode <span class="keyword">and</span> self.dropout <span class="keyword">and</span> i &lt; self.num_layer - <span class="number">1</span>:</span><br><span class="line">            keep_prob = <span class="number">0.5</span></span><br><span class="line">            d = np.random.rand(*A.shape) &lt; keep_prob</span><br><span class="line">            A = A * d / keep_prob</span><br><span class="line">        <span class="keyword">if</span> train_mode:</span><br><span class="line">            self.Z_cache[i] = Z</span><br><span class="line">            self.A_cache[i + <span class="number">1</span>] = A</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<p>同样，使用dropout后，我们也得到了一个比较满意的分类结果：</p>
<p><img src="/2022/06/11/DLS-note-5/18.jpg" alt></p>
<p>欢迎大家自行调试这两个项目~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/06/03/DLS-note-summary-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/03/DLS-note-summary-1/" class="post-title-link" itemprop="url">吴恩达《深度学习专项》第一阶段总结与第二阶段预览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-03 20:12:07" itemprop="dateCreated datePublished" datetime="2022-06-03T20:12:07+08:00">2022-06-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>经过前四周的学习，我们已经学完了《深度学习专项》的第一门课程《神经网络与深度学习》。让我们总结一下这几周学的知识，查缺补漏。</p>
<h1 id="《神经网络与深度学习》知识回顾"><a href="#《神经网络与深度学习》知识回顾" class="headerlink" title="《神经网络与深度学习》知识回顾"></a>《神经网络与深度学习》知识回顾</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>在有监督统计机器学习中，我们会得到一个<strong>训练集</strong>。训练集中的每一条<strong>训练样本</strong>由<strong>输入</strong>和<strong>输出</strong>组成。我们希望构建一个数学模型，使得该模型在学习了训练集中的规律后，能够建立起输入到输出的映射。</p>
<p>在<strong>深度学习</strong>中，使用的数学模型是深度<strong>神经网络</strong>。</p>
<p>神经网络一般可以由如下的<strong>计算图</strong>表示：</p>
<p><img src="/2022/06/03/DLS-note-summary-1/1.jpg" alt></p>
<p>其中，每一个圆形的计算单元（又称<strong>神经元</strong>）一般表示$g(WX+b)$这一组计算。$W, b$是线性运算的参数，$g$是激活函数。</p>
<p>为了使神经网络学习到输入和正确输出的映射，我们要定义一个描述网络输出和正确输出之间差距的<strong>损失函数</strong>（即每个样本的网络输出与正确输出的<strong>误差函数</strong>的平均值），并最小化这个损失函数。这样，网络的“学习”就成为了一个优化问题。</p>
<p>为了对这个优化问题求解，通常的方法是<strong>梯度下降法</strong>，即通过求导，使每一个参数都沿着让损失函数减少最快的方向移动。</p>
<h2 id="神经网络的结构"><a href="#神经网络的结构" class="headerlink" title="神经网络的结构"></a>神经网络的结构</h2><p>神经网络由<strong>输入层</strong>，<strong>隐藏层</strong>，<strong>输出层</strong>组成。计算神经网络的层数$L$时，我们只考虑隐藏层与输出层。</p>
<p><img src="/2022/06/03/DLS-note-summary-1/2.jpg" alt></p>
<p>令$x^{(i)[j]}_k$表示某向量在第$i$个样本第$j$层的第$k$个分量。</p>
<p>若每层的神经元个数为$n^{[l]}$，特别地，令输入的通道数$n_x=n^{[0]}$，则每层参数的形状满足$W^{[l]}:(n^{[l]}, n^{[l-1]})$，$b^{[l]}:(n^{[l]}, 1)$。</p>
<p>常见的激活函数有<code>sigmoid, tanh, relu, leaky_relu</code>。一般隐藏层的激活函数$g^{[l]}(l &lt; L)$用<code>relu</code>。对于二分类问题（输出为0或1），输出层的激活函数$g^{[L]}$应用<code>sigmoid</code>。</p>
<h2 id="神经网络的训练"><a href="#神经网络的训练" class="headerlink" title="神经网络的训练"></a>神经网络的训练</h2><ol>
<li>初始化参数：随机初始化$W$并使其绝对值较小，用零初始化$b$。</li>
</ol>
<p>重复执行以下步骤：</p>
<ol>
<li><p><strong>前向传播</strong>：直接运行神经网络，并缓存中间计算结果$A, Z$。</p>
</li>
<li><p><strong>反向传播</strong>：倒着“运行”神经网络，根据求导链式法则，由网络输出求得每一个参数的导数。</p>
</li>
<li><p><strong>梯度下降</strong>：对于每个参数$p = w^{[l]} \ or \ b^{[l]}$，用$p := p-\alpha dp$更新参数。其中$\alpha$叫学习率，表示参数更新的速度。</p>
</li>
</ol>
<h2 id="用numpy实现神经网络"><a href="#用numpy实现神经网络" class="headerlink" title="用numpy实现神经网络"></a>用numpy实现神经网络</h2><ol>
<li>把输入图片进行“压平”操作：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">images = np.reshape(images, (-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<ol>
<li>初始化参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">W = np.random.randn(neuron_cnt[i + <span class="number">1</span>], neuron_cnt[i]) * <span class="number">0.01</span></span><br><span class="line">b = np.zeros((neuron_cnt[i + <span class="number">1</span>], <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<ol>
<li>前向传播</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.A_cache[<span class="number">0</span>] = A</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">    Z = np.dot(self.W[i], A) + self.b[i]</span><br><span class="line">    A = get_activation_func(self.activation_func[i])(Z)</span><br><span class="line">    <span class="keyword">if</span> train_mode:</span><br><span class="line">        self.Z_cache[i] = Z</span><br><span class="line">        self.A_cache[i + <span class="number">1</span>] = A</span><br></pre></td></tr></table></figure>
<ol>
<li>反向传播</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    dZ = dA * get_activation_de_func(self.activation_func[i])(</span><br><span class="line">        self.Z_cache[i])</span><br><span class="line">    dW = np.dot(dZ, self.A_cache[i].T) / self.m</span><br><span class="line">    db = np.mean(dZ, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    dA = np.dot(self.W[i].T, dZ)</span><br><span class="line">    self.dW_cache[i] = dW</span><br><span class="line">    self.db_cache[i] = db</span><br></pre></td></tr></table></figure>
<ol>
<li>梯度下降</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">    self.W[i] -= learning_rate * self.dW_cache[i]</span><br><span class="line">    self.b[i] -= learning_rate * self.db_cache[i]</span><br></pre></td></tr></table></figure>
<h1 id="第一阶段学习情况自评"><a href="#第一阶段学习情况自评" class="headerlink" title="第一阶段学习情况自评"></a>第一阶段学习情况自评</h1><p>学了几周，大家可能不太清楚自己现在的水平怎么样了。这里，我给大家提供了一个用于自我评价的标准，大家可以看看自己现在身处第几层。</p>
<h2 id="Level-1-能谈论深度学习的程度"><a href="#Level-1-能谈论深度学习的程度" class="headerlink" title="Level 1 能谈论深度学习的程度"></a>Level 1 能谈论深度学习的程度</h2><ul>
<li>知道深度学习能解决计算机视觉、自然语言处理等问题。</li>
<li>能够说出“训练集”、“神经网络”等专有名词</li>
</ul>
<h2 id="Level-2-能调用深度学习框架的程度"><a href="#Level-2-能调用深度学习框架的程度" class="headerlink" title="Level 2 能调用深度学习框架的程度"></a>Level 2 能调用深度学习框架的程度</h2><ul>
<li>知道正向传播、反向传播、梯度下降的意义。</li>
<li>虽然现在不会用代码实现学习算法，但通过后面的学习，能够用深度学习框架编写学习算法。</li>
</ul>
<h2 id="Level-3-掌握所有知识细节的程度"><a href="#Level-3-掌握所有知识细节的程度" class="headerlink" title="Level 3 掌握所有知识细节的程度"></a>Level 3 掌握所有知识细节的程度</h2><ul>
<li>反向传播的流程。</li>
<li>为什么必须使用激活函数。</li>
<li>为什么要随机初始化参数。</li>
<li>正向传播时为什么要缓存，缓存的变量在反向传播时是怎么使用的。</li>
</ul>
<h2 id="Level-4-能从零开始实现一个分类器的程度"><a href="#Level-4-能从零开始实现一个分类器的程度" class="headerlink" title="Level 4 能从零开始实现一个分类器的程度"></a>Level 4 能从零开始实现一个分类器的程度</h2><blockquote>
<p>升级语音：别说是用numpy，就算是用纯C++，我也能造一个神经网络！</p>
</blockquote>
<ul>
<li>掌握 numpy 的基本操作。</li>
<li>能用 Python 编写一个神经网络框架。</li>
<li>能用 numpy 实现神经网络的计算细节。</li>
<li>能用 Python 实现读取数据集、输出精度等繁杂的操作。</li>
</ul>
<h1 id="第二阶段知识预览"><a href="#第二阶段知识预览" class="headerlink" title="第二阶段知识预览"></a>第二阶段知识预览</h1><p>《深度学习专项》第二门课的标题是《改进深度神经网络：调整超参数、正则化和优化》。从标题中也能看出，这门课会介绍广泛的改进深度神经网络性能的技术。具体来说，在三周的时间里，我们会学习：</p>
<ul>
<li>第一周：深度学习的实践层面 <ul>
<li>训练集/开发集/测试集的划分</li>
<li>偏差与方差</li>
<li>机器学习的基础改进流程</li>
<li>正则化</li>
<li>输入归一化</li>
<li>梯度问题与加权初始化</li>
<li>梯度检查</li>
</ul>
</li>
<li>第二周：优化算法<ul>
<li>分批梯度下降</li>
<li>更高级的梯度下降算法</li>
<li>学习率衰减</li>
</ul>
</li>
<li>第三周：调整超参数、批归一化和编程框架<ul>
<li>调参策略</li>
<li>批归一化</li>
<li>多分类问题</li>
<li>深度学习框架 TensorFlow</li>
</ul>
</li>
</ul>
<p>目录还是比较凌乱的，让我们具体看一下每项主要知识点的介绍：</p>
<ul>
<li>训练集/开发集/测试集的划分<ul>
<li>之前我们只把数据集划分成训练集和测试集两个部分。但实际上，我们还需要一个用于调试的“开发集”。</li>
</ul>
</li>
<li>偏差与方差<ul>
<li>机器学习模型的性能不够好，体现在高偏差和高方差两个方面。前者表示模型的描述能力不足，后者表示模型在训练集上过拟合。</li>
<li>为了解决过拟合问题，我们要使用添加正则项、dropout等正则化方法。</li>
</ul>
</li>
<li>梯度问题<ul>
<li>在较深的神经网络中，数值运算结果可能会过大或过小，这会导致梯度爆炸或者梯度弥散。</li>
<li>加权初始化可以解决这一问题。我们即将认识多种初始化参数的方法。</li>
</ul>
</li>
<li>优化梯度下降<ul>
<li>使用mini-batch：处理完部分训练数据后就执行梯度下降，而不用等处理完整个训练数据集。</li>
<li>使用更高级的梯度下降算法，比如让梯度更平滑的momentum优化器，以及结合了多种算法的adam优化器。</li>
<li>在训练一段时间后，减少学习率也能提高网络的收敛速度。</li>
</ul>
</li>
<li>调参策略<ul>
<li>在调试神经网络的超参数时，有一些超参数的优先级更高。我们应该按照优先级从高到低的顺序调参。</li>
<li>在调参时，一种技巧是多次随机选取超参数，观察哪些配置下网络的表现最好。</li>
</ul>
</li>
<li>归一化<ul>
<li>对输入做归一化能够加速梯度下降。</li>
<li>除了对输入做归一化外，我们还可以对每一层的输出做批归一化，这项技术能够让我们的网络更加健壮。</li>
</ul>
</li>
<li>多分类问题<ul>
<li>前几周我们一直关注的是二分类问题。我们将学习如何用类似的公式，把二分类问题推广到多分类问题。</li>
</ul>
</li>
<li>编程框架<ul>
<li>深度学习编程框架往往带有自动求导的功能，能够极大提升我们的开发效率。学完第二门课后，我们将一直使用TensorFlow来编程。</li>
<li>我会顺便介绍所有编程任务的 PyTorch 等价实现。</li>
</ul>
</li>
</ul>
<p>可以看出，第二门课包含的内容非常多。甚至很多知识都只会在课堂上提一两句，得通过阅读原论文才能彻底学会这些知识。但是，这门课的知识都非常重要。学完了第二门课后，我们对于深度学习的理解能提升整整一个台阶。让我们做好准备，迎接下周的学习。</p>
<hr>
<p>关注我社交媒体的人，肯定质疑我最近的行为：你最近怎么发文章只注意数量不注意质量啊？怎么一篇文章可以拆开来发好几遍啊？</p>
<p>这你就不懂了。我最近想看看，这些社交平台究竟有多捞：我提供了这么优质的文字内容，我看你们会不会去认真推广，会不会发掘优质内容。结果，我发现这些平台确实都很捞，根本不去好好推送的。没办法，我只好先写一批质量中等的文章，增加发文的次数。我倒要看看这些平台什么时候能给我符合我文章质量的关注量。文章看的人多，我才有继续创作更优质内容的动力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/06/01/20220531-styletransfer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/01/20220531-styletransfer/" class="post-title-link" itemprop="url">Neural Style Transfer 风格迁移经典论文讲解与 PyTorch 实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-01 09:23:03" itemprop="dateCreated datePublished" datetime="2022-06-01T09:23:03+08:00">2022-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">记录</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%B0%E5%BD%95/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天花半小时看懂了“Image Style Transfer Using Convolutional Neural Networks Leon”这篇论文，又花半小时看懂了其 PyTorch 实现，最后用半个下午自己实现了一下这篇工作。现在晚上了，顺便给大家分享一手。</p>
<p>文章会一边介绍风格迁移的原理，一边展示部分代码。完整的代码会在附录里给出。 </p>
<h1 id="基于-CNN-的图像风格迁移"><a href="#基于-CNN-的图像风格迁移" class="headerlink" title="基于 CNN 的图像风格迁移"></a>基于 CNN 的图像风格迁移</h1><h2 id="什么是风格迁移"><a href="#什么是风格迁移" class="headerlink" title="什么是风格迁移"></a>什么是风格迁移</h2><p>我们都知道，每一幅画，都可以看成「内容」与「画风」的组合。</p>
<p><img src="/2022/06/01/20220531-styletransfer/1.jpg" alt></p>
<p>比如名画《呐喊》画了一个张着嘴巴的人，这是一种表现主义的画风。</p>
<p><img src="/2022/06/01/20220531-styletransfer/2.jpg" alt></p>
<p>还有梵高这幅《星夜》，非常有个人风格的一幅夜景。</p>
<p><img src="/2022/06/01/20220531-styletransfer/3.jpg" alt></p>
<p>再比如这幅画，一个二次元画风的少女。</p>
<p><img src="/2022/06/01/20220531-styletransfer/4.jpg" alt></p>
<p>最后展示的是一个帅哥，这是一张写实的照片。</p>
<p>所谓风格迁移，就是把一张图片的风格，嵌入到另一张图片的内容里，形成一张新的图片：</p>
<p><img src="/2022/06/01/20220531-styletransfer/5.jpg" alt></p>
<p>如上图所示，左上角的A是一幅真实的照片，BCD分别是把其他几幅画作的风格迁移到原图中形成的新图片。</p>
<p>究竟是什么技术能够实现这么神奇的「风格迁移」效果呢？别急，让我们从几个简单的例子慢慢学起。</p>
<h2 id="复制一幅图片"><a href="#复制一幅图片" class="headerlink" title="复制一幅图片"></a>复制一幅图片</h2><p>如果你想复制一幅图片，你会怎么做？</p>
<p><img src="/2022/06/01/20220531-styletransfer/6.jpg" alt></p>
<p>在Windows上，你可以打开画图软件，点击左上角的选择框，把要复制的图片框起来。Ctrl+C、Ctrl+V，就能轻松完成图像复制。</p>
<p>但是，我觉得的这种方法太简单了，不能体现出我们这些学过数学的人的智慧。我打算用一个更高端的方法。</p>
<p>我把复制图像的任务，看成一个数学上的优化问题。已知源图像<code>S</code>，我要生成一个目标图像<code>T</code>，使得二者均方误差<code>MSE(S-T)</code>最小。这样，一个生成图像的问题，就变成求最优的<code>T</code>的优化问题。</p>
<p>对于这个问题，我们可以随机初始化一张图像<code>T</code>，然后对上面那个优化目标做梯度下降。几轮下来，我们就能求出最优的<code>T</code>——一幅和源图像<code>S</code>一模一样的目标图像。</p>
<p>这段逻辑可以PyTorch实现：</p>
<p>假设我们通过<code>read_image</code>函数读取了一个图片<code>img</code>，且把图片预处理成了<code>[1, 3, H, W]</code>的格式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source_img = read_image(<span class="string">&#x27;dldemos/StyleTransfer/picasso.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以随机初始化一个<code>[1, 3, H, W]</code>大小的图片。由于这张图片是我们的优化对象，所以我们令<code>input_img.requires_grad_(True)</code>，这样这张图片就可以被PyTorch自动优化了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input_img = torch.randn(<span class="number">1</span>, <span class="number">3</span>, *img_size)</span><br><span class="line">input_img.requires_grad_(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>之后，我们使用PyTorch的优化器<code>LBFGS</code>，并按照优化器的要求传入被优化参数。（这是这篇论文的作者推荐的优化器~）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer = optim.LBFGS([input_img])</span><br></pre></td></tr></table></figure>
<p>一切变量准备就绪后，我们可以执行梯度下降了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">steps = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> steps &lt;= <span class="number">10</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closure</span>():</span></span><br><span class="line">        <span class="keyword">global</span> steps</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss = F.mse_loss(input_img, source_img)</span><br><span class="line">        loss.backward()</span><br><span class="line">        steps += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> steps % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Step <span class="subst">&#123;steps&#125;</span>:&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Loss: <span class="subst">&#123;loss&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line">    optimizer.step(closure)</span><br></pre></td></tr></table></figure>
<p>这段代码有一点要注意：由于<code>LBFGS</code>执行上的特殊性，我们要把执行梯度下降的代码封装成一个闭包（closure，即一个临时定义的函数），并把这个闭包传给<code>optimizer.step</code>。</p>
<p>执行上面的代码进行梯度下降后，这个优化问题很快就能得到收敛。优化结束后，假设我们写好了一个后处理图片的函数<code>save_image</code>，我们可以这样保存它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save_image(input_img, <span class="string">&#x27;work_dirs/output.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>理论上，这幅图片会和我们的源图像<code>img</code>一模一样。</p>
<p>大家看到这里，肯定一肚子疑惑：为什么要用这么复杂的方式去复制图像啊？就好像告诉你x=2，拿优化算法求和x完全相等的y一样。这不直接令y=2就行了吗？别急，让我们再看下去。</p>
<h2 id="拟合神经网络的输出"><a href="#拟合神经网络的输出" class="headerlink" title="拟合神经网络的输出"></a>拟合神经网络的输出</h2><p>刚才我们求解目标图像<code>T</code>的过程，其实可以看成是拟合<code>T</code>的某项<strong>特征</strong>与<code>S</code>的<strong>特征</strong>的过程。只不过，我们使用的是像素值这个最基本的特征。假如我们去拟合更特别的一些特征，会发生什么事呢？</p>
<p>Gatys 等科学家发现，如果用预训练VGG模型不同层的卷积输出作为拟合特征，则可以拟合出不同的图像：</p>
<blockquote>
<p>如果你对预训练VGG模型不熟，也不用担心。VGG是一个包含很多卷积层的神经网络模型。所谓预训练VGG模型，就是在图像分类数据集上训练过的VGG模型。经过了预训练后，VGG模型的各个卷积层都能提取出图像的一些特征，尽管这些特征是我们人类无法理解的。</p>
</blockquote>
<p><img src="/2022/06/01/20220531-styletransfer/7.jpg" alt></p>
<p>上图中，越靠右边的图像，是用越深的卷积层特征进行特征拟合恢复出来的图像。从这些图像恢复结果可以看出，更深的特征只会保留图像的内容（形状），而难以保留图像的纹理（天空的颜色、房子的颜色）。</p>
<p>看到这，大家可能有一些疑惑：这些图片具体是怎么拟合出来的呢？让我们和刚刚一样，详细地看一看这一图像生成过程。</p>
<p>假设我们想生成上面的图c，即第三个卷积层的拟合结果。我们已经得到了模型<code>model_conv123</code>，其包含了预训练VGG里的前三个卷积层。我们可以设立以下的优化目标：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source_feature = model_conv123(source_img)</span><br><span class="line">input_feature = model_conv123(input_img)</span><br><span class="line"><span class="comment"># minimize MSE(source_feature, input_feature)</span></span><br></pre></td></tr></table></figure>
<p>在实现时，我们只要稍微修改一下开始的代码即可。</p>
<p>首先，我们可以预处理出源图像的特征。注意，这里我们要用<code>source_feature.detach()</code>来把<code>source_feature</code>从计算图中取出，防止源图像被PyTorch自动更新。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source_img = read_image(<span class="string">&#x27;dldemos/StyleTransfer/picasso.jpg&#x27;</span>)</span><br><span class="line">source_feature = model_conv123(source_img).detach()</span><br></pre></td></tr></table></figure>
<p>之后，我们可以用类似的方法做梯度下降：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">steps = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> steps &lt;= <span class="number">50</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closure</span>():</span></span><br><span class="line">        <span class="keyword">global</span> steps</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        input_feature = model_conv123(input_img)</span><br><span class="line">        loss = F.mse_loss(input_feature, source_feature)</span><br><span class="line">        loss.backward()</span><br><span class="line">        steps += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> steps % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Step <span class="subst">&#123;steps&#125;</span>:&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Loss: <span class="subst">&#123;loss&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line">    optimizer.step(closure)</span><br></pre></td></tr></table></figure>
<p>看到没，我们刚刚这种利用优化问题生成目标图像的方法并不愚蠢，只是一开始大材小用了而已。通过这种方法，我们可以生成一幅拟合了源图像在神经网络中的深层特征的目标图像。那么，怎么利用这种方法完成风格迁移呢？</p>
<h2 id="风格-内容-风格迁移"><a href="#风格-内容-风格迁移" class="headerlink" title="风格+内容=风格迁移"></a>风格+内容=风格迁移</h2><p>Gatys 等科学家发现，不仅是卷积结果可以当作拟合特征，VGG的一些其他中间结果也可以作为拟合特征。受到之前用CNN做纹理生成的工作[2]的启发，他们发现用卷积结果的Gram矩阵作为拟合特征可以得到另一种图像生成效果：</p>
<p><img src="/2022/06/01/20220531-styletransfer/8.jpg" alt></p>
<p>上图中，右边a-e是用VGG不同卷积结果的Gram矩阵作为拟合特征，得到的对左图的拟合图像。可以看出，用这种特征来拟合的话，生成图像会失去原图的内容（比如星星和物体的位置完全变了），但是会保持图像的整体风格。</p>
<p>这里稍微提一下Gram矩阵的计算方法。Gram矩阵定义在两个特征的矩阵<code>F_1, F_2</code>上。其中，每个特征矩阵<code>F</code>是VGG某层的卷积输出张量<code>F_conv(shape: [n, h, w])</code>reshape成一个矩阵<code>F (shape: [n, h * w])</code>的结果。Gram矩阵，就是两个特征矩阵<code>F_1, F_2</code>的内积，即<code>F_1</code>每个通道的特征向量和<code>F_2</code>每个通道的特征向量的相似度构成的矩阵。我们这里假设<code>F_1=F_2</code>，即对某个卷积特征自身生成Gram矩阵。这段逻辑用代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gram</span>(<span class="params">x: torch.Tensor</span>):</span></span><br><span class="line">    <span class="comment"># x 是VGG卷积层的输出张量</span></span><br><span class="line">    n, c, h, w = x.shape</span><br><span class="line"></span><br><span class="line">    features = x.reshape(n * c, h * w)</span><br><span class="line">    features = torch.mm(features, features.T)</span><br><span class="line">    <span class="keyword">return</span> features</span><br></pre></td></tr></table></figure>
<p>Gram矩阵表示的是通道之间的相似性，与位置无关。因此，Gram矩阵是一种具有空间不变性（spatial invariance）的指标，可以描述整幅图像的性质，适用于拟合风格。与之相对，我们之前拟合图像内容时用的是图像每一个位置的特征，这一个指标是和空间相关的。Gram矩阵只是拟合风格的一种可选指标。后续研究证明，还有其他类似的特征也能达到和Gram矩阵一样的效果。我们不需要过分纠结于Gram矩阵的原理。</p>
<p>看到这里，大家或许已经明白风格迁移是怎么实现的了。风格迁移，其实就是既拟合一幅图像的<strong>内容</strong>，又去拟合另一幅图像的<strong>风格</strong>。我们把前一幅图像叫做<strong>内容图像</strong>，后一幅图像叫做<strong>风格图像</strong>。</p>
<p>我们在上一节知道了如何拟合内容，这一节知道了怎么去拟合风格。要把二者结合起来，只要令我们的优化目标既包含和内容图像的<strong>内容误差</strong>，又包含和风格图像的<strong>风格误差</strong>。在原论文中，这些误差是这样表达的：</p>
<p><img src="/2022/06/01/20220531-styletransfer/9.jpg" alt></p>
<p>上面第一行公式表达的是内容误差，第二行公式表达的是风格误差。</p>
<p>第一行公式中，$F$，$P$分别是生成图像的卷积特征和源图像的卷积特征。</p>
<p>第二行公式中，$F$是生成图像的卷积特征，$G$是$F$的Gram矩阵，$A$是源图像卷积特征的Gram矩阵，$E_l$表示第$l$层的风格误差。在论文中，总风格误差是某几层风格误差的加权和，其中权重为$w_l$。事实上，不仅总风格误差可以用多层风格误差的加权和表示，总内容误差也可以用多层内容误差的加权和表示。只是在原论文中，只使用了一层的内容误差。</p>
<p>第三行中，$\alpha, \beta$分别是内容误差的权重和风格误差的权重。实际上，我们只用考虑$\alpha, \beta$的比值即可。如果$\alpha$较大，则说明优化内容的权重更大，生成出来的图像更靠近内容图像。反之亦然。</p>
<p>只要用这个误差去替换我们刚刚代码实现中的误差，就可以完成图像的风格迁移了，听起来是不是十分简单？但是，用PyTorch实现风格迁移时还要考虑不少细节。在本文的附录中，我会对风格迁移的实现代码做一些讲解。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>其实这篇文章是比较早期的用神经网络做风格迁移的工作。在近两年里，肯定有许多试图改进此方法的研究。时至今日，再去深究这篇文章里的一些细节（为什么用Gram矩阵，应该用VGG的哪些层做拟合）已经意义不大了。我们应该关注的是这篇文章的主要思想。</p>
<p>这篇文章对我的最大启发是：神经网络不仅可以用于在大批数据集上训练，完成一项通用的任务，还可以经过预训练，当作一个特征提取器，为其他任务提供额外的信息。同样，要记住神经网络只是优化任务的一项特例，我们完全可以把梯度下降法用于普通的优化任务中。在这种利用了神经网络的参数，而不去更新神经网络参数的优化任务中，梯度下降法也是适用的。</p>
<p>此外，这篇文章中提到的「风格」也是很有趣的一项属性。这篇文章算是首次利用了神经网络中的信息，用于提取内容、风格等图像属性。这种提取属性（尤其是提取风格）的想法被运用到了很多的后续研究中，比如大名鼎鼎的StyleGAN。</p>
<p>长期以来，人们总是把神经网络当成黑盒。但是，这篇文章给了我们一个掀开黑盒的思路：通过拟合神经网络中卷积核的特征，我们能够窥见神经网络每一层保留了哪些信息。相信在之后的研究中，人们能够更细致地去研究神经网络的内在原理。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Gatys L A, Ecker A S, Bethge M. Image style transfer using convolutional neural networks[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 2414-2423.</p>
<p>[2] Gatys L, Ecker A S, Bethge M. Texture synthesis using convolutional neural networks[J]. Advances in neural information processing systems, 2015, 28.</p>
<p>[3] 代码实现：<a target="_blank" rel="noopener" href="https://pytorch.org/tutorials/advanced/neural_style_tutorial.html">https://pytorch.org/tutorials/advanced/neural_style_tutorial.html</a></p>
<h1 id="附录：PyTorch-实现风格迁移"><a href="#附录：PyTorch-实现风格迁移" class="headerlink" title="附录：PyTorch 实现风格迁移"></a>附录：PyTorch 实现风格迁移</h1><p>这段代码实现是基于 <a target="_blank" rel="noopener" href="https://pytorch.org/tutorials/advanced/neural_style_tutorial.html">PyTorch 官方教程</a> 编写的。</p>
<p>本文的代码仓库链接：<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/StyleTransfer">https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/StyleTransfer</a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先，导入我们需要的库。我们要导入PyTorch的基本库，并导入<code>torchvision</code>做图像变换和初始化预训练模型。此外，我们用<code>PIL</code>读写图像。我们还可以顺手设置一下运算设备（cpu或gpu）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>之后是图像读取。为了正确计算误差，所有图像的形状必须是统一的。因此，在读取图像后，我们要对图像做<code>Resize</code>的预处理。预处理之后，我们得到的图像是<code>c, h, w</code>格式的，别忘了用<code>unsqueeze</code>加上batch那一维。</p>
<blockquote>
<p>这里<code>torchvision</code>中的<code>transforms</code>表示一些预处理操作。部分操作只能对PIL图像进行，而不能对<code>np.ndaray</code>进行。所以，这里用<code>PIL</code>存取图像比用<code>cv2</code>更方便。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img_size = (<span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_image</span>(<span class="params">image_path</span>):</span></span><br><span class="line">    pipeline = transforms.Compose(</span><br><span class="line">        [transforms.Resize((img_size)),</span><br><span class="line">         transforms.ToTensor()])</span><br><span class="line"></span><br><span class="line">    img = Image.<span class="built_in">open</span>(image_path).convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">    img = pipeline(img).unsqueeze(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> img.to(device, torch.<span class="built_in">float</span>)</span><br></pre></td></tr></table></figure>
<p>保存图像时，只要调用<code>PIL</code>的API即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_image</span>(<span class="params">tensor, image_path</span>):</span></span><br><span class="line">    toPIL = transforms.ToPILImage()</span><br><span class="line">    img = tensor.detach().cpu().clone()</span><br><span class="line">    img = img.squeeze(<span class="number">0</span>)</span><br><span class="line">    img = toPIL(img)</span><br><span class="line">    img.save(image_path)</span><br></pre></td></tr></table></figure></p>
<h2 id="误差计算"><a href="#误差计算" class="headerlink" title="误差计算"></a>误差计算</h2><p>在 PyTorch 中定义误差时，比较优雅的做法是定义一个<code>torch.autograd.Function</code>。但是这样做比较麻烦，需要手写反向传播。由于本文中新介绍的误差全部都是基于MSE均方误差的，我们可以基于<code>torch.nn.Module</code>编写一些“虚假的”误差函数。</p>
<p>首先，编写内容误差：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContentLoss</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, target: torch.Tensor</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.target = target.detach()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        self.loss = F.mse_loss(<span class="built_in">input</span>, self.target)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">input</span></span><br></pre></td></tr></table></figure><br>在神经网络中，这个类其实没有做任何运算（<code>forward</code>直接把<code>input</code>返回了）。但是，这个类缓存了内容误差值。我们稍后可以取出这个类实例的<code>loss</code>，丢进最终的误差计算公式里。这种通过插入一个不进行计算的<code>torch.nn.Module</code>来保存中间计算结果的方法，算是使用PyTorch的一个小技巧。</p>
<p>之后，编写<code>gram</code>矩阵的计算方法及风格误差的计算“函数”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gram</span>(<span class="params">x: torch.Tensor</span>):</span></span><br><span class="line">    <span class="comment"># x is a [n, c, h, w] array</span></span><br><span class="line">    n, c, h, w = x.shape</span><br><span class="line"></span><br><span class="line">    features = x.reshape(n * c, h * w)</span><br><span class="line">    features = torch.mm(features, features.T) / n / c / h / w</span><br><span class="line">    <span class="keyword">return</span> features</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StyleLoss</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, target: torch.Tensor</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.target = gram(target.detach()).detach()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        G = gram(<span class="built_in">input</span>)</span><br><span class="line">        self.loss = F.mse_loss(G, self.target)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">input</span></span><br></pre></td></tr></table></figure>
<p>这里实现风格误差的思路与内容误差同理。</p>
<h2 id="获取预训练模型"><a href="#获取预训练模型" class="headerlink" title="获取预训练模型"></a>获取预训练模型</h2><p>VGG模型对输入数据的分布有要求（即对输入数据均值、标准差有要求）。为了方便起见，我们可以写一个归一化分布的层，作为最终模型的第一层：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Normalization</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, mean, std</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.mean = torch.tensor(mean).to(device).reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        self.std = torch.tensor(std).to(device).reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, img</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (img - self.mean) / self.std</span><br></pre></td></tr></table></figure>
<p>接下来，我们可以利用torchvision中的预训练VGG，提取出其中我们需要的模块。我们还需要获取刚刚编写的误差类的实例的引用，以计算最终的误差。</p>
<p>这段代码的实现思路是：我们不直接把VGG拿过来用，而是新建一个用<code>torch.nn.Sequential</code>表示的序列模型。我们先把标准化层加入这个序列，再把原VGG中的计算层逐个加入我们的新序列模型中。一旦我们发现某个计算层的计算结果要用作计算误差，我们就在这个层后面加一个用于捕获误差的误差模块。</p>
<p>整段逻辑用文字难以说清，大家可以直接看代码理解：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">default_content_layers = [<span class="string">&#x27;conv_4&#x27;</span>]</span><br><span class="line">default_style_layers = [<span class="string">&#x27;conv_1&#x27;</span>, <span class="string">&#x27;conv_2&#x27;</span>, <span class="string">&#x27;conv_3&#x27;</span>, <span class="string">&#x27;conv_4&#x27;</span>, <span class="string">&#x27;conv_5&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model_and_losses</span>(<span class="params">content_img, style_img, content_layers, style_layers</span>):</span></span><br><span class="line">    num_loss = <span class="number">0</span></span><br><span class="line">    expected_num_loss = <span class="built_in">len</span>(content_layers) + <span class="built_in">len</span>(style_layers)</span><br><span class="line">    content_losses = []</span><br><span class="line">    style_losses = []</span><br><span class="line"></span><br><span class="line">    model = torch.nn.Sequential(</span><br><span class="line">        Normalization([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]))</span><br><span class="line">    cnn = models.vgg19(pretrained=<span class="literal">True</span>).features.to(device).<span class="built_in">eval</span>()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> layer <span class="keyword">in</span> cnn.children():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(layer, torch.nn.Conv2d):</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            name = <span class="string">f&#x27;conv_<span class="subst">&#123;i&#125;</span>&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(layer, torch.nn.ReLU):</span><br><span class="line">            name = <span class="string">f&#x27;relu_<span class="subst">&#123;i&#125;</span>&#x27;</span></span><br><span class="line">            layer = torch.nn.ReLU(inplace=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(layer, torch.nn.MaxPool2d):</span><br><span class="line">            name = <span class="string">f&#x27;pool_<span class="subst">&#123;i&#125;</span>&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(layer, torch.nn.BatchNorm2d):</span><br><span class="line">            name = <span class="string">f&#x27;bn_<span class="subst">&#123;i&#125;</span>&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">f&#x27;Unrecognized layer: <span class="subst">&#123;layer.__class__.__name__&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        model.add_module(name, layer)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> content_layers:</span><br><span class="line">            <span class="comment"># add content loss:</span></span><br><span class="line">            target = model(content_img)</span><br><span class="line">            content_loss = ContentLoss(target)</span><br><span class="line">            model.add_module(<span class="string">f&#x27;content_loss_<span class="subst">&#123;i&#125;</span>&#x27;</span>, content_loss)</span><br><span class="line">            content_losses.append(content_loss)</span><br><span class="line">            num_loss += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> style_layers:</span><br><span class="line">            target_feature = model(style_img)</span><br><span class="line">            style_loss = StyleLoss(target_feature)</span><br><span class="line">            model.add_module(<span class="string">f&#x27;style_loss_<span class="subst">&#123;i&#125;</span>&#x27;</span>, style_loss)</span><br><span class="line">            style_losses.append(style_loss)</span><br><span class="line">            num_loss += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> num_loss &gt;= expected_num_loss:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model, content_losses, style_losses</span><br></pre></td></tr></table></figure><br>这里有些地方要注意：VGG有多个模块，其中我们只需要包含卷积层的<code>vgg19().features</code>模块。另外，我们只需要那些用于计算误差的层，当我们发现所有和误差相关的层都放入了新模型后，就可以停止新建模块了。</p>
<h2 id="用梯度下降生成图像"><a href="#用梯度下降生成图像" class="headerlink" title="用梯度下降生成图像"></a>用梯度下降生成图像</h2><p>这里的步骤和正文中的类似，我们先准备好输入的噪声图像、模型、误差类实例的引用，并设置好哪些参数需要优化，哪些不需要。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input_img = torch.randn(<span class="number">1</span>, <span class="number">3</span>, *img_size, device=device)</span><br><span class="line">model, content_losses, style_losses = get_model_and_losses(</span><br><span class="line">    content_img, style_img, default_content_layers, default_style_layers)</span><br><span class="line"></span><br><span class="line">input_img.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">model.requires_grad_(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>之后，我们声明好用到的超参数。这两个超参数能够控制图像是更靠近内容图像还是风格图像。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">style_img = read_image(<span class="string">&#x27;dldemos/StyleTransfer/picasso.jpg&#x27;</span>)</span><br><span class="line">content_img = read_image(<span class="string">&#x27;dldemos/StyleTransfer/dancing.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>这两张图片来自官方教程。链接分别为<a target="_blank" rel="noopener" href="https://pytorch.org/tutorials/_static/img/neural-style/picasso.jpg">picasso</a>, <a target="_blank" rel="noopener" href="https://pytorch.org/tutorials/_static/img/neural-style/dancing.jpg">dancing</a>。</p>
<p>最后，执行熟悉的梯度下降即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">optimizer = optim.LBFGS([input_img])</span><br><span class="line">steps = <span class="number">0</span></span><br><span class="line">prev_loss = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> steps &lt;= <span class="number">1000</span> <span class="keyword">and</span> prev_loss &lt; <span class="number">100</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closure</span>():</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            input_img.clamp_(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">global</span> steps</span><br><span class="line">        <span class="keyword">global</span> prev_loss</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        model(input_img)</span><br><span class="line">        content_loss = <span class="number">0</span></span><br><span class="line">        style_loss = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> content_losses:</span><br><span class="line">            content_loss += l.loss</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> style_losses:</span><br><span class="line">            style_loss += l.loss</span><br><span class="line">        loss = content_weight * content_loss + style_weight * style_loss</span><br><span class="line">        loss.backward()</span><br><span class="line">        steps += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> steps % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Step <span class="subst">&#123;steps&#125;</span>:&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Loss: <span class="subst">&#123;loss&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="comment"># Open next line to save intermediate result</span></span><br><span class="line">            <span class="comment"># save_image(input_img, f&#x27;work_dirs/output_&#123;steps&#125;.jpg&#x27;)</span></span><br><span class="line">        prev_loss = loss</span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line">    optimizer.step(closure)</span><br></pre></td></tr></table></figure>
<p>由于我们有先验知识，知道图像位于(0, 1)之间，每一轮优化前我们可以手动约束一下图像的数值以加速训练。</p>
<p>运行程序的时候会有一些特殊情况。有些时候，任务的误差<code>loss</code>会突然涨到一个很高的值，过几轮才会恢复正常。为了保证输出的<code>loss</code>总是不那么大，我加了一个<code>prev_loss &lt; 100</code>的要求。</p>
<p>这里<code>steps</code>的值是可以调的，误差究竟多小才算小也取决于实际任务以及<code>content_weight, style_weight</code>的大小。这些超参数都是可以去调试的。</p>
<p>最后，我们可以保存最终输出的图像:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    input_img.clamp_(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">save_image(input_img, <span class="string">&#x27;work_dirs/output.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>正常情况下，运行上面这些的代码，可以得到下面的运行结果（我的<code>style_weight/content_weight=1e6</code>)</p>
<p><img src="/2022/06/01/20220531-styletransfer/10.jpg" alt></p>
<h1 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h1><p>在理解了风格迁移是在做什么后，我就立刻想到：可不可以用风格迁移，把照片渲染成二次元风格呢？</p>
<p>成功完成代码实现后，我立马尝试把动漫风格迁移到我的照片上：</p>
<p><img src="/2022/06/01/20220531-styletransfer/11.jpg" alt></p>
<p>这效果也太差了吧？！我不服气，多输出了几幅中间结果。这下好了，结果更诡异了：</p>
<p><img src="/2022/06/01/20220531-styletransfer/12.jpg" alt></p>
<p>我都搞不清楚，这是进入了二次元，还是进入了显像管电视机。</p>
<p>可以看出，这种算法生成出来的二次元图像，还是保留了二次元图片中的一些风格：线条分明，颜色是一块一块的。但是整体效果太差了。</p>
<p>只能说，这种算法的局限性还是太强了。想进入二次元，任重而道远啊。</p>
<h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>我的智力和效率已经到达了一个可怕的地步。一天时间内，我在正常生活的同时，完成了论文阅读、复现、写文章、吹牛。这种执行能力太强了。如果我每天以这样的效率学东西，成为科研大牛指日可待。</p>
<p>可惜，搞科研并不是我的归宿。其实写这篇文章的时候，我也在想是什么东西在支持我一直做下去。写文章对现在的我来说是没有任何收益的。想高效获取金钱上的收益，也不该写这种类型的文章。但是我就是想写。不知道究竟是为了完成我的一些个人目标，还是为了向他人展示我修炼多年的表达能力、学习能力，还是纯粹以吹牛为乐。我已经搞不太清楚了。只要觉得好玩，就一直做下去吧。</p>
<p>最近，我玩视频游戏的时间越来越少了。因为，生活，对我来说，就是一场最具难度、最有挑战性的游戏。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/05/30/DLS-note-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/30/DLS-note-4/" class="post-title-link" itemprop="url">吴恩达《深度学习专项》笔记+代码实战（四）：深层神经网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-30 19:30:24" itemprop="dateCreated datePublished" datetime="2022-05-30T19:30:24+08:00">2022-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>体验完了“浅度”神经网络后，我们终于等到了这门课的正题——深度神经网络了。</p>
<p>其实这节课并没有引入太多新的知识，只是把上节课的2层网络拓展成了L层网络。对于编程能力强的同学（或者认真研究了我上节课的编程实战代码的同学，嘿嘿嘿），学完了上节课的内容后，就已经有能力完成这节课的作业了。</p>
<h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="深度神经网络概述与符号标记"><a href="#深度神经网络概述与符号标记" class="headerlink" title="深度神经网络概述与符号标记"></a>深度神经网络概述与符号标记</h2><p><img src="/2022/05/30/DLS-note-4/1.jpg" alt></p>
<p>所谓<strong>深度</strong>神经网络，只是神经网络的隐藏层数量比较多而已，它的本质结构和前两课中的神经网络是一样的。让我们再复习一下神经网络中的标记：</p>
<p><img src="/2022/05/30/DLS-note-4/2.jpg" alt></p>
<p>$L$表示网络的层数。</p>
<blockquote>
<p>在这个网络中，$L=4$。（注意：输入层并不计入层数，但可以用第“0”层称呼输入层）</p>
</blockquote>
<p>上标中括号的标号$l (l \in [0, L])$表示和第$l$层相关的数据。比如, $n^{[l]}$是神经网络第$l$层的神经元数（即每层输出向量的长度）。</p>
<blockquote>
<p>这幅图里 $n^{[1]}=5$, $n^{[3]}=3$，以此类推。值得注意的是，$n^{[0]}=n_x=3$。回想第二课的知识，$n_x$是输入向量的长度。</p>
</blockquote>
<p>再比如，$a^{[l]}$是第$l$层的输出向量。$a^{[l]}=g^{[l]}(z^{[l]})$，其中$g^{[l]}$是第$l$层的激活函数，$z^{[l]}$是第$l$层的中间运算结果。$W[l], b[l]$是第$l$层的参数。</p>
<p>和上节课的单隐层神经网络类似，对于$L$层的网络，我们如下方法对<strong>单样本</strong>做前向传播（推理）：</p>
<script type="math/tex; mode=display">
\begin{align*}
a^{[l]} & \gets g^{[l]}(W^{[l]}a^{[l - 1]}+b^{[l]}) \\

for \ l & \in [1, 2, ... L]
\end{align*}</script><p>其中，输入输出分别为：$x=a^{[0]}, \hat{y}=a^{[L]}$。</p>
<p>当我们考虑全体样本$X, Y$时，上面的算式可以写成：</p>
<script type="math/tex; mode=display">
\begin{align*}
A^{[l]} & \gets g^{[l]}(W^{[l]}A^{[l - 1]}+b^{[l]}) \\

for \ l & \in [1, 2, ... L]
\end{align*}</script><p>其中，输入输出分别为：$X=A^{[0]}, \hat{Y}=A^{[L]}$。</p>
<blockquote>
<p>从公式上看，使用向量化计算全体样本只是把小写字母换成了大写字母而已。用代码实现时，我们甚至也只需要照搬上述公式就行。但我们要记住，全体样本是把每个样本以列向量的形式横向堆叠起来，堆成了一个矩阵。我们心中对$X, Y$的矩阵形状要有数。</p>
<p>在实现深度神经网络时，我们不可避免地引入了一个新的for循环：循环遍历网络的每一层。这个for循环是无法消除的。要记住，我们要消除的for循环，只有向量化计算中的for循环。它们之所以能被消除，是因为向量化计算可以使用并行加速，而不是for循环本身有问题。我们甚至可以把“向量化加法”、“向量化乘法”这些运算视为最小的运算单元。而在写其他代码时，不用刻意去规避for循环。</p>
</blockquote>
<p>参数矩阵的形状是：$W^{[l]}: (n^{[l]} , n^{[l-1]}), b^{[l]} : (n^{[l]} , 1)$</p>
<p>每一层的输入输出矩阵形状是：$A^{[l]} : (n^{[l]} , m)$</p>
<blockquote>
<p>如果忘了$W$的形状，就拿矩阵乘法形状规则$(a , b) \cdot (b , c)=(a , c)$推一下。</p>
</blockquote>
<p>某张量的梯度张量与其形状相同。比如$dW$的形状也是$(n^{[l]} , n^{[l-1]})$。</p>
<h2 id="为什么用更深的网络"><a href="#为什么用更深的网络" class="headerlink" title="为什么用更深的网络"></a>为什么用更深的网络</h2><p><img src="/2022/05/30/DLS-note-4/3.jpg" alt></p>
<p>这里给出一种不严谨、出于直觉的解释：网络中越靠前的层，捕捉的信息越初级；越深的层，捕捉的信息越高级。比如对于上图所示的人脸检测网络，网络的第一层可能识别的是图片的边缘，第二层识别的是人的五官，第三层识别的是整个人脸。更深的网络有助于捕捉更高层次的特征。</p>
<p>另外，从计算复杂度的角度来看，用更深的网络，而不是在同一层网络里叠加更多神经元，往往能更轻易地拟合出一个函数。比如要拟合函数a+b+c+d，我们可以先算(a+b)和(c+d)，再算(a+b)+(c+d)。这只需要2“层”计算。如果把上面4个数相加变成$n$个数相加，我们只需要构造$logn$层网络。但如果用单层网络拟合$n$个数相加，网络可能要尝试尝试$a, b, a+b, c, a+b+c, …$这一共$O(2^n)$种公式，需要在1层里放$O(2^n)$个神经元。</p>
<blockquote>
<p>这一章反正不是严谨的科学证明，内容听听就好。深度神经网络好不好用，究竟用多少层的网络，这些决定都取决于实际的问题。只不过大多数任务用深度神经网络实现都能生效。</p>
</blockquote>
<h2 id="深度神经网络的训练流程"><a href="#深度神经网络的训练流程" class="headerlink" title="深度神经网络的训练流程"></a>深度神经网络的训练流程</h2><p>前两节课，我们的网络只有1层或2层。我们或许可以直接写出它们的训练步骤。现在，对于$L$层的网络，我们必须系统化地写出它们的训练流程。</p>
<p>首先是前向传播；</p>
<script type="math/tex; mode=display">
\begin{align*}
A^{[0]} & = X \\
A^{[1]} & \gets g^{[1]}(Z^{[1]})=g^{[1]}(W^{[1]}A^{[0]}+b^{[1]}) \\
... & \\
A^{[l]} & \gets g^{[l]}(Z^{[l]})=g^{[l]}(W^{[l]}A^{[l - 1]}+b^{[l]})
\end{align*}</script><p>在前向传播时，我们要缓存(cache)一些临时变量，以辅助反向传播：</p>
<script type="math/tex; mode=display">
\begin{align*}
A^{[0]} &  = X \\
A^{[1]} & \gets g^{[1]}(Z^{[1]}) \ cache \ A^{[1]}, Z^{[1]},W^{[1]}, b^{[1]}  \\
... & \\
A^{[l]} & \gets g^{[l]}(Z^{[l]}) \ cache \ A^{[l]}, Z^{[l]},W^{[l]}, b^{[l]} 
\end{align*}</script><p>反向传播则按下面的步骤计算（注意观察被缓存的变量是怎么使用的）：</p>
<script type="math/tex; mode=display">
\begin{align*}
dA^{[L]} &  =  -\frac{y}{a} + \frac{1 - y}{1 - a} \\
... & \\
dZ^{[l]} & \gets dA^{[l]} \ast g^{[l]'}(Z^{[l]}) &use \  Z^{[l]} \\
dW^{[l]} & \gets \frac{1}{m}dZ^{[l]} A^{[l-1]T} &use \  A^{[l]} \\
db^{[l]} & \gets np.mean(dZ^{[l]}, axis=1, keepdims=True) \\
update & \ W^{[l]}, b^{[l]} &use \ W^{[l]}, b^{[l]}\\ 
dA^{[l-1]} & \gets W^{[l]T}dZ^{[l]} &use \ W^{[l]} \\
...
\end{align*}</script><p>上面的公式里，默认损失函数$L(a, y) = -(y \ loga + (1-y) \ log(1-a))$</p>
<blockquote>
<p>记不住公式没关系，编程的时候对着翻译就行。</p>
<p>从算法的角度来看，梯度下降法只需要用反向传播算法。我们这里之所以做一遍正向传播，是因为反向传播要用到正向传播的中间运算结果。从逻辑关系来看，是反向传播函数调用了正向传播函数，而不是“先正向传播，再反向传播”的并列关系，虽然编程时是用后者来表达。</p>
</blockquote>
<h2 id="参数与超参数"><a href="#参数与超参数" class="headerlink" title="参数与超参数"></a>参数与超参数</h2><p>之前，我们在不经意间就已经接触了“超参数”这个词，但一直没有对它下一个定义。现在，我们来正式介绍超参数这个概念，以及它和参数的关系。</p>
<p>对于我们之前的神经网络，参数包括：</p>
<ul>
<li>$W$</li>
<li>$b$</li>
</ul>
<p>这些参数和数学里的参数意义一样，表示函数的参数。</p>
<p>而超参数则包括：</p>
<ul>
<li>学习率 $\alpha$</li>
<li>训练迭代次数</li>
<li>网络层数 $L$</li>
</ul>
<p>我们直接从超参数的作用来给超参数下定义。超参数的取值会决定参数$W, b$的取值，它们往往只参与训练，而不参与最后的推理计算。可以说，除了网络中要<strong>学习</strong>的参数外，网络中剩下的可以变动的数值，都是超参数。</p>
<p>一个简单区别超参数的方法是：超参数一般是我们手动调的。我们常说“调参”，说的是超参数。</p>
<p>吴恩达老师鼓励我们多尝试调参，对于不同的问题可以尝试不同的超参数。</p>
<h2 id="神经网络与大脑"><a href="#神经网络与大脑" class="headerlink" title="神经网络与大脑"></a>神经网络与大脑</h2><p>生物的神经由“树突”，“轴突”等部分组成。生物信号会通过这些部分在神经里传播。神经网络的工作原理和生物神经的原理<strong>有那么一点类似</strong>。</p>
<p>但迄今为止，生物神经的原理还没有被破解。我们把神经网络当成一个$x \to y$的映射就好了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一课主要是介绍编程实现的思路，没有过多的知识点：</p>
<ul>
<li>实现任意层数的神经网络<ul>
<li>前向传播</li>
<li>反向传播</li>
<li>缓存信息</li>
</ul>
</li>
<li>为什么用更深的网络</li>
<li>分辨超参数与参数</li>
</ul>
<p>如果大家对神经网络的前向传播或反向传播还有问题，欢迎去回顾上一篇笔记：<a href="https://zhouyifan.net/2022/05/23/DLS-note-3/。">https://zhouyifan.net/2022/05/23/DLS-note-3/。</a></p>
<h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><p>说实话，这堂课的编程作业只能称为“体验写代码的感觉”，不能堂堂正正地称为“写程序”。整个框架都搭好了，每行输入输出的变量都给好了，只要填一填函数调用就行了。这样编程实在是不好玩，没有难度，学不到东西。</p>
<p>所以，是时候自己动手写代码了！</p>
<p>两周前，使用逻辑回归做小猫分类并不成功。看看这周换了“深度”神经网络后，我们能不能在小猫分类上取得更好的成绩。</p>
<h2 id="通用分类器类"><a href="#通用分类器类" class="headerlink" title="通用分类器类"></a>通用分类器类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRegressionModel</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X: np.ndarray, train_mode=<span class="literal">True</span></span>) -&gt; np.ndarray:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">self, Y: np.ndarray</span>) -&gt; np.ndarray:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span>(<span class="params">self, learning_rate: <span class="built_in">float</span></span>) -&gt; np.ndarray:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self, filename: <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, filename: <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">self, Y: np.ndarray, Y_hat: np.ndarray</span>) -&gt; np.ndarray:</span></span><br><span class="line">        <span class="keyword">return</span> np.mean(-(Y * np.log(Y_hat) + (<span class="number">1</span> - Y) * np.log(<span class="number">1</span> - Y_hat)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span>(<span class="params">self, X: np.ndarray, Y: np.ndarray, return_loss=<span class="literal">False</span></span>):</span></span><br><span class="line">        Y_hat = self.forward(X, train_mode=<span class="literal">False</span>)</span><br><span class="line">        Y_hat_predict = np.where(Y_hat &gt; <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        accuracy = np.mean(np.where(Y_hat_predict == Y, <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">if</span> return_loss:</span><br><span class="line">            loss = self.loss(Y, Y_hat)</span><br><span class="line">            <span class="keyword">return</span> accuracy, loss</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> accuracy</span><br></pre></td></tr></table></figure>
<p>这次我们还是用基于这个通用分类器类编写代码。相比上篇笔记中的代码，这个类有以下改动：</p>
<ul>
<li>由于这次模型要训练很久，我给模型加入了<code>save</code>,<code>load</code>用于保存和读取模型。</li>
<li><code>evaluate</code> 不再直接输出结果，而是返回一些评测结果，供调用其的函数使用。注意，这次我们不仅算了测试集上的准确率，还算了<strong>测试集上的损失函数</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">model: BaseRegressionModel,</span></span></span><br><span class="line"><span class="params"><span class="function">          X,</span></span></span><br><span class="line"><span class="params"><span class="function">          Y,</span></span></span><br><span class="line"><span class="params"><span class="function">          step,</span></span></span><br><span class="line"><span class="params"><span class="function">          learning_rate,</span></span></span><br><span class="line"><span class="params"><span class="function">          print_interval=<span class="number">100</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          test_X=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          test_Y=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(step):</span><br><span class="line">        Y_hat = model.forward(X)</span><br><span class="line">        model.backward(Y)</span><br><span class="line">        model.gradient_descent(learning_rate)</span><br><span class="line">        <span class="keyword">if</span> s % print_interval == <span class="number">0</span>:</span><br><span class="line">            loss = model.loss(Y, Y_hat)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Step: <span class="subst">&#123;s&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Train loss: <span class="subst">&#123;loss&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> test_X <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> test_Y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                accuracy, loss = model.evaluate(test_X,</span><br><span class="line">                                                test_Y,</span><br><span class="line">                                                return_loss=<span class="literal">True</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Test loss: <span class="subst">&#123;loss&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Test accuracy: <span class="subst">&#123;accuracy&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>模型训练的代码和上篇笔记中的也几乎完全相同，只是多输出了一点调试信息。</p>
<h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h2><p>这次我们希望能够更灵活地使用激活函数。因此，我编写了两个根据字符串获取激活函数、激活函数梯度的函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_activation_func</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&#x27;sigmoid&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> sigmoid</span><br><span class="line">    <span class="keyword">elif</span> name == <span class="string">&#x27;relu&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> relu</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> KeyError(<span class="string">f&#x27;No such activavtion function <span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_activation_de_func</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&#x27;sigmoid&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> sigmoid_de</span><br><span class="line">    <span class="keyword">elif</span> name == <span class="string">&#x27;relu&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> relu_de</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> KeyError(<span class="string">f&#x27;No such activavtion function <span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="实现任意层数的神经网络"><a href="#实现任意层数的神经网络" class="headerlink" title="实现任意层数的神经网络"></a>实现任意层数的神经网络</h2><p>上篇笔记中，我们实现了一个单隐层的神经网络。而这周，我们要实现一个更加通用的神经网络。这个神经网络的层数、每层的神经元数、激活函数都可以修改。还是照着上次的思路，让我们看看这个子类的每个方法是怎么实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepNetwork</span>(<span class="params">BaseRegressionModel</span>):</span></span><br></pre></td></tr></table></figure>
<h3 id="模型初始化"><a href="#模型初始化" class="headerlink" title="模型初始化"></a>模型初始化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, neuron_cnt: <span class="type">List</span>[<span class="built_in">int</span>], activation_func: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(neuron_cnt) - <span class="number">1</span> == <span class="built_in">len</span>(activation_func)</span><br><span class="line">    self.num_layer = <span class="built_in">len</span>(neuron_cnt) - <span class="number">1</span></span><br><span class="line">    self.neuron_cnt = neuron_cnt</span><br><span class="line">    self.activation_func = activation_func</span><br><span class="line">    self.W: <span class="type">List</span>[np.ndarray] = []</span><br><span class="line">    self.b: <span class="type">List</span>[np.ndarray] = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">        self.W.append(</span><br><span class="line">            np.random.randn(neuron_cnt[i + <span class="number">1</span>], neuron_cnt[i]) * <span class="number">0.2</span>)</span><br><span class="line">        self.b.append(np.zeros((neuron_cnt[i + <span class="number">1</span>], <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
<p>我们要在模型初始化时确定模型的结构，因此我们需要刚刚提到的<strong>神经网络的层数、每层的神经元数、激活函数</strong>这三个信息。在初始化函数中，我们只需要传入每层神经元数的列表、激活函数名的列表即可，神经网络的层数可以通过列表长度来获取。</p>
<p>注意，在构建神经网络时，我们不仅要设置每一层的神经元数，还需要设置输入层的向量长度（回忆一下，输入层虽然不计入网络的层数，但我们还需要根据输入的向量长度设置参数矩阵W的形状）。因此，神经元数列表比激活函数名列表多了一个元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(neuron_cnt) - <span class="number">1</span> == <span class="built_in">len</span>(activation_func)</span><br></pre></td></tr></table></figure></p>
<p>获取了构建模型所需信息（超参数）后，我们按照公式，根据这些信息初始化模型的参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">    self.W.append(</span><br><span class="line">        np.random.randn(neuron_cnt[i + <span class="number">1</span>], neuron_cnt[i]) * <span class="number">0.2</span>)</span><br><span class="line">    self.b.append(np.zeros((neuron_cnt[i + <span class="number">1</span>], <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
<p>别忘了，我们要随机初始化<code>W</code>，且令<code>W</code>为一个较小的值。这里我随便取了个0.2。后面的课程会介绍这个值该怎么设置。</p>
<p>此外，我们还要先准备好缓存的列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.Z_cache = [<span class="literal">None</span>] * self.num_layer</span><br><span class="line">self.A_cache = [<span class="literal">None</span>] * (self.num_layer + <span class="number">1</span>)</span><br><span class="line">self.dW_cache = [<span class="literal">None</span>] * self.num_layer</span><br><span class="line">self.db_cache = [<span class="literal">None</span>] * self.num_layer</span><br></pre></td></tr></table></figure><br>由于输入层(<code>A0</code>)的信息也要保留，因此<code>A_cache</code>的长度要多1。</p>
<h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><p>回忆这节课提到的前向传播公式：</p>
<script type="math/tex; mode=display">
A^{[l]} \gets g^{[l]}(Z^{[l]})=g^{[l]}(W^{[l]}A^{[l - 1]}+b^{[l]}) \\ \ cache \ A^{[l]}, Z^{[l]},W^{[l]}, b^{[l]}</script><p>我们只需要按照公式做运算并缓存变量即可（下标和公式不完全对应）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, train_mode=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> train_mode:</span><br><span class="line">        self.m = X.shape[<span class="number">1</span>]</span><br><span class="line">    A = X</span><br><span class="line">    self.A_cache[<span class="number">0</span>] = A</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">        Z = np.dot(self.W[i], A) + self.b[i]</span><br><span class="line">        A = get_activation_func(self.activation_func[i])(Z)</span><br><span class="line">        <span class="keyword">if</span> train_mode:</span><br><span class="line">            self.Z_cache[i] = Z</span><br><span class="line">            self.A_cache[i + <span class="number">1</span>] = A</span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<p>注意，虽然公式里写了要缓存模型参数<code>W, b</code>，但实际上在代码实现时，模型参数本来就是类的成员属性，不需要额外去缓存它们。</p>
<h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>同样，按照公式翻译反向传播即可：</p>
<script type="math/tex; mode=display">
\begin{align*}
dA^{[L]} &  =  -\frac{y}{a} + \frac{1 - y}{1 - a} \\
... & \\
dZ^{[l]} & \gets dA^{[l]} \ast g^{[l]'}(Z^{[l]}) &use \  Z^{[l]} \\
dW^{[l]} & \gets \frac{1}{m}dZ^{[l]} A^{[l-1]T} &use \  A^{[l]} \\
db^{[l]} & \gets np.mean(dZ^{[l]}, axis=1, keepdims=True) \\
dA^{[l-1]} & \gets W^{[l]T}dZ^{[l]} &use \ W^{[l]} \\
...
\end{align*}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">self, Y</span>):</span></span><br><span class="line">    dA = -Y / self.A_cache[-<span class="number">1</span>] + (<span class="number">1</span> - Y) / (<span class="number">1</span> - self.A_cache[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">assert</span> (self.m == Y.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        dZ = dA * get_activation_de_func(self.activation_func[i])(</span><br><span class="line">            self.Z_cache[i])</span><br><span class="line">        dW = np.dot(dZ, self.A_cache[i].T) / self.m</span><br><span class="line">        db = np.mean(dZ, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">        dA = np.dot(self.W[i].T, dZ)</span><br><span class="line">        self.dW_cache[i] = dW</span><br><span class="line">        self.db_cache[i] = db</span><br></pre></td></tr></table></figure>
<p>这里除了第一个<code>dA</code>要由误差函数的导数单独算出来外，其他的梯度直接照着公式算就可以了。由于我们把反向传播和更新参数分成了两步，这里额外缓存了<code>dW, db</code>的值。</p>
<h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>这次，梯度下降需要循环对所有参数进行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span>(<span class="params">self, learning_rate</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layer):</span><br><span class="line">        self.W[i] -= learning_rate * self.dW_cache[i]</span><br><span class="line">        self.b[i] -= learning_rate * self.db_cache[i]</span><br></pre></td></tr></table></figure>
<h3 id="存取模型"><a href="#存取模型" class="headerlink" title="存取模型"></a>存取模型</h3><p>在介绍存取模型的函数之前，我们要认识两个新的numpy API。</p>
<p>第一个API是<code>np.savez(filename, a_name=a, b_name=b, ...)</code>。它可以把<code>ndarray</code>类型的数据<code>a, b, ...</code>以键值对的形式记录进一个<code>.npz</code>文件中，其中键值对的键是数据的名称，值是数据的值。</p>
<p>第二个API是<code>np.load(filename)</code>。它可以从<code>.npz</code>里读取出一个词典。词典中存储的键值对就是我们刚刚保存的键值对。</p>
<p>比如，我们可以用如下方法存取<code>W, b</code>两个<code>ndarray</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">W = np.zeros((<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">b = np.zeros((<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">np.savez(<span class="string">&#x27;a.npz&#x27;</span>, W=W, b=b)</span><br><span class="line">params = np.load(<span class="string">&#x27;a.npz&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> W == params[<span class="string">&#x27;W&#x27;</span>]</span><br><span class="line"><span class="keyword">assert</span> b == params[<span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>学会了这两个API的用法后，我们来看看该怎么存取神经网络的参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">self, filename: <span class="built_in">str</span></span>):</span></span><br><span class="line">    save_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.W)):</span><br><span class="line">        save_dict[<span class="string">&#x27;W&#x27;</span> + <span class="built_in">str</span>(i)] = self.W[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.b)):</span><br><span class="line">        save_dict[<span class="string">&#x27;b&#x27;</span> + <span class="built_in">str</span>(i)] = self.b[i]</span><br><span class="line">    np.savez(filename, **save_dict)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">self, filename: <span class="built_in">str</span></span>):</span></span><br><span class="line">    params = np.load(filename)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.W)):</span><br><span class="line">        self.W[i] = params[<span class="string">&#x27;W&#x27;</span> + <span class="built_in">str</span>(i)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.b)):</span><br><span class="line">        self.b[i] = params[<span class="string">&#x27;b&#x27;</span> + <span class="built_in">str</span>(i)]</span><br></pre></td></tr></table></figure>
<p>和刚刚介绍的用法一样，这里我们要给神经网络中每一个参数取一个独一无二的名字，再把所有名字和值合并成键值对。保存和读取，就是对键值对的写和读。</p>
<p>这里我使用了<code>**save_dict</code>这种传参方式。在Python中，<code>func(**dict)</code>的作用是把一个词典的值当作函数的键值对参数。比如我要写<code>func(a=a, b=b)</code>，我可以定义一个词典<code>d=&#123;&#39;a&#39;:a, &#39;b&#39;:b&#125;</code>，再用<code>func(**d)</code>把词典传入函数的键值对参数。</p>
<h2 id="小猫分类器"><a href="#小猫分类器" class="headerlink" title="小猫分类器"></a>小猫分类器</h2><p>这次，我们还是使用和第二篇笔记中相同的猫狗数据集，作为这次任务的训练集和测试集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    train_X, train_Y, test_X, test_Y = get_cat_set(</span><br><span class="line">        <span class="string">&#x27;dldemos/LogisticRegression/data/archive/dataset&#x27;</span>, train_size=<span class="number">1500</span>)</span><br><span class="line">    <span class="comment"># train_X: [n_x, m]</span></span><br><span class="line">    <span class="comment"># train_Y: [1, m]</span></span><br></pre></td></tr></table></figure>
<p>这次我直接在<code>get_cat_set</code>函数里把输入数据的形状调好了，总算不用在main函数看乱糟糟的代码了。</p>
<p>之后，我们根据输入的向量长度，初始化一个较深的神经网络：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n_x = train_X.shape[<span class="number">0</span>]</span><br><span class="line">model = DeepNetwork([n_x, <span class="number">30</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">1</span>],</span><br><span class="line">                    [<span class="string">&#x27;relu&#x27;</span>, <span class="string">&#x27;relu&#x27;</span>, <span class="string">&#x27;relu&#x27;</span>, <span class="string">&#x27;relu&#x27;</span>, <span class="string">&#x27;sigmoid&#x27;</span>])</span><br></pre></td></tr></table></figure><br>如这段代码所示，我创建了一个有4个隐藏层的神经网络，其中隐藏层的通道数分别为<code>30, 30, 20, 20</code>。除了最后一层用<code>sigmoid</code>以外，每一层都用<code>relu</code>作为激活函数。</p>
<p>初始化完模型后，我们可以开始训练模型了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">model.load(<span class="string">&#x27;work_dirs/model.npz&#x27;</span>)</span><br><span class="line">train(model,</span><br><span class="line">      train_X,</span><br><span class="line">      train_Y,</span><br><span class="line">      <span class="number">500</span>,</span><br><span class="line">      learning_rate=<span class="number">0.01</span>,</span><br><span class="line">      print_interval=<span class="number">10</span>,</span><br><span class="line">      test_X=test_X,</span><br><span class="line">      test_Y=test_Y)</span><br><span class="line">model.save(<span class="string">&#x27;work_dirs/model.npz&#x27;</span>)</span><br></pre></td></tr></table></figure><br>其中，模型是否要读取和保存是可以“灵活地”注释掉的。只需要简单地调用<code>train</code>函数，我们的模型就可以训起来了。</p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>本来，写完了代码，讨论实验结果，是一件令人心情愉悦的事情：忙了大半天，总算能看一看自己的成果了。但是，在深度学习项目中，实验其实是最烦人的部分。</p>
<p>如第一课所述，深度学习是一个以实验为主的研究方向，深度学习项目是建立在“实验-开发”这一循环上的。一旦实验效果不佳，你就得去重新调代码。普通的编程项目，你能预计程序有怎样的输出，出了问题你能顺藤摸瓜找到bug。而对于深度学习项目，模型效果不佳，可能是代码有bug，也可能是模型不行。哪怕是知道是模型不行，你也很难确切地知道应该怎么去提升模型。因此，对于深度学习项目，开始实验，仅仅是麻烦的开始。</p>
<p>这不，在开启这周的小猫分类任务实验时，我是满怀期待的：上次用的逻辑回归确实太烂了。这周换了一个这么强大的模型，应该没问题了吧。</p>
<p>结果呢，模型跑了半天，精度还比不过逻辑回归。</p>
<p>我也不好去直接debug啊。我只好对着屏幕大眼瞪小眼，硬生生地用我的人脑编译器去调试代码。</p>
<p>我看了很久，屏幕都快被我眼睛发出的射线射穿了，我还是找不到bug。</p>
<p>我只好断定：这不是代码的问题，是模型或数据的问题。</p>
<p>调了半天超参数后，开始训练。模型用蜗牛般的速度训练了一个小时后，总算达到了 <strong>60.5%</strong> 的准确率。还好，这个模型没有太丢人，总算比之前逻辑回归的 <strong>57.5%</strong> 要高上一点点了。</p>
<p>可又过了半小时，这模型的准确率又只有 <strong>58.5%</strong> 了，准确度就再也上不去了。</p>
<p>这个结果实在是太气人了。相比逻辑回归，这么深的网络竟然只有这么小的提升。</p>
<p>消气后，我冷静地分析了下为什么这个“深度”神经网络的提升这么小：</p>
<ol>
<li>上次逻辑回归使用的测试集太小，结果不准确。模型可能碰巧多猜对了几次。</li>
<li>还有很多训练优化的手段我没有用上。</li>
</ol>
<p>还有一些其他方面的原因。现在所有运算都是在CPU上运行的，速度特别慢。如果放到GPU上运算，模型的训练会快上很多。实验速度快了，就有更多的机会去调试模型的超参数，得到更优的模型。</p>
<p>其实，我已经学完了后面几周的课程，知道该怎么优化神经网络的训练；我也知道该怎么在GPU上训练模型。但是，出于教学的考虑，为了让使用的知识尽可能少，我没有提前去使用一些更高级的优化方法和编程手段。我大概只发挥了一成的模型优化水平，使用GPU后实验速度保守估计提升10倍。这样算来，我现在展示的实力，最多只有真实实力的1%。一旦我稍稍拿出5成实力，这个模型的性能就会有显著提升；一旦我释放所有能量，再去多看几篇论文，使用更加优秀的分类模型，那我的模型在这个数据集上的分类精度就可以登顶全球了。只是这样太张扬了不太好。</p>
<p>这样一想，我也没有必要为这个模型的垃圾性能而生气。后面还有的是改进的机会。希望在后面的编程实战中，我们能一点一点见证这个分类模型的提升。</p>
<p>代码链接：<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/DeepNetwork">https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/DeepNetwork</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/05/23/DLS-note-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/23/DLS-note-3/" class="post-title-link" itemprop="url">吴恩达《深度学习专项》笔记+代码实战（三）：“浅度”神经网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-23 15:36:34" itemprop="dateCreated datePublished" datetime="2022-05-23T15:36:34+08:00">2022-05-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上节课中，我们学习了逻辑回归——一种经典的学习算法。我兴致勃勃地用它训练了一个猫狗分类模型，结果只得到了57%这么个惨淡的准确率。正好，这周开始学习如何实现更复杂的模型了。这次，我一定要一雪前耻！</p>
<p>开始学这周的课之前，先回忆一下上周我们学习了什么。</p>
<p>对于一个神经网络，我们要定义它的网络结构（一个数学公式），定义损失函数。根据损失函数和网络结构，我们可以对网络的参数求导，并用梯度下降法最小化损失函数。</p>
<p>也就是说，不管是什么神经网络，都由以下几部分组成：</p>
<ul>
<li><strong>网络结构</strong></li>
<li><strong>损失函数</strong></li>
<li><strong>优化策略</strong></li>
</ul>
<p>而在编程实现神经网络时，我们不仅要用计算机语言定义上面这几项内容，还需要<strong>收集数据</strong>、<strong>预处理数据</strong>。</p>
<p>在这堂课中，我们要学一个更复杂的模型，其知识点逃不出上面这些范围。在之后的学习中我们还会看到，浅层神经网络的<strong>损失函数</strong>和<strong>优化策略</strong>和上节课的逻辑回归几乎是一模一样的。我们要关心的，主要是<strong>网络结构</strong>上的变化。</p>
<p>在学习之前，我们可以先有一个心理准备，知道大概要学到哪些东西。</p>
<h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="神经网络概述与符号标记"><a href="#神经网络概述与符号标记" class="headerlink" title="神经网络概述与符号标记"></a>神经网络概述与符号标记</h2><p><img src="/2022/05/23/DLS-note-3/0.jpg" alt></p>
<p>上节课我们使用的逻辑回归过于简单，它只能被视为只有一个神经元（计算单元）的神经网络。如上图第一行所示。</p>
<p>一般情况下，神经网络都是由许多神经元组成的。我们把一次性计算的神经元都算作“一层”。比如上图第二行的网络有两层，第一层有3个神经元，第二层有1个神经元。</p>
<p>上节课中，对于一个样本$x$，一层的神经网络是用下面的公式计算的：</p>
<script type="math/tex; mode=display">
\hat{y}=a=\sigma(w^Tx+b)</script><p>而这节课将使用的两层神经网络，也使用类似的公式计算：</p>
<script type="math/tex; mode=display">
\begin{align*}
a^{[1]} & = \sigma(W^{[1]}x+b^{[1]}) \\

\hat{y}=a^{[2]} & = \sigma(W^{[2]}a^{[1]}+b^{[2]})
\end{align*}</script><blockquote>
<p>上节课中，参数$w$是一个列向量。这节课的参数$W$是一个矩阵。我们稍后会见到$W$的全貌。</p>
</blockquote>
<p>这里的方括号上标$[l]$表示第$l$层相关的变量。总结一下，$a_i^{<a href="k">j</a>}$表示第$k$个样本在网络第$j$层中向量的第$i$个分量。</p>
<p>事实上，输入$x$可以看成$a^{[0]}$。</p>
<blockquote>
<p>这里的a是activation（激活）意思，每个$a$都是激活函数的输出。</p>
</blockquote>
<p>为了方便称呼，我们给神经网络的层取了些名字：</p>
<p><img src="/2022/05/23/DLS-note-3/1.jpg" alt></p>
<p>其中，输入叫做“输入层”，最后一个计算层叫做“输出层”，中间其余的层都叫做“隐藏层”。事实上，由于第一个输入层不参与计算，它不会计入网络的总层数，只是为了方便称呼才这么叫。因此，上面这个网络看上去有3层，但叫做“双层神经网络”，或“单隐藏层神经网络”。</p>
<h2 id="单样本多神经元的计算"><a href="#单样本多神经元的计算" class="headerlink" title="单样本多神经元的计算"></a>单样本多神经元的计算</h2><p>让我们先看一下，对于<strong>一个输入样本</strong>$x^{(1)}$，神经网络是怎么计算输出的。</p>
<p><img src="/2022/05/23/DLS-note-3/2.jpg" alt></p>
<p>如图，输入 $x$ 是一个形状为$3 \times 1$的列向量。第一层有三个神经元，第一个神经元的参数是$w_1^{[1]}, b_1^{[1]}$，第二个是$w_2^{[1]}, b_2^{[1]}$，第三个是$w_3^{[1]}, b_3^{[1]}$。</p>
<p>$w_i^{[1]}$的形状是$1 \times 3$，$b_i^{[1]}$是常数。</p>
<p>每个神经元的计算公式和上节课的逻辑回归相同，都是$z_i^{[1]}=w_i^{[1]}x+b_i^{[1]}$，$a_i^{[1]}=\sigma(z_i^{[1]})$（$i \in [1, 2, 3]$)。</p>
<blockquote>
<p>回忆一下，上一节课里$w$的形状是$n_x \times1$，即一个长度为$n_x$的<strong>列向量</strong>，其中$n_x$是输入向量的长度（此处为3）。$b$是一个常数。计算结果时，我们要把$w$转置，计算$w^Tx+b$。这里的$w_i^{[1]}$是一个<strong>行向量</strong>，其形状是$1 \times n_x$，计算时不用转置。计算时直接$w_i^{[1]}x+b_i^{[1]}$就行。</p>
</blockquote>
<p>因为有三个神经元，我们得到三个计算结果$a_1^{[1]}, a_2^{[1]}, a_3^{[1]}$。我们可以把它们合起来当成一个$3 \times 1$的列向量$a^{[1]}$，就像输入$x$一样。</p>
<p>之后，这三个输出作为输入传入第二层的神经元，计算$z^{[2]}=W_1^{[2]}a^{[1]}+b^{[2]}$, $\hat{y}=a^{[2]}=\sigma(z^{[2]})$。这个算式和上周的逻辑回归一模一样。</p>
<p>总结一下，如果某一层有$n$个神经元，那么这一层的输出就是一个长度为$n$的列向量。这个输出会被当作下一层的输入。神经网络的每一层都按同样的方式计算着。</p>
<p>对于单隐层神经网络，隐藏层的参数$W^{[1]}$的形状是$n_1 \times n_x$，其中$n_1$是隐藏层神经元个数，$n_x$是每个输入样本的向量长度。参数$b^{[1]}$的形状是$n_1 \times 1$。输出层参数$W^{[2]}$的形状是$1 \times n_1$，$b^{[2]}$的形状是$1 \times 1$。</p>
<h2 id="多样本多神经元的计算"><a href="#多样本多神经元的计算" class="headerlink" title="多样本多神经元的计算"></a>多样本多神经元的计算</h2><p>和上一节课一样，让我们把一个输入样本拓展到<strong>多个样本</strong>，看看整个计算公式该怎么写。</p>
<p>对于第$i$个输入样本$x^{(i)}$，我们要计算：</p>
<script type="math/tex; mode=display">
\begin{align*}
a^{[1](i)} & =\sigma(W^{[1]}x^{(i)}+b^{[1]}) \\
a^{[2](i)} & =\sigma(W^{[2]}a^{[1](i)}+b^{[2]})
\end{align*}</script><p>直接写的话，我们要写个for循环，把$i$从$0$遍历到$m-1$。</p>
<blockquote>
<p>回忆一下，$m$是样本总数。</p>
</blockquote>
<p>但是，如果把输入打包在一起，形成一个$n_x \times m$的矩阵$X$，那么整个计算过程可以用十分相似的向量化计算公式表示：</p>
<script type="math/tex; mode=display">
\begin{align*}
A^{[1]} & =\sigma(W^{[1]}X+b^{[1]}) \\
A^{[2]} & =\sigma(W^{[2]}A^{[1]}+b^{[2]})
\end{align*}</script><blockquote>
<p>这里的$X$,$A$相当于横向“拉长了”：</p>
<script type="math/tex; mode=display">
X=\left[
  \begin{matrix}
  | & | & & | \\
  x^{(1)} & x^{(2)} & ... & x^{(m)} \\
  | & | & & |
  \end{matrix}
\right] \\ 
\ \\
A^{[l]}=\left[
  \begin{matrix}
  | & | & & | \\
  a^{[l](1)} & a^{[l](2)} & ... & a^{[l](m)} \\
  | & | & & |
  \end{matrix}
\right]</script></blockquote>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>在神经网络中，我们每做完一个线性运算$Z=WX+b$后，都会做一个$\sigma(Z)$的操作。上周我们讲这个$\sigma$（sigmoid函数）是为了把实数的输入映射到$[0, 1]$。这是它在逻辑回归的作用。而在普通的神经网络中，$\sigma$就有别的作用了——<strong>激活</strong>线性输出。$\sigma$其实只是激活输出的<strong>激活函数</strong>的一员，还有很多其他函数都可以用作为激活函数。我们现在暂时不管这个“激活”是什么意思，先认识一下常见的激活函数。</p>
<p><img src="/2022/05/23/DLS-note-3/3.jpg" alt></p>
<blockquote>
<p>画这些函数的代码见后文。</p>
</blockquote>
<p>它们的数学公式如下：</p>
<script type="math/tex; mode=display">
sigmoid(x)=\frac{1}{1+e^{-x}} \\
tanh(x)=\frac{e^x - e^{-x}}{e^x + e^{-x}} \\
relu(x) = \left\{
\begin{aligned}
   x & \ (x \geq 0) \\
   0 & \ (x < 0)
\end{aligned}
\right. \\
leaky\_relu(x) = \left\{
\begin{aligned}
   x & \ (x \geq 0) \\
   kx & \ (x < 0, k < 1)
\end{aligned}
\right.</script><p>其中leaky_relu里的$k$是一个常数，这个常数要小于1。图中的leaky_relu的$k$取了0.1。</p>
<p>现在来介绍一下这些激活函数。</p>
<p>sigmiod，老熟人了，这个函数可以把实数上的输入映射到$(0, 1)$。tanh其实是sigmoid的一个“位移版”（二者的核心都是$e^x$），它可以把实数的输入映射到$(-1, 1)$。</p>
<p>这两个函数有一个问题：当x极大或者极小的时候，函数的梯度几乎为0。从图像上来看，也就是越靠近左边或者右边，函数曲线就越平。梯度过小，会导致梯度下降法每次更新的幅度较小，从而使网络训练速度变慢。</p>
<p>为了解决梯度变小的问题，研究者们又提出了relu函数(rectified linear unit, 线性整流单元)。别看这个名字很高大上，relu函数本身其实很简单：你是正数，就取原来的值；你是负数，就取0。非常的简单直接。把这个函数用作激活函数，梯度总是不会太小，可以有效加快训练速度。</p>
<p>有人觉得relu对负数太“一刀切”了，把relu在负数上的值改成了一个随输入$x$变化的，十分接近0的值。这样一个新的relu函数就叫做leaky relu。（大家应该知道为什么leaky_relu的$k$要小于1了吧）</p>
<blockquote>
<p>写在博客里的题外话：浅谈文章的统一性。为什么这里relu用的是小写呢？按照英文的写法，应该是ReLU才对啊？这里是不是写文章的时候不够严谨啊？其实不是。我们这里其实统一用的是代码写法，即全部单词小写。我们首次介绍relu时，是在上文的图片和公式里。那里面用的是小写的relu。后文其实是对这种描述的一个统一，表示“前文用到的relu”，而不是一般用语中的ReLU。在后面的文章中，我会使用ReLU这个称呼。</p>
<p>如果有严谨的文字工作者，还会质疑道：“你这篇文章里有些单词应该用公式框起来，有些应该用代码框起来，怎么直接用文本表示啊？”这是因为微信公众号对公式的支持很烂，我编辑得累死了，不想动脑去思考到底用公式还是用代码了。要把一个东西写得天衣无缝，需要耗费大量的时间。为了权衡，我抛弃了部分严谨性，换来了写文章的效率。</p>
</blockquote>
<h2 id="如何选择激活函数"><a href="#如何选择激活函数" class="headerlink" title="如何选择激活函数"></a>如何选择激活函数</h2><p>tanh由于其值域比sigmoid大，原理又一模一样，所以tanh在数学上严格优于sigmoid。除非是输出恰好处于$(0, 1)$(比如逻辑回归的输出)，不然宁可用tanh也不要用sigmoid。</p>
<p>现在大家都默认使用relu作为激活函数，偶尔也有使用leaky_relu的。吴恩达老师鼓励大家多多尝试不同的激活函数。</p>
<p>在之前介绍的公式中，我们所有激活函数$g$都默认用的是$g=\sigma$。准确来说，单隐层神经网络公式应该写成下面这种形式：</p>
<script type="math/tex; mode=display">
\begin{align*}
A^{[1]} & =g^{[1]}(W^{[1]}X+b^{[1]}) \\
A^{[2]} & =g^{[2]}(W^{[2]}A^{[1]}+b^{[2]})
\end{align*}</script><p>由于第二层网络的输出落在[0, 1]，我们第二个激活函数还是可以用sigmoid，即$g^{[2]}=\sigma$。</p>
<h2 id="激活函数的作用"><a href="#激活函数的作用" class="headerlink" title="激活函数的作用"></a>激活函数的作用</h2><p>假设我们有一个两层神经网络：</p>
<script type="math/tex; mode=display">
\hat{y} = g(W_2 \cdot g(W_1x+b_1) + b_2)</script><p>其中激活函数用$g$表示。</p>
<p>假如我们不使用激活函数，即令$g(x)=x$的话，这个神经网络就变成了：</p>
<script type="math/tex; mode=display">
\begin{align*}
\hat{y} &= W_2 \cdot (W_1x+b_1) + b_2 \\
&= (W_2W_1)x+(b_1+b_2)
\end{align*}</script><p>我们把$W_2W_1$看成一个新的“$W$”,$(b_1+b_2)$看成一个新的”$b$”,那么这其实是一个单层神经网络。</p>
<p>也就是说，如果我们不用激活函数，那么无论神经网络有多少层，这个神经网络都等价于只有一层。这种神经网络永远只能拟合一个线性函数。</p>
<p>为了让神经网络取拟合一个非线性的，超级复杂的函数，我们必须要使用激活函数。</p>
<h2 id="激活函数的导数（选读）"><a href="#激活函数的导数（选读）" class="headerlink" title="激活函数的导数（选读）"></a>激活函数的导数（选读）</h2><blockquote>
<p>为了让大家重新体验一下高中学数学的感觉，这里求导的步骤推得十分详细。</p>
</blockquote>
<h3 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h3><script type="math/tex; mode=display">
\begin{align*}
f(x) &= \frac{1}{1+e^{-x}} \\
f'(x) &=  -(\frac{1}{1+e^{-x}})^2(e^{-x})' \\
&= -(\frac{1}{1+e^{-x}})^2(-e^{-x}) \\
&= \frac{e^{-x}}{(1+e^{-x})^2} \\
&= f(x)(1-f(x))
\end{align*}</script><blockquote>
<p>上篇笔记也吐槽过了，想写出最后一步，需要发动数学家的固有技能：「注意到」。这不怎么学数学的人谁能注意到最后这一步啊。</p>
</blockquote>
<h3 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h3><script type="math/tex; mode=display">
\begin{align*}
f(x) &= \frac{e^x - e^{-x}}{e^x + e^{-x}} = \frac{e^{2x}-1}{e^{2x}+1}\\
\\
(\frac{x-1}{x+1})' &=\frac{(x+1)-(x-1)}{(x+1)^2}\\
&= \frac{2}{(x+1)^2}\\
\\
f'(x) &=  (\frac{x-1}{x+1})'(e^{2x}) \cdot (e^{2x})' \\
&= \frac{2}{(e^{2x}+1)^2}(2e^{2x}) \\
&= \frac{4e^{2x}}{(e^{2x}+1)^2} \\
&= (1+ f(x))(1-f(x))
\end{align*}</script><blockquote>
<p>回忆一下，$(\frac{u}{v})’=(\frac{u’v-uv’}{v^2})$。</p>
<p>最后这步我依然注意不到。我猜原函数$f(x)$是用$f’(x)=(1+ f(x))(1-f(x))$这个微分方程构造出来的，而不是反过来恰好发现导数能够写得这么简单。</p>
</blockquote>
<h3 id="relu"><a href="#relu" class="headerlink" title="relu"></a>relu</h3><script type="math/tex; mode=display">
f(x) = \left\{
\begin{aligned}
   x & \ (x \geq 0) \\
   0 & \ (x < 0)
\end{aligned}
\right. \\
f'(x) = \left\{
\begin{aligned}
   1 & \ (x > 0) \\
   0 & \ (x < 0)
\end{aligned}
\right. \\</script><blockquote>
<p>这个导求得神清气爽。</p>
</blockquote>
<h3 id="leaky-relu"><a href="#leaky-relu" class="headerlink" title="leaky relu"></a>leaky relu</h3><script type="math/tex; mode=display">
f(x) = \left\{
\begin{aligned}
   x & \ (x \geq 0) \\
   kx & \ (x < 0)
\end{aligned}
\right. \\
f'(x) = \left\{
\begin{aligned}
   1 & \ (x > 0) \\
   k & \ (x < 0)
\end{aligned}
\right. \\</script><blockquote>
<p>学数学的人可能会很在意：relu和leaky relu在0处没有导数啊！碰到0你怎么梯度下降啊？实际上，我们编程的时候，不用管那么多，直接也令0处的导数为1就行（即导数在0处的右极限）。</p>
</blockquote>
<h2 id="对神经网络做梯度下降"><a href="#对神经网络做梯度下降" class="headerlink" title="对神经网络做梯度下降"></a>对神经网络做梯度下降</h2><p>回顾一下，如果只有两个参数$w, b$，应该用下式做梯度下降：</p>
<script type="math/tex; mode=display">
\begin{align*}
w & \gets w - \alpha \frac{dJ}{dw} \\ 
b & \gets b - \alpha \frac{dJ}{db}
\end{align*}</script><blockquote>
<p>回忆一下，$\alpha$是学习率，表示梯度更新的速度，一般取$0.0001$这种很小的值。</p>
</blockquote>
<p>现在，我们有4个参数：$W^{[1]},W^{[2]}, b^{[1]},b^{[2]}$，它们也应该按照同样的规则执行梯度下降：</p>
<script type="math/tex; mode=display">
\begin{align*}
W^{[1]} & \gets W^{[1]} - \alpha \frac{dJ}{dW^{[1]}} \\ 
W^{[2]} & \gets W^{[2]} - \alpha \frac{dJ}{dW^{[2]}} \\ 
b^{[1]} & \gets b^{[1]} - \alpha \frac{dJ}{db^{[1]}} \\
b^{[2]} & \gets b^{[2]} - \alpha \frac{dJ}{db^{[2]}} \\
\end{align*}</script><p>剩下的问题就是怎么求导了。让我们再看一遍神经网络正向传播的公式：</p>
<script type="math/tex; mode=display">
\begin{align*}
Z^{[1]} &= W^{[1]}X+b^{[1]} \\
A^{[1]} &= g^{[1]}(Z^{[1]}) \\
Z^{[2]} &= W^{[2]}X+b^{[2]} \\
A^{[2]} &= g^{[2]}(Z^{[2]})
\end{align*}</script><p>由于我们令$g^{[2]}=\sigma$，所以神经网络第二层（输出层）的导数可以直接套用上周的导数公式：</p>
<script type="math/tex; mode=display">
\begin{align*}
dZ^{[2]} &= A^{[2]}-Y \\
dW^{[2]} &=  \frac{1}{m}dZ^{[2]}A^{[1]T} \\
db^{[2]} &= \frac{1}{m} \Sigma_{i=1}^m dZ^{[2](i)} 
\end{align*}</script><blockquote>
<p><strong>注意！</strong> 上周我们算的是$AdZ^T$，这周是$dZ^{[2]}A^{[1]T}$。这是因为参数$W$转置了一下。上周的$w$是列向量，这周每个神经元的权重$W_i$是行向量。</p>
</blockquote>
<p>之后，我们来看第一层。首先求$dZ^{[1]}$:</p>
<script type="math/tex; mode=display">
\begin{align*}
dZ^{[1]} &= dA^{[1]}\frac{dA^{[1]}}{dZ^{[1]}} \\
&=W^{[2]T}dZ^{[2]} \ast g^{[1]'} (Z^{[1]})
\end{align*}</script><blockquote>
<p>注意，上式中右边第一项$dA^{[1]}$是$\frac{dJ}{dA^{[1]}}$的简写，第二项$\frac{dA^{[1]}}{dZ^{[1]}}$是实实在在的求导。</p>
<p>这里$dA^{[1]}$和$dW^{[2]}$的计算是对称的哟。</p>
</blockquote>
<p>之后的$dW^{[1]}, db^{[1]}$的公式和前面$dW^{[2]}, db^{[2]}$的相同：</p>
<script type="math/tex; mode=display">
\begin{align*}
dW^{[1]} &=  \frac{1}{m}dZ^{[1]}X^{T} \\
db^{[1]} &= \frac{1}{m} \Sigma_{i=1}^m dZ^{[1](i)} 
\end{align*}</script><blockquote>
<p>别忘了，$X=A^{[0]}$。</p>
</blockquote>
<p>这些求导的步骤写成代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dZ2=A2-Y</span><br><span class="line">dW2=np.dot(dZ2, A1.T) / m</span><br><span class="line">db2=np.<span class="built_in">sum</span>(dZ2, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>) / m</span><br><span class="line">dZ1=np.dot(W2.T, dZ2) * g1_backward(Z1)</span><br><span class="line">dW1=np.dot(dZ1, X.T) / m</span><br><span class="line">db1=np.<span class="built_in">sum</span>(dZ1, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>) / m</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>再次温馨提示，搞不清楚数学公式的细节没关系，直接拿来用就好了。要学会的是算法的整体思路。</p>
</blockquote>
<p>这段代码有一点需要注意：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db2=np.<span class="built_in">sum</span>(dZ2, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">db1=np.<span class="built_in">sum</span>(dZ1, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>这个<code>keepdims=True</code>是必不可少的。使用<code>np.sum, np.mean</code>这种会导致维度变少的计算时，如果加了<code>keepdims=True</code>,会让变少的那一个维度保持长度1.比如一个[4, 3]的矩阵，我们对第二维做求和，理论上得到的是一个[4]的向量。但如果用了<code>keepdims=True</code>，就会得到一个[4, 1]的矩阵。</p>
<p>保持向量的维度，可以让某些广播运算正确进行。比如我要用[4, 3]的矩阵减去[4]的矩阵就会报错，而减去[4, 1]的矩阵就不会报错。</p>
<h2 id="参数随机初始化"><a href="#参数随机初始化" class="headerlink" title="参数随机初始化"></a>参数随机初始化</h2><p>再次回顾下，梯度下降算法的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始化参数</span><br><span class="line">迭代 k 步：</span><br><span class="line">   算参数的梯度</span><br><span class="line">   用梯度更新参数</span><br></pre></td></tr></table></figure>
<p>对于这节课新学的单隐层神经网络，求导、更新参数的过程我们已经学完了。我们还有一个东西没有详细探究：参数的初始化方式。现在，我们来详细研究一下参数初始化。</p>
<p>在上节课中，我们用一句话就带过了参数初始化方法：令参数全为0就行了。这种初始化方法在这节课还有用吗？让我们来看课堂里提到的一个示例：</p>
<p><img src="/2022/05/23/DLS-note-3/4.jpg" alt></p>
<p>如上图，对于输入长度为2，第一层有2个神经元的网络，其第一层参数$W^{[1]}$为<code>[[0, 0], [0, 0]]</code>。这样算出来的神经元输出$a^{[1]}_1,a^{[1]}_2$是一样的。而更新梯度时，每一个神经元的参数$W^{[1]}_1, W^{[1]}_2$的梯度都只和该神经元的输出有关。这样，每个神经元参数的导数<code>dw</code>都是一模一样的。导数一样，初始化的值也一样，那么每个神经元的参数的值会一直保持相同。这样，不论我们在某一层使用了多少个神经元，都等价于只使用一个神经元。</p>
<p>为了不发生这样的情况，我们需要让每一个神经元的参数$w$都<strong>取不同的值</strong>。这可以通过<strong>随机初始化</strong>实现。只需要使用下面的代码就可以随机初始化$w$:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = np.random.randn((h, w)) * 0.01</span><br></pre></td></tr></table></figure>
<p>注意，这里我们给随机出的数乘了个0.01。这是因为出于经验，人们更倾向于使用更小的参数，以计算出更小的结果，防止激活函数（如tanh）在绝对值过大时梯度过小的问题。</p>
<blockquote>
<p>后面的课会详细介绍该如何初始化这些参数，以及初始化参数可以解决哪些问题。</p>
</blockquote>
<p>而$b$和之前一样，直接用0初始化就行了。</p>
<h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p>在这堂课中，我们正式认识了神经网络的定义。原来，上周的逻辑回归只是一个特殊的神经网络。它只有一个输出层，并且使用sigmoid作激活函数。而这周，我们学习了如何定义一个两层（一个隐藏层、一个输出层）的神经网络，并且知道如何在网络中使用不同的激活函数。</p>
<p>让我们来看一下这节课的知识点：</p>
<ul>
<li>神经网络的定义<ul>
<li>输入层、隐藏层、输出层</li>
<li>每一层每一个神经元相关的参数该怎么表示</li>
</ul>
</li>
<li>神经网络的计算方式<ul>
<li>单样本 -&gt; 多样本</li>
<li>正向传播与反向传播</li>
</ul>
</li>
<li>激活函数<ul>
<li>直观认识激活函数——激活函数属于神经网络计算中的哪一部分？</li>
<li>常见的四种激活函数：sigmoid, tanh, relu, leaky_relu</li>
<li><strong>如何选择激活函数</strong></li>
<li><strong>为什么要使用激活函数</strong></li>
</ul>
</li>
<li>神经网络与逻辑回归的区别——参数初始化问题<ul>
<li><strong>为什么不能用0初始化$W$</strong></li>
<li>随机初始化$W$</li>
<li>可以用0初始化$b$</li>
</ul>
</li>
</ul>
<h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><p>这节课的编程作业是搞一个点集分类器。此任务的数据集如下图所示：</p>
<p><img src="/2022/05/23/DLS-note-3/5.jpg" alt></p>
<p>在平面上，已知有一堆红色的点和绿色的点。我们希望任意给定一个点，程序能够判断这个点是红点还是绿点。</p>
<p>让我们人类来分类的话，肯定会认为左边一片花瓣和右上角两片花瓣是绿色的，剩下三片花瓣是红色的（有部分点不满足这个规律，可以认为这些点是噪声，即不正确的数据）。让神经网络来做这个任务，会得到怎样的结果呢？</p>
<p>现在，让我们用这周学的单隐层神经网络，来实现这个分类器。</p>
<p>虽然前面说这周要继续挑战猫狗分类任务，但我估摸着这周的模型可能还是简单了一点。等下周学了再强大一点的模型，我再来复仇。</p>
<p>项目链接:<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/ShallowNetwork">https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/ShallowNetwork</a></p>
<h2 id="通用分类器类"><a href="#通用分类器类" class="headerlink" title="通用分类器类"></a>通用分类器类</h2><p>在上节课的编程实战中，我们很暴力地写了“一摊”代码。说实话，有编程洁癖的我是不能接受那种潦草的代码的。如果代码写得太乱，就根本不能复用，根本不可读，根本不能体现编程的逻辑之美。</p>
<p>这周，我将解除封印，释放我30%的编程水平，展示一个比较优雅的通用分类器类该怎么写。我们会先把上周的逻辑回归用继承基类的方式实现一遍，再实现一遍这周的浅层神经网络。</p>
<p>分类器基类的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRegressionModel</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line">    <span class="comment"># Use Cross Entropy as the cost function</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, train_mode=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="comment"># if self.train_mode:</span></span><br><span class="line">        <span class="comment">#   forward_train()</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#   forward_test()</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">self, Y</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span>(<span class="params">self, learning_rate=<span class="number">0.001</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">self, Y_hat, Y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.mean(-(Y * np.log(Y_hat) + (<span class="number">1</span> - Y) * np.log(<span class="number">1</span> - Y_hat)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span>(<span class="params">self, X, Y</span>):</span></span><br><span class="line">        Y_hat = self.forward(X, train_mode=<span class="literal">False</span>)</span><br><span class="line">        predicts = np.where(Y_hat &gt; <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        score = np.mean(np.where(predicts == Y, <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Accuracy: <span class="subst">&#123;score&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>为了简化代码，我们用<code>BaseRegressionModel</code>表示一个使用交叉熵为损失函数的二分类模型。这样，我们所有的模型都可以共用一套损失函数<code>loss</code>、一套评估方法<code>evaluate</code>。这里损失函数和评估方法的实现都是从上周的代码里复制过来的。</p>
<p>让我们分别看一下其他几个类方法的描述：</p>
<ul>
<li><code>__init__</code>: 模型的参数应该在<code>__init__</code>方法里初始化。</li>
<li><code>forward</code>：正向传播函数。这个函数即可以用于测试，也可以用于训练。如果是用于训练，就要令参数<code>train_mode=True</code>。为什么要区分训练和测试呢？这是因为，正向传播在训练的时候需要额外保存一些数据(缓存)，保存数据是存在开销的。在测试的时候，我们可以不做缓存，以降低程序运行开销。</li>
<li><code>backward</code>：反向传播函数。这个函数用于<code>forward</code>之后的梯度计算。算出来的梯度会缓存起来，供反向传播使用。</li>
<li><code>gradient_descent</code>：用梯度下降更新模型的参数。（一般框架会把优化器和模型分开写。由于我们现在只学了梯度下降这一种优化策略，所以直接把梯度下降当成了模型类的方法）</li>
</ul>
<p>有了这样一个分类器基类后，我们可以用统一的方式训练模型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span>(<span class="params">model: BaseRegressionModel,</span></span></span><br><span class="line"><span class="params"><span class="function">                X_train,</span></span></span><br><span class="line"><span class="params"><span class="function">                Y_train,</span></span></span><br><span class="line"><span class="params"><span class="function">                X_test,</span></span></span><br><span class="line"><span class="params"><span class="function">                Y_test,</span></span></span><br><span class="line"><span class="params"><span class="function">                steps=<span class="number">1000</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                learning_rate=<span class="number">0.001</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                print_interval=<span class="number">100</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(steps):</span><br><span class="line">        Y_hat = model.forward(X_train)</span><br><span class="line">        model.backward(Y_train)</span><br><span class="line">        model.gradient_descent(learning_rate)</span><br><span class="line">        <span class="keyword">if</span> step % print_interval == <span class="number">0</span>:</span><br><span class="line">            train_loss = model.loss(Y_hat, Y_train)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Step <span class="subst">&#123;step&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Train loss: <span class="subst">&#123;train_loss&#125;</span>&#x27;</span>)</span><br><span class="line">            model.evaluate(X_test, Y_test)</span><br></pre></td></tr></table></figure><br>有了一个初始化好的模型<code>model</code>后，我们在训练函数<code>train_model</code>里可以直接开始循环训练模型。每次我们先调用<code>model.forward</code>做正向传播，缓存一些数据，再调用<code>model.backward</code>反向传播算梯度，最后调用<code>model.gradient_descent</code>更新模型的参数。每训练一定的步数，我们监控一次模型的训练情况，输出模型的训练loss和测试精度。</p>
<p>看吧，是不是使用了类来实现神经网络后，整个代码清爽而整洁？</p>
<h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.maximum(x, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu_de</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.where(x &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>同样，为了让代码更整洁，我把一些工具函数单独放到了一个文件里。现在，如上面的代码所示，我们的工具函数只有几个损失函数及它们的导数。（用于sigmoid只用于最后一层，我们可以直接用<code>dZ=A-Y</code>跳一个导数计算步骤，所以这里没有写sigmoid的导数）。</p>
<h2 id="复现逻辑回归"><a href="#复现逻辑回归" class="headerlink" title="复现逻辑回归"></a>复现逻辑回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegression</span>(<span class="params">BaseRegressionModel</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n_x</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.n_x = n_x</span><br><span class="line">        self.w = np.zeros((n_x, <span class="number">1</span>))</span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, train_mode=<span class="literal">True</span></span>):</span></span><br><span class="line">        Z = np.dot(self.w.T, X) + self.b</span><br><span class="line">        A = sigmoid(Z)  <span class="comment"># hat_Y = A</span></span><br><span class="line">        <span class="keyword">if</span> train_mode:</span><br><span class="line">            self.m_cache = X.shape[<span class="number">1</span>]</span><br><span class="line">            self.X_cache = X</span><br><span class="line">            self.A_cache = A</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">self, Y</span>):</span></span><br><span class="line">        d_Z = self.A_cache - Y</span><br><span class="line">        d_w = np.dot(self.X_cache, d_Z.T) / self.m_cache</span><br><span class="line">        d_b = np.mean(d_Z)</span><br><span class="line">        self.d_w_cache = d_w</span><br><span class="line">        self.d_b_cache = d_b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span>(<span class="params">self, learning_rate=<span class="number">0.001</span></span>):</span></span><br><span class="line">        self.w -= learning_rate * self.d_w_cache</span><br><span class="line">        self.b -= learning_rate * self.d_b_cache</span><br></pre></td></tr></table></figure>
<p>逻辑回归是上节课的内容，这里就不讲解，直接贴代码了。大家可以通过这个例子看一看<code>BaseRegressionModel</code>的子类应该怎么写。</p>
<h2 id="实现单隐层神经网络"><a href="#实现单隐层神经网络" class="headerlink" title="实现单隐层神经网络"></a>实现单隐层神经网络</h2><p>有了基类后，我们更加明确代码中哪些地方是要重新写，不能复用以前的代码了。在实现浅层神经网络时，我们要重写<strong>模型初始化</strong>、<strong>正向传播</strong>、<strong>反向传播</strong>、<strong>梯度下降</strong>这几个步骤。</p>
<h3 id="模型初始化"><a href="#模型初始化" class="headerlink" title="模型初始化"></a>模型初始化</h3><p>我们要在<code>__init__</code>里初始化模型的参数。回忆一下这周的单隐层神经网络推理公式：</p>
<script type="math/tex; mode=display">
\begin{align*}
A^{[1]} & =g^{[1]}(W^{[1]}X+b^{[1]}) \\
A^{[2]} & =g^{[2]}(W^{[2]}A^{[1]}+b^{[2]})
\end{align*}</script><p>其中，有四个参数$W^{[1]}, W^{[2]}, b^{[1]}, b^{[2]}$，它们的形状分别是$n_1 \times n_x$, $1 \times n_1$, $n_1 \times 1$, $1 \times 1$。我们需要在这里决定$n_x, n_1$这两个数。</p>
<p>$n_x$由输入向量的长度决定。由于我们是做2维平面点集分类，每一个输入数据就是一个二维的点。因此，在稍后初始化模型时，我们会令$n_x=2$。</p>
<p>$n_1$属于网络的超参数，我们可以调整这个参数的值。</p>
<p>计划好了初始化函数的输入参数后，我们来看看初始化函数的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n_x, n_1</span>):</span></span><br><span class="line">   <span class="built_in">super</span>().__init__()</span><br><span class="line">   self.n_x = n_x</span><br><span class="line">   self.n_1 = n_1</span><br><span class="line">   self.W1 = np.random.randn(n_1, n_x) * <span class="number">0.01</span></span><br><span class="line">   self.b1 = np.zeros((n_1, <span class="number">1</span>))</span><br><span class="line">   self.W2 = np.random.randn(<span class="number">1</span>, n_1) * <span class="number">0.01</span></span><br><span class="line">   self.b2 = np.zeros((<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<p>别忘了，前面我们学过，初始化<code>W</code>时要使用随机初始化，且让初始化出来的值比较小。</p>
<h3 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h3><p>我们打算神经网络令第一层的激活函数为relu，第二层的激活函数为sigmoid。因此，模型的正向传播公式如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
A^{[1]} & =relu(W^{[1]}X+b^{[1]}) \\
A^{[2]} & =sigmoid(W^{[2]}A^{[1]}+b^{[2]})
\end{align*}</script><p>用代码表示如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X, train_mode=<span class="literal">True</span></span>):</span></span><br><span class="line">   Z1 = np.dot(self.W1, X) + self.b1</span><br><span class="line">   A1 = relu(Z1)</span><br><span class="line">   Z2 = np.dot(self.W2, A1) + self.b2</span><br><span class="line">   A2 = sigmoid(Z2)</span><br><span class="line">   <span class="keyword">if</span> train_mode:</span><br><span class="line">      self.m_cache = X.shape[<span class="number">1</span>]</span><br><span class="line">      self.X_cache = X</span><br><span class="line">      self.Z1_cache = Z1</span><br><span class="line">      self.A1_cache = A1</span><br><span class="line">      self.A2_cache = A2</span><br><span class="line">   <span class="keyword">return</span> A2</span><br></pre></td></tr></table></figure></p>
<p>其中<code>train_mode</code>里的内容是我们待会儿要在反向传播用到的数据，这里需要先缓存起来。</p>
<blockquote>
<p>事实上，我是边写反向传播函数，边写这里<code>if train_mode:</code>里面的缓存数据的。编程不一定要按照顺序写。</p>
</blockquote>
<h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>翻译一下这些公式：</p>
<script type="math/tex; mode=display">
\begin{align*}
dZ^{[2]} &= A^{[2]}-Y \\
dW^{[2]} &=  \frac{1}{m}dZ^{[2]}A^{[1]T} \\
db^{[2]} &= \frac{1}{m} \Sigma_{i=1}^m dZ^{[2](i)} \\
dZ^{[1]} &=W^{[2]T}dZ^{[2]} \ast g^{[1]'} (Z^{[1]}) \\
dW^{[1]} &=  \frac{1}{m}dZ^{[1]}X^{T} \\
db^{[1]} &= \frac{1}{m} \Sigma_{i=1}^m dZ^{[1](i)} 
\end{align*}</script><p>用代码写就是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">self, Y</span>):</span></span><br><span class="line">   dZ2 = self.A2_cache - Y</span><br><span class="line">   dW2 = np.dot(dZ2, self.A1_cache.T) / self.m_cache</span><br><span class="line">   db2 = np.<span class="built_in">sum</span>(dZ2, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>) / self.m_cache</span><br><span class="line">   dA1 = np.dot(self.W2.T, dZ2)</span><br><span class="line"></span><br><span class="line">   dZ1 = dA1 * relu_de(self.Z1_cache)</span><br><span class="line">   dW1 = np.dot(dZ1, self.X_cache.T) / self.m_cache</span><br><span class="line">   db1 = np.<span class="built_in">sum</span>(dZ1, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>) / self.m_cache</span><br><span class="line"></span><br><span class="line">   self.dW2_cache = dW2</span><br><span class="line">   self.dW1_cache = dW1</span><br><span class="line">   self.db2_cache = db2</span><br><span class="line">   self.db1_cache = db1</span><br></pre></td></tr></table></figure>
<p>算完梯度后，我们要把它们缓存起来，用于之后的梯度下降。</p>
<h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span>(<span class="params">self, learning_rate=<span class="number">0.001</span></span>):</span></span><br><span class="line">   self.W1 -= learning_rate * self.dW1_cache</span><br><span class="line">   self.b1 -= learning_rate * self.db1_cache</span><br><span class="line">   self.W2 -= learning_rate * self.dW2_cache</span><br><span class="line">   self.b2 -= learning_rate * self.db2_cache</span><br></pre></td></tr></table></figure>
<p>梯度已经算好了，梯度下降就没什么好讲的了。</p>
<h2 id="挑战点集分类问题"><a href="#挑战点集分类问题" class="headerlink" title="挑战点集分类问题"></a>挑战点集分类问题</h2><h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><blockquote>
<p>这里我已经提前实现好了生成数据集的函数。本文的附录里会介绍这些函数的细节。</p>
</blockquote>
<p>使用项目里的 <code>generate_point_set</code> 函数可以生成一个平面点集分类数据集：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x, y, label = generate_point_set()</span><br><span class="line"><span class="comment"># x: [240]</span></span><br><span class="line"><span class="comment"># y: [240]</span></span><br><span class="line"><span class="comment"># label: [240]</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>x[i]</code>是第i个点的横坐标，<code>y[i]</code>是第i个点的纵坐标，<code>label[i]</code>是第i个点的标签。标签为0表示是红色的点，标签为1表示是绿色的点。</p>
<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>得到了原始数据后，我们要把数据处理成矩阵X和Y，其中X的形状是<code>[2, m]</code>，Y的形状是<code>[1, m]</code>，其中<code>m</code>是样本大小。之后，我们还需要把原始数据拆分成训练集和测试集。</p>
<p>第一步生成矩阵的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = np.stack((x, y), axis=<span class="number">1</span>)</span><br><span class="line">Y = np.expand_dims(label, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># X: [240, 2]</span></span><br><span class="line"><span class="comment"># Y: [240, 1]</span></span><br></pre></td></tr></table></figure></p>
<p>大家应该能猜出<code>stack</code>和<code>expand_dims</code>是什么意思。<code>stack</code>能把两个张量堆起来，比如这里把表示x,y坐标的一维向量合成起来，变成一个向量（长度为2）的向量（长度为240）。<code>expand_dims</code>就是凭空给张量加一个长度为1的维度，比如这里给<code>Y</code>添加了<code>axis=1</code>上的维度。</p>
<p>第二步划分数据集的方法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">indices = np.random.permutation(X.shape[<span class="number">0</span>])</span><br><span class="line">X_train = X[indices[<span class="number">0</span>:<span class="number">200</span>], :].T</span><br><span class="line">Y_train = Y[indices[<span class="number">0</span>:<span class="number">200</span>], :].T</span><br><span class="line">X_test = X[indices[<span class="number">200</span>:], :].T</span><br><span class="line">Y_test = Y[indices[<span class="number">200</span>:], :].T</span><br><span class="line"><span class="comment"># X_train: [2, 200]</span></span><br><span class="line"><span class="comment"># Y_train: [1, 200]</span></span><br><span class="line"><span class="comment"># X_test: [2, 40]</span></span><br><span class="line"><span class="comment"># Y_test: [1, 40]</span></span><br></pre></td></tr></table></figure><br>注意，我们划分数据集的时候最好要随机划分。我这里使用<code>np.random.permutation</code>生成了一个排列，把这个排列作为下标来打乱数据集。</p>
<p>大家看不懂这段代码的话，可以想象这样一个例子：老师想抽10个人去值日，于是，他把班上同学的学号打乱，在打乱后的学号列表中，把前10个学号的同学叫了出来。代码里<code>indices</code>就是用随机排列生成的一个“打乱过的学号”，根据这个随机索引值，我们把前200个索引的数据当成训练集，200号索引之后的数据当成测试集。</p>
<p>经过这些处理，数据就符合课堂上讲过的形状要求了。</p>
<h3 id="使用模型"><a href="#使用模型" class="headerlink" title="使用模型"></a>使用模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n_x = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">model1 = LogisticRegression(n_x)</span><br><span class="line">model2 = ShallowNetwork(n_x, <span class="number">2</span>)</span><br><span class="line">model3 = ShallowNetwork(n_x, <span class="number">4</span>)</span><br><span class="line">model4 = ShallowNetwork(n_x, <span class="number">10</span>)</span><br><span class="line">train_model(model1, X_train, Y_train, X_test, Y_test, <span class="number">500</span>, <span class="number">0.0001</span>, <span class="number">50</span>)</span><br><span class="line">train_model(model2, X_train, Y_train, X_test, Y_test, <span class="number">2000</span>, <span class="number">0.01</span>, <span class="number">100</span>)</span><br><span class="line">train_model(model3, X_train, Y_train, X_test, Y_test, <span class="number">2000</span>, <span class="number">0.01</span>, <span class="number">100</span>)</span><br><span class="line">train_model(model4, X_train, Y_train, X_test, Y_test, <span class="number">2000</span>, <span class="number">0.01</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>由于我们前面已经定义好了模型，使用模型的过程就很惬意了。这里直接初始化我们自己编写的类，再用训练函数训练模型即可。</p>
<p>为了比较不同的模型，从感性上认识不同模型间的区别，在示例代码中我训练了4个模型。第一个模型是逻辑回归，后三个模型分别是隐藏层有2、4、10个神经元的单隐藏层神经网络。</p>
<p>模仿这堂课的编程作业，我也贴心地实现了模型可视化函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">visualize_X = generate_plot_set()</span><br><span class="line">plot_result = model4.forward(visualize_X, train_mode=<span class="literal">False</span>)</span><br><span class="line">visualize(X, Y, plot_result)</span><br></pre></td></tr></table></figure>
<p>只要运行上面这些代码，大家就可以看到模型具体是怎么分类2维平面上所有点的。让我们在下一节里看看这些函数的运行效果。</p>
<h3 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h3><p>好了，最好玩的地方来了。让我们有请四位选手，看看他们在二维点分类任务上表现如何。</p>
<p>首先是逻辑回归：</p>
<p><img src="/2022/05/23/DLS-note-3/6.jpg" alt></p>
<p>逻辑回归选手也太菜了吧！他只能模拟一条直线。这条直线虽然把下面两片红色花瓣包进去了，但忽略了左上角的花瓣。太弱了，太弱了！</p>
<p><img src="/2022/05/23/DLS-note-3/7.jpg" alt></p>
<p>隐藏层只有2个神经元的选手也菜得不行，和逻辑回归一起可谓是“卧龙凤雏”啊！</p>
<p><img src="/2022/05/23/DLS-note-3/8.jpg" alt></p>
<p><img src="/2022/05/23/DLS-note-3/9.jpg" alt></p>
<p>4-神经元选手似乎在尝试做出一些改变！好像有一次的运行结果还挺不错！但怎么我感觉他的发挥不是很稳定啊？他是在瞎蒙吧？</p>
<p>好，那我们最后上场的是4号选手10-神经元网络。4号选手可谓是受到万众的期待啊。据说，他有着“二维点分类小丸子”的称号，让我们来看一看他的表现:</p>
<p><img src="/2022/05/23/DLS-note-3/10.jpg" alt></p>
<p><img src="/2022/05/23/DLS-note-3/11.jpg" alt></p>
<p>只见4号网络手起刀落，刀刀见血。不论是怎么运行程序，他都能精准无误地把点集正确分类。我宣布，他就是本届点集分类大赛的冠军！让我们祝贺他！</p>
<p>程序里很多超参数是可调的，数据集也是可以随意修改的。欢迎大家去使用<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/ShallowNetwork">本课的代码</a>，比较一下不同的神经网络。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这节课的编程练习后，大家应该掌握以下编程技能：</p>
<ul>
<li>编写单隐层神经网络的正向传播</li>
<li>编写单隐层神经网络的反向传播</li>
<li>正确初始化神经网络的参数</li>
<li>常见激活函数及其导数的实现</li>
</ul>
<p>此外，通过浏览我的项目，大家应该能够提前学到以下技能：</p>
<ul>
<li>在神经网络中使用<strong>缓存</strong>的方法保存数据</li>
</ul>
<p>当然，我相信我的项目里还展示了许多编程技术。这些技能严格来说不在本课程的要求范围内，大家可以自行体悟。</p>
<h1 id="附赠内容"><a href="#附赠内容" class="headerlink" title="附赠内容"></a>附赠内容</h1><h2 id="如何画激活函数"><a href="#如何画激活函数" class="headerlink" title="如何画激活函数"></a>如何画激活函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<p>先导入第三方库。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tanh</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (np.exp(x) - np.exp(-x)) / (np.exp(x) + np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.maximum(x, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leaky_relu</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.maximum(x, <span class="number">0.1</span> * x)</span><br></pre></td></tr></table></figure>
<p>再定义好激活函数的公式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">100</span>)</span><br><span class="line">y1 = sigmoid(x)</span><br><span class="line">y2 = tanh(x)</span><br><span class="line">y3 = relu(x)</span><br><span class="line">y4 = leaky_relu(x)</span><br></pre></td></tr></table></figure>
<p>画函数，其实就是生成函数上的一堆点，再把相邻的点用直线两两连接起来。为了生成函数上的点，我们先用<code>np.linspace(-3, 3, 100)</code>生成100个位于[-3, 3]上的x坐标值，用这些x坐标值算出每个函数的y坐标值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.axvline(x=<span class="number">0</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plt.axhline(y=<span class="number">0</span>, color=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plt.plot(x, y1)</span><br><span class="line">plt.title(<span class="string">&#x27;sigmoid&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>之后就是调用API了。这里只展示一下sigmoid函数是怎么画出来的。<code>plt.subplot(a, b, c)</code>表示你要在一个a <em>x</em> b的网格里的第c个格子里画图。 <code>plt.axvline(x=0, color=&#39;k&#39;) plt.axhline(y=0, color=&#39;k&#39;)</code>用于生成x,y轴，<code>plt.plot(x, y1)</code>用于画函数曲线，<code>plt.title(&#39;sigmoid&#39;)</code>用于给图像写标题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>用类似的方法画完所有函数后，调用<code>plt.show()</code>把图片显示出来就大功告成了。</p>
<p>这段代码的链接：<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/blob/master/dldemos/ShallowNetwork/plot_activation_func.py">https://github.com/SingleZombie/DL-Demos/blob/master/dldemos/ShallowNetwork/plot_activation_func.py</a></p>
<p>学API本身没有任何技术含量，知道API能做什么，有需求的时候去查API用法即可。</p>
<h2 id="画花"><a href="#画花" class="headerlink" title="画花"></a>画花</h2><p>看完上面的内容，有些人肯定会想：“诶，你数据集里那朵花画得挺不错啊，你是不是学过美术的啊？”嘿嘿，你们能这么想，我很荣幸。其实那朵花是用程序生成出来的。作为笔记的赠品，我打算顺手介绍一下该怎么用高中知识画出前面的那朵花。</p>
<p>代码文件：<code>dldemos/ShallowNetwork/genereate_points.py</code></p>
<h3 id="流程一览"><a href="#流程一览" class="headerlink" title="流程一览"></a>流程一览</h3><p><img src="/2022/05/23/DLS-note-3/12.jpg" alt></p>
<p>这幅图足以概括花朵绘制的流程。</p>
<ol>
<li>生成半个椭圆。</li>
<li>合成完整的椭圆。</li>
<li>把椭圆移到x正半轴。</li>
<li>复制、旋转椭圆。</li>
</ol>
<p>有人会说：“这前三步可以用一步就完成吧？你直接生成一个在x正半轴上的椭圆就好了，干嘛要拆开来？”别急，看了后文你就知道了。我这么做，完全是为了多展示一点知识，可谓是用心良苦啊。</p>
<h3 id="画半个椭圆"><a href="#画半个椭圆" class="headerlink" title="画半个椭圆"></a>画半个椭圆</h3><p><img src="/2022/05/23/DLS-note-3/13.jpg" alt></p>
<p>椭圆的公式是$\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$，其中$a$是椭圆在x轴上的轴长，$b$是在y轴上的轴长。我画的椭圆的长轴为20，短轴为10，其形状和公式如图所示。</p>
<p>但程序可不认得这个公式。为了生成椭圆上的点，我们可以遍历横坐标x，用公式$y=b\sqrt{1-\frac{x^2}{a^2}}$算出对应的y坐标。</p>
<p>这段生成半椭圆的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">half_oval</span>(<span class="params">cnt, h=<span class="number">10</span>, w=<span class="number">20</span></span>):</span></span><br><span class="line">    x = np.linspace(-w, w, cnt)</span><br><span class="line">    y = np.sqrt(h * h * (<span class="number">1</span> - x * x / w / w))</span><br><span class="line">    <span class="keyword">return</span> np.stack((x, y), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">petal1 = half_oval(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p><code>hafl_ovel</code>的参数分别表示椭圆上点的数量、y轴上轴长、x轴上轴长。根据刚刚的理论分析，我们在第二、三行算出所有点的x, y坐标。第四行用<code>np.stack((x, y), 1)</code>把坐标合并起来。</p>
<p>这里要介绍一下<code>stack</code>函数的用法。<code>stack</code>用于把多个张量（第一个参数）按某一维（第二个参数）堆叠起来。第一个参数很好理解，而第二个参数“堆叠的维度”就不是那么好理解了。让我们针对这份代码，看两个取不同维度的例子。</p>
<p>在我们这份代码中，执行完第二、三行后，<code>x</code>是<code>[x1, x2 ..., xn]</code>这样一个形状为<code>[n]</code>的向量，<code>y</code>也是<code>[y1, y2 ..., yn]</code>这样一个形状为<code>[n]</code>的向量。</p>
<p>当堆叠维度取0时，<code>x</code>会变成<code>[[x1, x2, ..., xn]]([1, n])</code>的矩阵，<code>y</code>会变成<code>[[y1, y2, ..., yn]]([1, n])</code>的矩阵。之后，两个矩阵的第一维会拼起来，变成<code>[[x1, x2, ..., xn], [y1, y2, ..., yn]]</code>这样一个形状为<code>[2, n]</code>的矩阵。</p>
<p>当堆叠维度取1时，<code>x</code>会变成<code>[[x1], [x2], ..., [xn]]([n, 1])</code>的矩阵，<code>y</code>会变成<code>[[y1], [y2], ..., [yn]]([n, 1])</code>的矩阵。之后，两个矩阵的第二维会拼起来，变成<code>[[x1, y1], [x2, y2]..., [xn, yn]]</code>这样一个形状为<code>[n, 2]</code>的矩阵。</p>
<p>我们希望生成一个坐标的数组，即形状为<code>[n 2]</code>的矩阵。因此，我们会堆叠维度1（第二个维度），即使用如下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.stack((x, y), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>总之，经过以上操作，<code>half_oval</code>会返回一个形状为<code>[n, 2]</code>的坐标数组，表示半个花瓣上每个点的坐标。</p>
<h3 id="翻转合并椭圆"><a href="#翻转合并椭圆" class="headerlink" title="翻转合并椭圆"></a>翻转合并椭圆</h3><p>要把半椭圆垂直翻转,实际上只要令半椭圆上所有点的y坐标取反即可：</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
   x &\gets x \\ 
   y &\gets -y
\end{aligned}
\right.</script><p>但是，这种写法不够高级。我们可以写成矩阵乘法的形式：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\left[
\begin{aligned}
   &x  \\
   &y  
\end{aligned}
\right] \gets
\left[
\begin{aligned}
   &1  &0 \\
   &0  &-1
\end{aligned}
\right] \times
\left[
\begin{aligned}
   &x  \\
   &y  
\end{aligned}
\right] \\
\Rightarrow&\left[
\begin{aligned}
   &x  \\
   &y  
\end{aligned}
\right] \gets

\left[
\begin{aligned}
   x  \\
   -y  
\end{aligned}
\right]
\end{align*}</script><blockquote>
<p>如果你对矩阵乘法不熟，只需要知道</p>
<script type="math/tex; mode=display">
\left[
\begin{aligned}
   &a  &b \\
   &c  &d
\end{aligned}
\right] \times
\left[
\begin{aligned}
   &x  \\
   &y  
\end{aligned}
\right]=
\left[
\begin{aligned}
   &ax+by  \\
   &cx+dy  
\end{aligned}
\right]</script></blockquote>
<p>设翻转矩阵为$F$，坐标向量为$p$，则翻转后的向量$p’$可以写成：</p>
<script type="math/tex; mode=display">
p'=Fp</script><p>这里我们默认$p$和$p’$都是列向量。但是，刚刚我们生成点的坐标时，每个坐标都是一个行向量。也就是说，$p$和$p’$其实都是行向量。因此，上式应该改成：</p>
<script type="math/tex; mode=display">
p'^T=Fp^T</script><p>最后我们要算的是$p’$，因此可以对上式两边再取转置：</p>
<script type="math/tex; mode=display">
\begin{align*}
p'&=(Fp^T)^T \\
&=pF^T
\end{align*}</script><p>有了这些数学上的分析，我们可以写代码了。</p>
<p>首先是生成翻转矩阵：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vertical_flip</span>():</span></span><br><span class="line">    <span class="keyword">return</span> np.array([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]])</span><br></pre></td></tr></table></figure>
<p>之后生成翻转后的花瓣：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">petal2 = np.dot(half_oval(<span class="number">20</span>), vertical_flip().T)</span><br></pre></td></tr></table></figure></p>
<p>现在，我们有开始得到的<code>petal1</code>和翻转后的<code>petal2</code>，它们的形状都是<code>[n, 2]</code>。我们希望把这两个坐标数组合并起来。这可以通过下面这行代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">petal = np.concatenate((petal1, petal2), <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><code>concatenate</code>用于按某一维（第二个参数）拼接张量（第一个参数）。回顾一下，刚刚的半椭圆张量的形状<code>[n, 2]</code>表示有<code>n</code>个<code>2</code>维坐标。合并两个半椭圆后，我们应该得到<code>2n</code>个点，即得到一个形状为<code>[2n, 2]</code>的张量。因此，这里我们要把两个半椭圆数组按第一维（<code>0</code>号维度）拼接。</p>
<p><code>concatenate</code>和刚刚提到的<code>stack</code>有点像。其实，<code>stack</code>就是新建了一个维度，再做<code>concatenate</code>操作。<code>stack</code>一般由于把单独计算出来的<code>x, y, z</code>这样的坐标堆叠成一个坐标数组/坐标张量，<code>concatenate</code>一般用于合并多个性质一样的张量，比如这里的合并两个坐标数组。</p>
<h3 id="移动椭圆"><a href="#移动椭圆" class="headerlink" title="移动椭圆"></a>移动椭圆</h3><p>移动椭圆很简单，只要给所有坐标加同一个向量就行了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">petal += [<span class="number">25</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>注意，这里的<code>petal</code>是一个形状为<code>[2n, 2]</code>的张量，而<code>[25, 0]</code>是一个形状为<code>[2]</code>的张量。这一个逐元素的加法操作之所以能够被程序正常解读，是因为上周提到的“广播”操作。通过使用广播，<code>[25, 0]</code>这个向量被加到了坐标数组中的每一个坐标里。</p>
<h3 id="旋转花瓣，生成花朵"><a href="#旋转花瓣，生成花朵" class="headerlink" title="旋转花瓣，生成花朵"></a>旋转花瓣，生成花朵</h3><p><img src="/2022/05/23/DLS-note-3/14.jpg" alt></p>
<p>如上图1所示，一个坐标$(x, y)$可以用它到原点的距离$r$和与x正半轴夹角$\theta$表示：</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
   x = r \cdot cos\theta \\
   y = r \cdot sin\theta
\end{aligned}
\right.</script><p>那么，如上图2所示，假设现在把一个夹角为$\theta$的$(x_1, y_1)$旋转$\alpha$后得到了$(x_2, y_2)$，$(x_2, y_2)$可以表示为:</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
   x_2 = r \cdot cos(\theta+\alpha) \\
   y_2 = r \cdot sin(\theta+\alpha)
\end{aligned}
\right.</script><p>但是，我们现在只知道$(x_1, y_1)$这个坐标。给定$x_1, y_1, \alpha$，该怎么计算出$x_2, y_2$呢？</p>
<p>这里，我们可以用高中学过的三角函数两角和公式，把刚才那个三角函数“拆开”：</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
   x_2 &= r \cdot cos(\theta+\alpha) \\
   &= r(cos \theta cos\alpha - sin \theta sin\alpha)\\
   y_2 &= r \cdot sin(\theta+\alpha) \\
   &= r(sin \theta cos\alpha + cos \theta sin\alpha)
\end{aligned}
\right.</script><p>我们又已知：</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
   x_1 = r \cdot cos\theta \\
   y_1 = r \cdot sin\theta
\end{aligned}
\right.</script><p>因此，$x_2, y_2$可以用下面的式子表示：</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
   x_2 &= r(cos \theta cos\alpha - sin \theta sin\alpha)\\
   &= cos\alpha \cdot x_1 - sin\alpha \cdot y_1\\
   y_2 &= r(sin \theta cos\alpha + cos \theta sin\alpha) \\
   &= cos\alpha \cdot y_1 + sin\alpha \cdot x_1
\end{aligned}
\right.</script><p>这个式子用矩阵乘法表达如下：</p>
<script type="math/tex; mode=display">
\left[
\begin{aligned}
   &x_2  \\
   &y_2  
\end{aligned}
\right]=
\left[
\begin{aligned}
   &cos\alpha  &-sin\alpha \\
   &sin\alpha  &cos\alpha
\end{aligned}
\right] \times
\left[
\begin{aligned}
   &x_1  \\
   &y_2  
\end{aligned}
\right]</script><p>也就是说，旋转操作也可以用一个矩阵表示。我们可以用和刚刚做翻转操作相同的办法，对坐标数组做旋转。以下是代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">theta</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.array([[np.cos(theta), -np.sin(theta)],</span><br><span class="line">                     [np.sin(theta), np.cos(theta)]])</span><br></pre></td></tr></table></figure>
<p>这个函数可以生成一个让坐标旋转<code>theta</code>弧度的矩阵。</p>
<p>这样，我们如果想让一个坐标数组旋转60度，可以写下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_petal = np.dot(petal, rotate(np.radians(<span class="number">60</span>)).T)</span><br></pre></td></tr></table></figure>
<p>在生成花朵时，我们除了生成第一片花瓣外，还要通过旋转生成另外5朵花瓣，并把花瓣合并起来。这整个流程的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">petal1 = half_oval(<span class="number">20</span>)</span><br><span class="line">petal2 = np.dot(half_oval(<span class="number">20</span>), vertical_flip().T)</span><br><span class="line">petal = np.concatenate((petal1, petal2), <span class="number">0</span>)</span><br><span class="line">petal += [<span class="number">25</span>, <span class="number">0</span>]</span><br><span class="line">flower = petal.copy()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    new_petal = np.dot(petal.copy(), rotate(np.radians(<span class="number">60</span>) * (i + <span class="number">1</span>)).T)</span><br><span class="line">    flower = np.concatenate((flower, new_petal), <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以给每个坐标打上0或1的标签，0表示点是红色，1表示点是绿色。然后，我们把各个花瓣染成不同的颜色：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">label = np.zeros([<span class="number">40</span> * <span class="number">6</span>])</span><br><span class="line">label[<span class="number">0</span>:<span class="number">40</span>] = <span class="number">1</span></span><br><span class="line">label[<span class="number">40</span>:<span class="number">80</span>] = <span class="number">1</span></span><br><span class="line">label[<span class="number">120</span>:<span class="number">160</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>再做一些操作就可以用<code>matplotlib</code>画出花朵了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = flower[:, <span class="number">0</span>]</span><br><span class="line">y = flower[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">c = np.where(label == <span class="number">0</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.scatter(x, y, c=c)</span><br><span class="line"></span><br><span class="line">plt.xlim(-<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line">plt.ylim(-<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="在数据中加入噪声"><a href="#在数据中加入噪声" class="headerlink" title="在数据中加入噪声"></a>在数据中加入噪声</h3><p>大家可以发现，我生成的花朵数据中，有几个点的颜色“不太对劲”。这是为了模拟训练数据中的噪声数据。让我们看看这些噪声是怎么添加的。</p>
<p>为了让部分数据的标签出错，我们只需要随机挑选出一些数据，然后令它们的标签取反（0变1，1变0）即可。这里涉及一个问题：该怎样从n个数据中随机挑选出若干个数据呢？</p>
<p>在我项目中，我使用的方法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> default_rng</span><br><span class="line"></span><br><span class="line">rng = default_rng()</span><br><span class="line">noise_indice1 = rng.choice(<span class="number">40</span> * <span class="number">6</span>, <span class="number">10</span>, replace=<span class="literal">False</span>)</span><br><span class="line">label[noise_indice1] = <span class="number">1</span> - label[noise_indice1]</span><br></pre></td></tr></table></figure></p>
<p>生成随机数需要一个随机数生成器。这里我用<code>rng = default_rng()</code>生成了一个默认的随机数生成器，它从<strong>均匀分布</strong>生成随机数。</p>
<p><code>noise_indice1 = rng.choice(40 * 6, 10, replace=False)</code>用于生成多个不重复的随机数。<code>rng.choice</code>的第一个参数<code>40*6</code>表示生成出来的随机数位于区间[1, 40*6]。第二个参数<code>10</code>表示生成10个随机数。<code>replace=False</code>表示生成的随机数不重复。</p>
<p>最后，我们用<code>label[noise_indice1] = 1 - label[noise_indice1]</code>把随机选中的标签取反。</p>
<h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>我很早之前就在计划如何构建我的个人IP。没想到，从上周日开始，我不知不觉地开始认真地在公开渠道上发文章了。</p>
<p>发完文章后，我其实抱有很大的期待，希望能有很多人来读我的文章（哪怕是早已养成了不以他人的评价来评价自己的我，也不能免俗）。很可惜，文章似乎并不是很受欢迎。</p>
<p>还好我有着强大的自信心，心态一点也不受影响。首先，我自己有着强大的鉴别能力，在我自己来看，我的文章水准不低；其次，我的部署教程经 OpenMMLab 发表，受到了不少赞誉，客观上证明我当前的写作水平很强。文章不受欢迎，肯定另有原因。</p>
<p>首先，是我现在没有曝光度。这是当然的，毕竟我之前一点名气也没有，平台并不会去推荐你的文章，能够接触到你文章的人本来就少。另外，我的文章十分冗长，用我自己的话来讲，“根本不是给人来看的”（本来写文章的目的就是为了总结我自己的学习心得，提升我的学习效果）。虽然认真读起来，其实还可以，但几乎没有人有足够的动力去把我这些文章认真读完。</p>
<p>这两个问题，我都会去想办法解决。曝光度的问题我已经想好了办法，在这里就不提了。而第二点，文章可读性这点，对现在的我来说非常好解决。说实话，我不是写不出大家很愿意去读的文章，而是不愿写。如果你想去迎合他人的体验，那你肯定要付出额外的心血。我现在的主业是学习，不是搞自媒体，我之前比较高傲，懒得去把文章写得更加适合大部分人群阅读。但是，现在，我生气了，我认真了，我很不服气。我不是做不好，而是没有去做。我一旦出手，必定是一鸣惊人。</p>
<p>从这周开始，我的博客只发笔记原稿。发到其他平台上时，我会做一定的修改，使之阅读体验更好。</p>
<p>最可怕的是，我还是不会花大量的时间去讨好读者，我还是会保证我的学习工作不受影响。我会拿出我的真实实力，真正的人性洞察能力，真正的时间分配能力，真正的权衡利弊的能力，以最高效率生产出质量优秀的文章。以我这些精心写作的博客原稿为基础，我有自信生产出大量有趣、有深度的文章。我靠这些文字火不起来，可以理解，因为认真愿意去学深度学习的人，没有那么多。但是，我有足够的信心，我认为我的文章一定会受到很多人的好评。</p>
<p>另外，我刚刚是承认我仅凭这些深度学习教程文章是火不起来的。但我并没有承认我的个人IP火不起来。究竟我之后还会干出哪些大事？我这里不讲，且看历史是怎么发展的。</p>
<hr>
<p>嘿嘿嘿，为了准备之后的编程实况解说，我这一课的编程是一边在录制一边编的。结果我发挥超神，3小时左右就把这一课代码写完了，其中实现逻辑回归和通用分类器框架花了40分钟，实现神经网络花了20分钟，剩下时间都在捣鼓Numpy API，在可视化网络的输出结果。可以说我的编程水平相比普通人已经登峰造极了。但我还会继续精进我的编程技术，直至出神入化，神鬼莫及的境界。</p>
<p>顺带一提，第一次编写一个程序的直播是没有节目效果的。你大部分时间都会花在思考上，你脑子里想的东西是无法即时传递给观众的。哪怕是搞节目效果能力这么强的我，录出来的视频也不太好看。要做编程教学视频，必须要提前写一遍代码，第二次重新编同一段程序的时候，才有可能游刃有余地解说。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/05/10/DLS-note-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/10/DLS-note-2/" class="post-title-link" itemprop="url">吴恩达《深度学习专项》笔记+代码实战（二）：简单的神经网络——逻辑回归</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-10 17:16:34" itemprop="dateCreated datePublished" datetime="2022-05-10T17:16:34+08:00">2022-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这堂课要学习的是逻辑回归——一种求解二分类任务的算法。同时，这堂课会补充实现逻辑回归必备的数学知识、编程知识。学完这堂课后，同学们应该能够用Python实现一个简单的小猫辨别器。</p>
<h1 id="学习提示"><a href="#学习提示" class="headerlink" title="学习提示"></a>学习提示</h1><p><img src="/2022/05/10/DLS-note-2/preface.png" alt></p>
<p>如上图所示，深度学习和编程，本来就是相对独立的两块知识。</p>
<p>深度学习本身的知识包括数学原理和实验经验这两部分。深度学习最早来自于数学中的优化问题。随着其结构的复杂化，很多时候我们解释不清为什么某个模型性能更高，只能通过重复实验来验证模型的有效性。因此，深度学习很多情况下变成了一门“实验科学”。</p>
<p>深度学习中，只有少量和编程有关系的知识，比如向量化计算、自动求导器等。得益于活跃的开源社区，只要熟悉了这些少量的编程技巧，人人都可以完成简单的深度学习项目。但是，真正想要搭建一个实用的深度学习项目，需要完成大量“底层”的编程工作，要求开发者有着广泛的编程经验。</p>
<p>通过上吴恩达老师的课，我们应该能比较好地掌握深度学习的数学原理，并且了解深度学习中少量的编程知识。而广泛的编程经验、修改模型的经验，这些都是只上这门课学不到的。</p>
<p>获取修改模型的经验这项任务过于复杂，不太可能短期学会，几乎可以作为研究生的课题了。而相对而言，编程的经验就很好获得了。</p>
<p>我的系列笔记会补充很多编程实战项目，希望读者能够通过完成类似的编程项目，在学习课内知识之余，提升广义上的编程能力。比如在这周的课程里，我们会用课堂里学到的逻辑回归从头搭建一个分类器。</p>
<h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h2 id="本节课的目标"><a href="#本节课的目标" class="headerlink" title="本节课的目标"></a>本节课的目标</h2><p>在这节课里，我们要完成一个二分类任务。所谓二分类任务，就是给一个问题，然后给出一个“是”或“否”的回答。比如给出一张照片，问照片里是否有一只猫。</p>
<p>这节课中，我们用到的方法是逻辑回归。逻辑回归可以看成是一个非常简单的神经网络。</p>
<h3 id="符号标记"><a href="#符号标记" class="headerlink" title="符号标记"></a>符号标记</h3><p>从这节课开始，我们会用到一套统一的符号标记：</p>
<p>$(x, y)$ 是一个训练样本。其中，$x$ 是一个长度为 $n_x$ 的一维向量，即 $x \in \mathcal{R}^{n_x}$。$y$ 是一个实数，取0或1，即$y \in {0, 1}$。取0表示问题的的答案为“否”，取1表示问题的答案为“是”。</p>
<blockquote>
<p>这套课默认读者对统计机器学习有基本的认识，似乎没有过多介绍训练集是什么。在有监督统计机器学习中，会给出<strong>训练数据</strong>。训练数据中的每一条<strong>训练样本</strong>包含一个“问题”和“问题的答案”。神经网络根据输入的问题给出一个自己的解答，再和正确的答案对比，通过这样一个“学习”的过程来优化解答能力。</p>
<p>对计算机知识有所了解的人会知道，在计算机中，颜色主要是通过RGB（红绿蓝）三种颜色通道表示。每一种通道一般用长度8位的整数表示，即用一个0~255的数表示某颜色在红、绿、蓝上的深浅程度。这样，一个颜色就可以用一个长度为3的向量表示。一幅图像，其实就是许多颜色的集合，即许多长度为3的向量的集合。颜色通道，再算上某颜色所在像素的位置$(x, y)$，图像就可以看成一个3维张量$I \in \mathcal{R}^{H \times W \times 3}$，其中$H$是图像高度，$W$是图像宽度，$3$是图像的通道数。在把图像输入逻辑回归时，我们会把图像“拉直”成一个一维向量。这个向量就是前面提到的网络输入$x$，其中$x$的长度$n_x$满足$n_x = H \times W \times 3$。这里的“拉直”操作就是把张量里的数据按照顺序一个一个填入新的一维向量中。</p>
<p>其实向量就是一维的，但我还是很喜欢强调它是“一维”的。这是因为在计算机中所有数据都可以看成是数组（甚至C++的数组就叫<code>vector</code>)。二维数组不过是一维数组的数组，三位数组不过是二维数组的数组。在数学中，为了方便称呼，把一维数组叫“向量”，二维数组叫“矩阵”，三维及以上数组叫“张量”。其实在我看来它们之间只是一个维度的差别而已，叫“三维向量”、“一维张量”这种不是那么严谨的称呼也没什么问题。</p>
</blockquote>
<p>实际上，我们有很多个训练样本。样本总数记为$m$。第$i$个训练样本叫做$(x^{(i)}, y^{(i)})$。在后面使用其他标记时，也会使用上标$(i)$表示第$i$个训练样本得到的计算结果。</p>
<p>所有输入数据的集合构成一个矩阵（其中每个输入样本用<strong>列向量</strong>的形式表示，这是为了方便计算机的计算）：</p>
<script type="math/tex; mode=display">
X=\left[
  \begin{matrix}
  | & | & & | \\
  x^{(1)} & x^{(2)} & ... & x^{(m)} \\
  | & | & & |
  \end{matrix}
\right]
,X \in \mathcal{R}^{n_x \times m}</script><p>同理，所有真值也构成集合 $Y$:</p>
<script type="math/tex; mode=display">
Y=\left[
  \begin{matrix}
  y^{(1)} & y^{(2)} & ... & y^{(m)} 
  \end{matrix}
\right]
,Y \in \mathcal{R}^{m}</script><p>由于每个样本$y^{(i)}$是一个实数，所以集合$Y$是一个向量。</p>
<h2 id="逻辑回归的公式描述"><a href="#逻辑回归的公式描述" class="headerlink" title="逻辑回归的公式描述"></a>逻辑回归的公式描述</h2><p>逻辑回归是一个学习算法，用于对真值只有0或1的“逻辑”问题进行建模。给定输入$x$,逻辑回归输出一个$\hat{y}$。这个$\hat{y}$是对真值$y$的一个估计，准确来说，它描述的是$y=1$的概率，即$\hat{y}=P(y=1 \ | \ x)$</p>
<p>逻辑回归会使用一个带参数的函数计算$\hat{y}$。这里的参数包括$w \in \mathcal{R}^{n_x}, b \in \mathcal{R}$。</p>
<p>说起用于拟合的函数，最容易想到的是线性函数$w^Tx+b$（即做点乘再加$b$： $w^Tx+b = (\Sigma_{i=1}^{n_x}w_ix_i)+b $）。但线性函数的值域是$(- \infty,+\infty) $（即全体实数$\mathcal{R}$），概率的取值是$[0, 1]$。我们还需要一个定义域为$\mathcal{R}$，值域为$[0, 1]$，把线性函数映射到$[0, 1]$上的一个函数。</p>
<p>逻辑回归中，使用的映射函数是sigmoid函数$\sigma$,它的定义为：</p>
<script type="math/tex; mode=display">\sigma(z)=\frac{1}{1 + e^{-z}}</script><p>这个函数可以有效地完成映射，它的函数图像长这个样子：</p>
<p><img src="/2022/05/10/DLS-note-2/0.png" alt></p>
<blockquote>
<p>这里不用计较为什么使用这个函数，只需要知道这个函数的趋势：$x$越小，$\sigma (x)$越靠近0；$x$越大，$\sigma (x)$越靠近1。</p>
</blockquote>
<p>也就是说，最终的逻辑回归公式长这个样子：$\hat{y} = \sigma(w^Tx+b)$。</p>
<h2 id="逻辑回归的损失函数（Cost-Function）"><a href="#逻辑回归的损失函数（Cost-Function）" class="headerlink" title="逻辑回归的损失函数（Cost Function）"></a>逻辑回归的损失函数（Cost Function）</h2><p>所有的机器学习问题本质上是一个优化问题，一般我们会定义一个<strong>损失函数（Cost Function）</strong>，再通过优化参数来最小化这个损失函数。</p>
<p>回顾一下我们的任务目标：我们定义了逻辑回归公式$\hat{y} = \sigma(w^Tx+b)$，我们希望$\hat{y}$尽可能和$y$相近。这里的“相近”，就是我们的优化目标。损失函数，可以看成是$y, \hat{y}$间的“距离”。</p>
<p>逻辑回归中，定义了每个输出和真值的<strong>误差函数（Loss Function）</strong>，这个误差函数叫<strong>交叉熵</strong></p>
<script type="math/tex; mode=display">L(\hat{y}, y)=-(y \ log\hat{y} + (1-y) \ log(1-\hat{y}))</script><p>不使用另一种常见的误差函数<strong>均方误差</strong>的原因是，交叉熵较均方误差梯度更加平滑，更容易在之后的优化中找到全局最优解。</p>
<p><strong>误差函数</strong>是定义在每个样本上的，而<strong>损失函数</strong>是定义在整个样本上的，表示所有样本误差的“总和”。这个“总和”其实就是平均值，即损失函数$J(w, b)$为:</p>
<script type="math/tex; mode=display">J(w, b)=\frac{1}{m}\Sigma_{i=1}^{m}-(y^{(i)} \ log\hat{y}^{(i)} + (1-y^{(i)}) \ log(1-\hat{y}^{(i)}))</script><h2 id="优化算法——梯度下降"><a href="#优化算法——梯度下降" class="headerlink" title="优化算法——梯度下降"></a>优化算法——梯度下降</h2><p>有了优化目标，接下来的问题就是如何用优化算法求出最优值。这里使用的是<strong>梯度下降（Gradient Descent）</strong> 法。梯度下降的思想很符合直觉：如果要让函数值更小，就应该让函数的输入沿着函数值下降最快的方向（梯度的方向）移动。</p>
<p>以课件中的一元函数为例：</p>
<p><img src="/2022/05/10/DLS-note-2/1.png" alt></p>
<p>一元函数的梯度值就是导数值，方向只有正和负两个方向。我们要根据每个点的导数，让每个点向左或向右“运动”，以使函数值更小。</p>
<p>从图像里可以看出，如果是参数最开始在A点，则往右走函数值才会变少；反之，对于B点，则应该往左移动。</p>
<p>每个点都应该向最小值“一小步一小步”地移动，直至抵达最低点。为什么要“一小步”移动呢？可以想象，如果一次移动的“步伐”过大，改变参数不仅不会让优化函数变小，甚至会让待优化函数变大。比如从A点开始，同样是往右移动，如果“步伐”过大，A点就会迈过最低点的红点，甚至跑到B点的上面。那么这样下去，待优化函数会越来越大，优化就失败了。</p>
<p>为了让优化能顺利进行，梯度下降法使用<strong>学习率（Learning Rate)</strong> 来控制参数优化的“步伐”，即用如下方法更新损失函数$J(w)$的参数：</p>
<script type="math/tex; mode=display">
Repeat: \\
w \gets w - \alpha \frac{dJ}{dw}</script><p>这里的 $\alpha$ 就是学习率，它控制了每次梯度更新的幅度。</p>
<p>其实这里还有两个问题：参数$w$该如何初始化；该执行梯度下降多少次。在这个问题中初始化对结果影响不大，可以简单地令$w=0$。而优化的次数没有硬性的需求，先执行若干次，根据误差是否收敛再决定是否继续优化即可。</p>
<h2 id="前置知识补充"><a href="#前置知识补充" class="headerlink" title="前置知识补充"></a>前置知识补充</h2><p>到这里，逻辑回归的知识已经讲完了。让我们梳理一下：</p>
<p>在逻辑回归问题中，我们有输入样本集$X$和其对应的期望输出$Y$，我们希望找到拟合函数$\hat{Y}=w^TX+b$，使得$\hat{Y}$和$Y$尽可能接近，即让损失函数$J(w, b)=mean(-(Ylog\hat{Y}+(1-Y)log(1-\hat{Y})))$尽可能小。</p>
<blockquote>
<p>这里的$X,Y,\hat{Y}$表示的是全体样本。稍后我们会讨论如何用公式表示全体样本的计算。</p>
</blockquote>
<p>我们可以用$0$来初始化所有待优化参数$w, b$，并执行梯度下降</p>
<script type="math/tex; mode=display">
\begin{align*}
w & \gets w - \alpha \frac{dJ}{dw} \\ 
b & \gets b - \alpha \frac{dJ}{db}
\end{align*}</script><p>若干次后得到一个较优的拟合函数。</p>
<p>为了让大家成功用代码实现逻辑回归，这门课贴心地给大家补充了数学知识和编程知识。</p>
<blockquote>
<p>在我的笔记中，补充编程知识的记录会潦草一些。</p>
</blockquote>
<h3 id="求导"><a href="#求导" class="headerlink" title="求导"></a>求导</h3><blockquote>
<p>这部分对中国学生来说十分简单，因为求导公式是高中教材的内容。</p>
</blockquote>
<p>导数即函数每时每刻的变化率，比如位移对时间的导数就是速度。以常见函数为例，对于直线$y=kx$，函数的变化率时时刻刻都是$k$；对于二次函数$y=x^2$，$x$处的导数是$2x$。</p>
<h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p>其实，所有复杂的数学运算都可以拆成计算图表示法。</p>
<p><img src="/2022/05/10/DLS-note-2/2.png" alt></p>
<blockquote>
<p>计算<strong>图</strong>中的”图”其实是一个计算机概念，表示由节点和边组成的集合。不熟悉的话，当成日常用语里的图来理解也无妨。</p>
</blockquote>
<p>比如上图中，哪怕是简单的运算$2a+b$，也可以拆成两步：先算$2 \times a$，再算$(2a) + b$。</p>
<p>这里的“步”指原子运算，即最简单的运算。原子运算可以是加减乘除，也可以是求指数、求对数。复杂的运算，只是对简单运算的组合、嵌套。</p>
<p>明明简简单单可以用一行公式表示的事，要费很大的功夫画一张计算图呢？这是因为，对函数求导满足“链式法则”，借助计算图，可以更方便地用链式法则算出所有参数的导数。比如在上图中要求$f$对$a$的导数，使用链式法则的话，可以通过先求$f$对$c$的导数，再求$c$对$a$的导数得到。</p>
<h3 id="利用计算图对逻辑回归求导"><a href="#利用计算图对逻辑回归求导" class="headerlink" title="利用计算图对逻辑回归求导"></a>利用计算图对逻辑回归求导</h3><p>逻辑回归有计算图：<br><img src="/2022/05/10/DLS-note-2/3.png" alt></p>
<p>现在利用链式法则从右向左求导：</p>
<script type="math/tex; mode=display">
\begin{align*}
z & =  w_1x_1 + w_2x_2 +b \\
a & =  \frac{1}{1+e^{-z}} \\
L & = -(yloga+(1-y)log(1-a)) \\

\frac{dL}{da} & =  -(\frac{y}{a}-\frac{1-y}{1-a}) \\
\frac{da}{dz} & =  \frac{e^{-z}}{(1+e^{-z})^2} = a(1-a)\\
\frac{dL}{dz} & = \frac{dL}{da} \frac{da}{dz} \\
&= -(\frac{y}{a}-\frac{1-y}{1-a}) \times a(1-a) \\
&= -(y(1-a)-(1-y)a) \\
&= -(y-ya-a+ya) \\
&= a-y \\
\frac{dL}{dw_i} &= \frac{dL}{dz}\frac{dz}{dw_i}=(a-y)x_i \\
\frac{dL}{db} &= \frac{dL}{dz}\frac{dz}{db}=(a-y)
\end{align*}</script><blockquote>
<p>这些运算里最难“注意到”的是$\frac{e^{-z}}{(1+e^{-z})^2} = a(1-a)$。</p>
<p>在学计算机科学的知识时，可以适当忽略一些数学证明，把算好的公式直接拿来用，比如这里的$\frac{dL}{dz}=a-y$。</p>
</blockquote>
<p>$\frac{dL}{dw_i}, \frac{dL}{db}$就是我们要的梯度了，用它们去更新原来的参数即可。值得一提的是，这里的梯度是对一个样本而言。对于全部$m$个样本来说，本轮的梯度应该是所有样本的梯度的平均值。后面我们会学习如何对所有样本求导。</p>
<h3 id="Python-向量化计算"><a href="#Python-向量化计算" class="headerlink" title="Python 向量化计算"></a>Python 向量化计算</h3><p>在刚刚的一轮迭代中，我们要用到两次循环：</p>
<ol>
<li>对$m$个样本循环处理</li>
<li>对$n_x$个权重$w_i$与对应的$x_i$相乘</li>
</ol>
<p>直接拿 Python 写这些 for 循环，程序会跑得很慢的，这里最好使用向量化计算。在这一节里我们补充一下 Python 基础知识，下一节介绍怎么用它们实现逻辑回归的向量化实现。</p>
<blockquote>
<p>课程中提到向量化的好处是可以用<strong>SIMD</strong>（单指令多数据流）优化，这个概念可以理解成计算机会同时对16个或32个数做计算。如果输入的数据是向量的话，相比一个一个做for循环，一次算16,32个数的计算速度会更快。</p>
<p>但实际上，除了无法使用SIMD以外，Python的低效也是拖慢速度的原因之一。哪怕是不用SIMD，单纯地用C++的for循环实现向量化计算，都能比用Python的循环快上很多。</p>
</blockquote>
<p>Python 的 numpy 库提供了向量化计算的接口。比如以下是向量化的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.zeros((<span class="number">10</span>)) <span class="comment"># 新建长度为10的向量，值为0</span></span><br><span class="line">b = np.ones((<span class="number">10</span>)) <span class="comment"># 新建长度为10的向量，值为1</span></span><br><span class="line">a = a + b <span class="comment"># 10个数同时做加法</span></span><br><span class="line">a = np.exp(a) <span class="comment"># 对10个数都做指数运算</span></span><br></pre></td></tr></table></figure>
<p>numpy 允许一种叫做“广播”的操作，这种操作能够完成不同形状数据间的运算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones(<span class="number">10</span>) <span class="comment"># a的形状:[10]</span></span><br><span class="line">k = np.array([<span class="number">3</span>]) <span class="comment"># 用列表[3]新建张量，k的形状:[1]</span></span><br><span class="line">a = k * a <span class="comment"># 广播</span></span><br></pre></td></tr></table></figure>
<p>这里k的shape为<code>[1]</code>，a的shape为<code>[10]</code>。用k乘a，实际上就是令<code>a[i] = k[0] * a[i]</code>。也就是说，<code>k[0]</code>“广播”到了<code>a</code>的每一个元素上。</p>
<p>有一种快速理解广播的方法：可以认为k的形状从<code>[1]</code>变成了<code>[10]</code>，再让k和a逐个元素做乘法。</p>
<p>同理，如果用一个<code>a[x, y]</code>的矩阵加一个<code>b[x, 1]</code>的矩阵，实际上是做了下面的运算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(y):</span><br><span class="line">    a[i, j] = a[i, j] + b[i, <span class="number">0</span>] </span><br></pre></td></tr></table></figure></p>
<p>用刚刚介绍的方法来理解，可以认为<code>b</code>从<code>[x, 1]</code>扩充成了<code>[x, y]</code>，再和<code>a</code>做逐个元素的加法运算。</p>
<h2 id="向量化计算前向和反向传播"><a href="#向量化计算前向和反向传播" class="headerlink" title="向量化计算前向和反向传播"></a>向量化计算前向和反向传播</h2><p>现在，有了求导的基础知识和向量化计算的基础知识，让我们来写一下如何用矩阵表示逻辑回归中的运算，并用Python代码描述这些计算过程。</p>
<p>单样本的正向传播：</p>
<script type="math/tex; mode=display">
\hat{y} = a=\sigma(w^Tx+b)</script><p>推广到多样本：</p>
<script type="math/tex; mode=display">
\hat{Y} = A=\sigma(w^TX+b)</script><p>这里的$X, A, \hat{Y}$是把原来单样本的列向量$x_i, \hat{y}_i$横向堆叠起来形成的矩阵，即:</p>
<script type="math/tex; mode=display">
[\hat{y_1}, ..., \hat{y_m}] = \sigma([w^Tx_1+b, ..., w^Tx_m+b])</script><p>单样本反向传播：</p>
<script type="math/tex; mode=display">
\begin{align*}
dz &= a-y \\
dw_i &= dz \cdot x_i \\
dw &= \left[
  \begin{matrix}
  dw_1 \\
  ... \\
  dw_{n_x} 
  \end{matrix}
\right] =
\left[
  \begin{matrix}
  dz \cdot x_1\\
  ... \\
  dz \cdot x_{n_x}
  \end{matrix}
\right]=dz \ast x\\
db &= dz 
\end{align*}</script><blockquote>
<p>$dz$ 是 $\frac{dJ}{dz}$的简写，其他变量同理。编程时也按同样的方式命名。</p>
<p>所有的$\ast$都表示逐元素乘法。比如$[1, 2, 3] \ast [1, 2, 3]=[1, 4, 9]$。$\ast$满足前面提到的广播，比如$[2] \ast [1, 2, 3]=[2, 4, 6]$。 </p>
</blockquote>
<p>多样本反向传播：</p>
<script type="math/tex; mode=display">
\begin{align*}
dZ &= A-Y \\
dw_i &=  X_i dZ^T = dz^{(1)}x_i^{(1)} +  ... +  dz^{(m)}x_i^{(m)} \\
dw &=  \frac{1}{m} \left[
  \begin{matrix}
  dw_1 \\
  ... \\
  dw_{n_x} 
  \end{matrix}
\right]=\frac{1}{m}\left[
  \begin{matrix}
  dz^{(1)}x_1^{(1)} + &...& + dz^{(m)}x_1^{(m)}\\
  ... &...& ...\\
  dz^{(1)}x_{n_x}^{(1)} + &...& +dz^{(m)}x_{n_x}^{(m)} 
  \end{matrix}
\right]\\
&= \frac{1}{m}XdZ^T\\
db &= \frac{1}{m} \Sigma_{i=1}^m dZ^{(i)} 
\end{align*}</script><p>用代码描述多样本前向传播和反向传播就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z = np.dot(w.T, x)+b</span><br><span class="line">A = sigmoid(Z)</span><br><span class="line">dZ = A-Y</span><br><span class="line">dw = np.dot(X, dZ.T) / m</span><br><span class="line">db = np.mean(dZ)</span><br><span class="line"><span class="comment"># db=np.sum(dZ) / m</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>np.dot</code>实现了求向量内积或矩阵乘法，<code>np.sum</code>实现了求和，<code>np.mean</code>实现了求均值。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这堂课的主要知识点有：</p>
<ul>
<li>什么是二分类问题。</li>
<li>如何对建立逻辑回归模型。<ul>
<li>Sigmoid 函数 $\sigma(z)=\frac{1}{1 + e^{-z}}$</li>
</ul>
</li>
<li>误差函数与损失函数<ul>
<li>逻辑回归的误差函数：$L(\hat{y}, y)=-(y \ log\hat{y} + (1-y) \ log(1-\hat{y}))$</li>
</ul>
</li>
<li>用梯度下降算法优化损失函数</li>
<li>计算图的概念及如何利用计算图算梯度</li>
</ul>
<p>学完这堂课后，应该掌握的编程技能有：</p>
<ul>
<li>了解numpy基本知识<ul>
<li>resize</li>
<li>.T</li>
<li>exp</li>
<li>dot</li>
<li>mean, sum</li>
</ul>
</li>
<li>用numpy做向量化计算</li>
<li>实现逻辑回归<ul>
<li>对输入数据做reshape的预处理</li>
<li>用向量化计算算$\hat{y}$及参数的梯度</li>
<li>迭代优化损失函数</li>
</ul>
</li>
</ul>
<h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><p>这节课有两个编程作业:第一个作业要求使用numpy实现对张量的一些操作，第二个作业要求用逻辑回归实现一个分类器。这些编程作业是在python的notebook上编写的。每道题给出了代码框架，只要写关键的几行代码就行。对我来说，编程体验极差。作为编程最强王者，怎能受此“嗟来之码”的屈辱？我决定从零开始，自己收集数据，并用numpy实现逻辑回归。</p>
<blockquote>
<p>其实我不分享作业代码的真正原因是：Coursera不允许公开展示作业代码。在之后的笔记中，我也会分享如何用自己的代码实现每堂课的编程目标。</p>
</blockquote>
<p>这篇笔记用到的代码已在GitHub上开源：<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/LogisticRegression">https://github.com/SingleZombie/DL-Demos/tree/master/LogisticRegression</a> 。下文展示的代码和原本的代码有略微的出入，建议大家对着源代码阅读后文。</p>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>不管写什么程序，都要先想好整体的架构，再开始动手写代码。</p>
<p>深度学习项目的架构比较固定。一般一个深度学习项目由以下几部分组成：</p>
<ul>
<li>数据预处理</li>
<li>定义网络结构</li>
<li>定义损失函数</li>
<li>定义优化策略</li>
<li>用训练pipeline串联起网络、损失函数、优化策略</li>
<li>测试模型精度</li>
</ul>
<p>当然，实现深度学习项目比一般的编程项目多一个步骤：除了写代码外，完成深度学习项目还需要收集数据。</p>
<p>接下来，我将按照<strong>数据收集</strong>、<strong>数据处理</strong>、<strong>网络结构</strong>、<strong>损失函数</strong>、<strong>训练</strong>、<strong>测试</strong>这几部分介绍这个项目。之后的笔记也会以这个形式介绍编程项目。</p>
<h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>说起最经典的二分类任务，大家都会想起小猫分类（或许跟吴恩达老师的课比较流行有关）。在这个项目中，我也顺应潮流，选择了一个猫狗数据集（<a target="_blank" rel="noopener" href="https://www.kaggle.com/datasets/fusicfenta/cat-and-dog?resource=download）。">https://www.kaggle.com/datasets/fusicfenta/cat-and-dog?resource=download）。</a></p>
<p>在此数据集中，数据是按以下结构存储的：</p>
<p><img src="/2022/05/10/DLS-note-2/4.png" alt></p>
<p>在二分类任务中，数据的标签为0或1（表示是否是小猫）。而此数据集只是把猫、狗的图片分别放到了不同的文件夹里，这意味着我们待会儿要手动给这些数据打上0或1的标签。</p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>由于训练集和测试集的目录结构相同，我们先写一个读数据集的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">input_shape=(<span class="number">224</span>, <span class="number">224</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_dataset</span>(<span class="params"><span class="built_in">dir</span>, data_num</span>):</span></span><br><span class="line">    cat_images = glob(osp.join(<span class="built_in">dir</span>, <span class="string">&#x27;cats&#x27;</span>, <span class="string">&#x27;*.jpg&#x27;</span>))</span><br><span class="line">    dog_images = glob(osp.join(<span class="built_in">dir</span>, <span class="string">&#x27;dogs&#x27;</span>, <span class="string">&#x27;*.jpg&#x27;</span>))</span><br><span class="line">    cat_tensor = []</span><br><span class="line">    dog_tensor = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, image <span class="keyword">in</span> <span class="built_in">enumerate</span>(cat_images):</span><br><span class="line">        <span class="keyword">if</span> idx &gt;= data_num:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i = cv2.imread(image) / <span class="number">255</span></span><br><span class="line">        i = cv2.resize(i, input_shape)</span><br><span class="line">        cat_tensor.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, image <span class="keyword">in</span> <span class="built_in">enumerate</span>(dog_images):</span><br><span class="line">        <span class="keyword">if</span> idx &gt;= data_num:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i = cv2.imread(image) / <span class="number">255</span></span><br><span class="line">        i = cv2.resize(i, input_shape)</span><br><span class="line">        dog_tensor.append(i)</span><br><span class="line"></span><br><span class="line">    X = cat_tensor + dog_tensor</span><br><span class="line">    Y = [<span class="number">1</span>] * <span class="built_in">len</span>(cat_tensor) + [<span class="number">0</span>] * <span class="built_in">len</span>(dog_tensor)</span><br><span class="line">    X_Y = <span class="built_in">list</span>(<span class="built_in">zip</span>(X, Y))</span><br><span class="line">    shuffle(X_Y)</span><br><span class="line">    X, Y = <span class="built_in">zip</span>(*X_Y)</span><br><span class="line">    <span class="keyword">return</span> X, Y</span><br></pre></td></tr></table></figure><br>函数先是用<code>glob</code>读出文件夹下所有猫狗的图片路径，再按文件路径依次把文件读入。接着，函数为数据生成了0或1的标签。最后，函数把数据打乱，并返回数据。让我们来看看这段代码里有哪些要注意的地方。</p>
<p>在具体介绍代码之前，要说明一下我在这个数据集上做的两个特殊处理：</p>
<ol>
<li>这个函数有一个参数<code>data_num</code>，表示我们要读取<code>data_num</code>张猫+<code>data_num</code>张狗的数据。原数据集有上千张图片，直接读进内存肯定会把内存塞爆。为了实现上的方便，我加了一个控制数据数量的参数。在这个项目中，我只用了800张图片做训练集。</li>
<li>原图片是很大的，为了节约内存，我把所有图片都变成了input_shape=(224, 224)的大小。</li>
</ol>
<p>接下来，我们再了解一下数据处理中的一些知识。在读数据的时候，把数据<strong>归一化</strong>（令数据分布在(-1, 1)这个区间内）十分关键。如果不这样做的话，loss里的$loge^{z}$会趋近$log0$，梯度的收敛速度会极慢，训练会难以进行。这是这节课上没有讲的内容，但是它在实战中非常关键。</p>
<blockquote>
<p>这个时候输出loss的话，会得到一个Python无法表示的数字：<code>nan</code>。在训练中如果看到loss是<code>nan</code>，多半就是数据没有归一化的原因。这个是一个非常常见的bug，一定要记得做数据归一化！</p>
<p>第三节课里讲了激活函数的收敛速度问题。</p>
</blockquote>
<p>现在来详细看代码。</p>
<p>下面的代码用于从文件系统中读取所有图片文件，并把文件的绝对路径保存进一个list。如果大家有疑问，可以自行搜索<code>glob</code>函数的用法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat_images = glob(osp.join(<span class="built_in">dir</span>, <span class="string">&#x27;cats&#x27;</span>, <span class="string">&#x27;*.jpg&#x27;</span>))</span><br><span class="line">dog_images = glob(osp.join(<span class="built_in">dir</span>, <span class="string">&#x27;dogs&#x27;</span>, <span class="string">&#x27;*.jpg&#x27;</span>))</span><br></pre></td></tr></table></figure></p>
<p>在之后的两段for循环中，我们通过设定循环次数来控制读取的图片数。在循环里，我们先读入文件，再归一化文件，最后把图片resize到(224, 224)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, image <span class="keyword">in</span> <span class="built_in">enumerate</span>(cat_images):</span><br><span class="line">    <span class="keyword">if</span> idx &gt;= data_num:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i = cv2.imread(image) / <span class="number">255</span></span><br><span class="line">    i = cv2.resize(i, input_shape)</span><br><span class="line">    cat_tensor.append(i)</span><br></pre></td></tr></table></figure><br>在这段代码里，归一化是靠</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = cv2.imread(image) / <span class="number">255</span></span><br></pre></td></tr></table></figure>
<p>实现的。</p>
<blockquote>
<p>这里我们知道输入是图像，颜色通道最大值是255，所以才这样归一化。在很多问题中，我们并不知道数据的边界是多少，这个时候只能用普通的归一化方法了。一种简单的归一化方法是把每个输入向量的模设为1。后面的课程里会详细介绍归一化方法。</p>
</blockquote>
<p>读完数据后，我们用以下代码生成了训练输入和对应的标签：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = cat_tensor + dog_tensor</span><br><span class="line">Y = [<span class="number">1</span>] * <span class="built_in">len</span>(cat_tensor) + [<span class="number">0</span>] * <span class="built_in">len</span>(dog_tensor)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Python里，<code>[1] * 10</code>可以把列表<code>[1]</code>复制10次。</p>
</blockquote>
<p>现在，我们的数据是“[猫，猫，猫……狗，狗，狗]”这样整整齐齐地排列着，没有打乱。由于我们是一次性拿整个训练集去训练，训练数据不打乱倒也没事。但为了兼容之后其他训练策略，这里我还是习惯性地把数据打乱了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X_Y = <span class="built_in">list</span>(<span class="built_in">zip</span>(X, Y))</span><br><span class="line">shuffle(X_Y)</span><br><span class="line">X, Y = <span class="built_in">zip</span>(*X_Y)</span><br></pre></td></tr></table></figure><br>使用这三行“魔法Python”可以打乱<code>list</code>对中的数据。</p>
<p>有了读一个文件夹的函数<code>load_dataset</code>，用下面的代码就可以读训练集和测试集：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_data</span>(<span class="params"><span class="built_in">dir</span>=<span class="string">&#x27;data/archive/dataset&#x27;</span>, input_shape=(<span class="params"><span class="number">224</span>, <span class="number">224</span></span>)</span>):</span></span><br><span class="line">    train_X, train_Y = load_dataset(osp.join(<span class="built_in">dir</span>, <span class="string">&#x27;training_set&#x27;</span>), <span class="number">400</span>)</span><br><span class="line">    test_X, test_Y = load_dataset(osp.join(<span class="built_in">dir</span>, <span class="string">&#x27;test_set&#x27;</span>), <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> train_X, train_Y, test_X, test_Y</span><br></pre></td></tr></table></figure><br>这里训练集有400+400=800张图片，测试集有100+100=200张图片。如果大家发现内存还是占用太多的话，可以改小这两个数字。</p>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p>在这个项目中，我们使用的是逻辑回归算法。它可以看成是只有一个神经元的神经网络。如之前的课堂笔记所述，我们网络的公式是：</p>
<script type="math/tex; mode=display">
\hat{y} = \sigma(w^Tx+b)</script><p>这里我们要实现两个函数：</p>
<ol>
<li>resize_input：由于图片张量的形状是[h, w, c]（高、宽、颜色通道），而网络的输入是一个列向量，我们要把图片张量resize一下。</li>
<li>sigmoid: 我们要用<code>numpy</code>函数组合出一个<code>sigmoid</code>函数。</li>
</ol>
<p>熟悉了<code>numpy</code>的API后，实现这两个函数还是很容易的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize_input</span>(<span class="params">a: np.ndarray</span>):</span></span><br><span class="line">    h, w, c = a.shape</span><br><span class="line">    a.resize((h * w * c))</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br></pre></td></tr></table></figure></p>
<p>这里我代码实现上写得有点“脏”，调用<code>resize_input</code>做数据预处理是放在<code>main</code>函数里的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">train_X, train_Y, test_X, test_Y = generate_data()</span><br><span class="line"></span><br><span class="line">train_X = [resize_input(x) <span class="keyword">for</span> x <span class="keyword">in</span> train_X]</span><br><span class="line">test_X = [resize_input(x) <span class="keyword">for</span> x <span class="keyword">in</span> test_X]</span><br><span class="line">train_X = np.array(train_X).T</span><br><span class="line">train_Y = np.array(train_Y)</span><br><span class="line">train_Y = train_Y.reshape((<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line">test_X = np.array(test_X).T</span><br><span class="line">test_Y = np.array(test_Y)</span><br><span class="line">test_Y = test_Y.reshape((<span class="number">1</span>, -<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>array = array.reshape(a, b)</code> 等价于 <code>array.resize(a, b)</code>。但是，<code>reshape</code>的某一维可以写成<code>-1</code>，表示这一维的大小让程序自己用除法算出来。比如总共有<code>a * b</code>个元素，调用<code>reshape(-1, a)</code>，<code>-1</code>的那一维会变成<code>b</code>。</p>
</blockquote>
<p>经过这些预处理代码，X的shape会变成[$n_x$, $m$]，Y的shape会变成[$1$, $m$]，和课堂里讲的内容一致。</p>
<p>有了sigmoid函数和正确shape的输入，我们可以写出网络的推理函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">w, b, X</span>):</span></span><br><span class="line">    <span class="keyword">return</span> sigmoid(np.dot(w.T, X) + b)</span><br></pre></td></tr></table></figure>
<h2 id="损失函数与梯度下降"><a href="#损失函数与梯度下降" class="headerlink" title="损失函数与梯度下降"></a>损失函数与梯度下降</h2><p>如前面的笔记所述，损失函数可以用下面的方法计算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">y_hat, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.mean(-(y * np.log(y_hat) + (<span class="number">1</span> - y) * np.log(<span class="number">1</span> - y_hat)))</span><br></pre></td></tr></table></figure>
<p>我们定义损失函数，实际上为了求得每个参数的梯度。在求梯度时，其实用不到损失函数本身，只需要知道每个参数对于损失函数的导数。在这个项目中，损失函数只用于输出，以监控当前的训练进度。</p>
<p>而在梯度下降中，我们不需要用到损失函数，只需要算出每个参数的梯度并执行梯度下降：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span>(<span class="params">w, b, X, Y, lr</span>):</span></span><br><span class="line">    m = X.shape[<span class="number">1</span>]</span><br><span class="line">    Z = np.dot(w.T, X) + b</span><br><span class="line">    A = sigmoid(Z)</span><br><span class="line">    d_Z = A - Y</span><br><span class="line">    d_w = np.dot(X, d_Z.T) / m</span><br><span class="line">    d_b = np.mean(d_Z)</span><br><span class="line">    <span class="keyword">return</span> w - lr * d_w, b - lr * d_b</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们根据前面算好的公式，算出了<code>w, b</code>的梯度并对<code>w, b</code>进行更新。</p>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">train_X, train_Y, step=<span class="number">1000</span>, learning_rate=<span class="number">0.00001</span></span>):</span></span><br><span class="line">    w, b = init_weights()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;learning rate: <span class="subst">&#123;learning_rate&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(step):</span><br><span class="line">        w, b = train_step(w, b, train_X, train_Y, learning_rate)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输出当前训练进度</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            y_hat = predict(w, b, train_X)</span><br><span class="line">            ls = loss(y_hat, train_Y)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;step <span class="subst">&#123;i&#125;</span> loss: <span class="subst">&#123;ls&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> w, b</span><br></pre></td></tr></table></figure>
<p>有了刚刚的梯度下降函数<code>train_step</code>，训练实现起来就很方便了。我们只需要设置一个训练总次数<code>step</code>，再调用<code>train_step</code>更新参数即可。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在深度学习中，我们要用一个网络从来没有见过的数据集做测试，以验证网络能否泛化到一般的数据上。这里我们直接使用数据集中的<code>test_set</code>，用下面的代码计算分类任务的准确率：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">w, b, test_X, test_Y</span>):</span></span><br><span class="line">    y_hat = predict(w, b, test_X)</span><br><span class="line">    predicts = np.where(y_hat &gt; <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    score = np.mean(np.where(predicts == test_Y, <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Accuracy: <span class="subst">&#123;score&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里的<code>np.where</code>没有在课堂里讲过，这里补充介绍一下。<code>predicts=np.where(y_hat &gt; 0.5, 1, 0)</code>这一行，等价于下面的循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建一个和y_hat一样形状的ndarray</span></span><br><span class="line">predicts = np.zeros(y_hat.shape)</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(y_hat):</span><br><span class="line">  <span class="keyword">if</span> v &gt; <span class="number">0.5</span>:</span><br><span class="line">    predicts[i] = <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    predicts[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>也就是说，我们对<code>y_hat</code>做了逐元素的判断<code>v &gt; 0.5?</code>，如果判断成立，则赋值<code>1</code>，否则赋值<code>0</code>。这就好像是一个老师在批改学生的作业，如果对了，就给1分，否则给0分。</p>
<p><code>y_hat &gt; 0.5</code>是有实际意义的：在二分类问题中，如果网络输出图片是小猫的概率大于0.5，我们就认为图片就是小猫的图片；否则，我们认为不是。</p>
<p>之后，我们用另一个<code>(np.where(predicts == test_Y, 1, 0)</code>来“批改作业”：如果预测值和真值一样，则打1分，否则打0分。</p>
<p>最后，我们用<code>score = np.mean(...)</code>算出每道题分数的平均值，来给整个网络的表现打一个总分。</p>
<p>这里要注意一下，整个项目中我们用了两个方式来评价网络：我们监控了<code>loss</code>,因为<code>loss</code>反映了网络在<strong>训练集</strong>上的表现；我们计算了网络在测试集上的准确度，因为准确度反映了网络在<strong>一般数据</strong>上的表现。之后的课堂里应该也会讲到如何使用这些指标来进一步优化网络，这里会算它们就行了。</p>
<h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><p>嘿嘿，想不到吧，除了之前计划的章节外，这里还多了一个趣味性比较强的调参章节。</p>
<h3 id="使用错误代码得到的结果，千万不要学我"><a href="#使用错误代码得到的结果，千万不要学我" class="headerlink" title="使用错误代码得到的结果，千万不要学我"></a>使用错误代码得到的结果，千万不要学我</h3><p>搞深度学习，最好玩的地方就是调参数了。通过优化网络的超参数，我们能看到网络的性能在不断变好，准确率在不断变高。这个感觉就和考试分数越来越高，玩游戏刷的伤害越来越高给人带来的成就感一样。</p>
<p>在这个网络中，可以调的参数只有一个学习率。通过玩这个参数，我们能够更直观地认识学习率对梯度下降的影响。</p>
<p>这里我分享一下我的调参结果：</p>
<p>如果学习率&gt;=0.0003，网络更新的步伐过大，从而导致梯度不收敛，训练失败。</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">learning rate: 0.0003</span><br><span class="line">step 0 loss: 0.6918513655136874</span><br><span class="line">step 10 loss: 0.9047000002073068</span><br><span class="line">step 20 loss: 0.9751763789675365</span><br></pre></td></tr></table></figure>
<p>学习率==0.0002的话，网络差不多能以最快的速度收敛。</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">learning rate: 0.0002</span><br><span class="line">step 0 loss: 0.692168431534233</span><br><span class="line">step 10 loss: 0.684254876013497</span><br><span class="line">step 20 loss: 0.6780829877162996</span><br></pre></td></tr></table></figure>
<p>学习率==0.0001,甚至==0.00003也能训练，但是训练速度会变慢。</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">learning rate: 0.0001</span><br><span class="line">step 0 loss: 0.6926003513589579</span><br><span class="line">step 10 loss: 0.6883167092427446</span><br><span class="line">step 20 loss: 0.684621635180076</span><br></pre></td></tr></table></figure>
<p>这里判断网络的收敛速度时，要用到的指标是<strong>损失函数</strong>。我的代码里默认每10次训练输出一次损失函数的值。</p>
<blockquote>
<p>一般大家不会区别误差和损失函数，会把损失函数叫成 loss。</p>
</blockquote>
<p>为了节约时间，一开始我只训练了1000步，最后准确率只有0.57左右。哪怕我令输出全部为1，从期望上都能得到0.5的准确率。这个结果确实不尽如人意。</p>
<p>我自己亲手设计的模型，结果怎么能这么差呢？肯定是训练得不够。我一怒之下，加了个零，让程序跑10000步训练。看着loss不断降低，从0.69，到0.4，再到0.3，最后在0.24的小数点第3位之后变动，我的心情也越来越激动：能不能再低点，能不能再创新低？那感觉就像股市开盘看到自己买的股票高开，不断祈祷庄家快点买入一样。</p>
<p>在电脑前，盯着不断更新的控制台快一小时后，loss定格在了0.2385，我总算等到了10000步训练结束的那一刻。模型即将完成测试，准确率即将揭晓。<br>我定睛一看——准确率居然还只有0.575!</p>
<p>这肯定不是我代码的问题，一定是逻辑回归这个模型太烂了！希望在之后的课程中，我们能够用更复杂的模型跑出更好的结果。</p>
<p>欢迎大家也去下载这个demo(<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/LogisticRegression)，一起调一调参数~">https://github.com/SingleZombie/DL-Demos/tree/master/LogisticRegression)，一起调一调参数~</a></p>
<h3 id="修好bug后的结果"><a href="#修好bug后的结果" class="headerlink" title="修好bug后的结果"></a>修好bug后的结果</h3><p>第一次写的代码竟然把梯度全部算错了，这太离谱了，我也不知道当时写代码的时候脑子里进了多少水。修好bug后，我又跑了一次训练。</p>
<p>首先，按照上次的经验，学习率0.0002，跑1000步，就得到了0.59的准确率。这效果差的也太多吧！</p>
<p>接下来训练10000步，我又满怀期待地盯着控制台，看着梯度降到了0.2395。</p>
<p>精度测出来了——好家伙，又是0.575。</p>
<p>行吧，起码文章的内容不用大改了。逻辑回归太菜了，和代码确实没什么关系。</p>
<p>其实，这段写bug经历对我来说是很赚的。我学到了：在梯度算得有问题的情况下，网络可以正常训练，甚至loss还会正常降低。但是，网络的正确率肯定会更低。一定要尊重数学规律，老老实实地按照数学推导的结果写公式。如果没有写bug，我反而学不到这么多东西，反而很亏。</p>
<h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>把这篇文章刚发到博客上的时候，这篇文章有一堆错误：$W,w$不分，损失函数乱写……。写这种教学文章一定要严谨，尤其是涉及了数学运算的。很多时候程序有bug，根本看不出来。希望我能引以为戒，学踏实了，把文章检查了几遍了，再把文章发出来。</p>
<p>突然又发现一个bug：reshape不是inplace运算。我写得也太潦草了吧！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/04/23/DLS-note-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/23/DLS-note-1/" class="post-title-link" itemprop="url">吴恩达《深度学习专项》笔记+代码实战（一）：深度学习入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-23 21:49:02" itemprop="dateCreated datePublished" datetime="2022-04-23T21:49:02+08:00">2022-04-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">知识记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近在学吴恩达的《深度学习专项》（Deep Learning Specialization)。为了让学习更有效率（顺便有一些博文上的产出），我准备写一些学习笔记。笔记的内容比较简单，没有什么原创性的内容，主要是对课堂的知识进行梳理（这些文章的标题虽然叫”笔记“，但根据我之前的分类，这些文章由于原创性较低，被划分在”知识记录“里）。如果读者也在学这门课的话，可以对照我总结出来的知识，查缺补漏。之后几节课有课后作业，我会在笔记里讲解我的编程思路，给读者一些编程上的启发。</p>
<p>文章中的正文主要是对课堂内容的总结。引用里的内容和每篇笔记的总结是我个人的观点或评论。</p>
<h2 id="什么是神经网络"><a href="#什么是神经网络" class="headerlink" title="什么是神经网络"></a>什么是神经网络</h2><p>我们把一个有输入有输出的计算单元叫做“神经元”。神经元可以简单地理解成一个线性函数。比如要预测房价和房屋面积的关系，我们可以近似地用一个线性函数去拟合。这个函数就是一个神经元。</p>
<blockquote>
<p>事实上，一个神经元不仅包含一个线性函数，还包括一个激活函数。这里提到了激活函数 ReLU 的概念，其具体内容应该会在后面介绍。</p>
</blockquote>
<p>神经元的堆叠，构成了神经网络，如下图所示。</p>
<p><img src="/2022/04/23/DLS-note-1/1.jpg" alt></p>
<p>在用一个神经元来表示房价和房屋面积的关系时，神经元的输入是房屋面积，输出是房价。而用多层神经元时，每个神经元的意义可能都不一样。比如中间的神经元可能会根据输入的邮政编码、地址特征，输出一个表示房屋地段的中间特征。在神经网络中，这些特征都是<strong>自动生成</strong>的（意味着我们只需要管理神经网络的输入和输出，而不用指定中间的特征，也不用理解它们究竟有没有实际意义）。</p>
<blockquote>
<p>以前的一些机器学习要手动设置特征。而神经网络这种自动生成特征的性质，是其成功的原因之一。</p>
</blockquote>
<h2 id="用神经网络做监督学习"><a href="#用神经网络做监督学习" class="headerlink" title="用神经网络做监督学习"></a>用神经网络做监督学习</h2><blockquote>
<p>要理解监督学习，其实应该要对比无监督学习。本节实际上是介绍了监督学习的几个例子。</p>
</blockquote>
<p>常见的神经网络有三类：</p>
<ol>
<li>标准神经网络（即全连接网络）可以用于房屋分类、广告分类问题。（这些问题一般输入是<strong>结构化</strong>的）</li>
<li>卷积神经网络（CNN）一般用于图像相关的问题，比如图片猫狗分类，自动驾驶中识别其他车辆的位置。</li>
<li>循环神经网络（RNN）一般用于处理有时序的序列数据，比如和声音、文字有关的应用都需要RNN。</li>
</ol>
<p>结构化数据，就是所有其数据项都是人能理解的（房子的面积、价格）。对比来看，无结构化的数据的具体含义是无法直接解释的，比如图像每一个像素值、声音某时刻的频率和响度、某一个文字/单词。</p>
<h2 id="为什么最近深度学习“起飞”了？"><a href="#为什么最近深度学习“起飞”了？" class="headerlink" title="为什么最近深度学习“起飞”了？"></a>为什么最近深度学习“起飞”了？</h2><p><img src="/2022/04/23/DLS-note-1/2.jpg" alt></p>
<p>这张图足以解释深度学习腾飞的原因。随着数据量的增加，所有方法都有性能的上限。而对于神经网络来说，结构越复杂的神经网络，其性能上限越高。复杂的神经网络（深度学习方法）在海量数据不断产生的今天更具优势。</p>
<p>光有大量的数据，没有使用数据的方法是不够的。总结来看，深度学习在近几年得到发展的原因有下：</p>
<ul>
<li>互联网的发展使得数字数据大量增长。</li>
<li>GPU等计算设备使得处理数据的硬件变强。</li>
<li>深度学习的算法不断更新迭代，从软件层面上加快了数据处理。（比如激活函数的改进，从sigmoid到ReLU）</li>
</ul>
<p>深度学习本质上还是以实验为主。计算能力上来了，研究人员做实验做得快了，各种各样的深度学习的应用也就出来了。各种应用又鼓舞着更多人参与深度学习研究。也就是说，是计算能力的提升使得近年来深度学习进入了良好的正反馈循环中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一周的课没有什么深奥的内容，主要是给对深度学习不太熟悉的同学们介绍了下背景知识。</p>
<p>在我看来，这周的课需要记住的东西有：</p>
<ul>
<li>神经元有输入和输出的计算单元。神经元堆叠成了神经网络。</li>
<li>大致有三种不同类型的神经网络，适用于不同的任务。</li>
<li>神经网络的性能随其规模和数据量而增长。</li>
<li>计算效率的提高使深度学习近期得到飞速发展。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/03/18/20220315-custom-op/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/18/20220315-custom-op/" class="post-title-link" itemprop="url">PyTorch Custom OP （自定义算子） 教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-18 15:28:41" itemprop="dateCreated datePublished" datetime="2022-03-18T15:28:41+08:00">2022-03-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">知识整理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="PyTorch-自定义算子教程：两种方法实现加法算子（附LibTorch-Windows环境配置教程）"><a href="#PyTorch-自定义算子教程：两种方法实现加法算子（附LibTorch-Windows环境配置教程）" class="headerlink" title="PyTorch 自定义算子教程：两种方法实现加法算子（附LibTorch Windows环境配置教程）"></a>PyTorch 自定义算子教程：两种方法实现加法算子（附LibTorch Windows环境配置教程）</h1><p>我们都知道，PyTorch做卷积等底层运算时，都是用C++实现的。有时，我们再怎么去调用PyTorch定义好的算子，也无法满足我们的需求。这时，我们就要考虑用C++自定义一个PyTorch的算子了。</p>
<p>PyTorch提供了两种添加C++算子的方法：编译动态库并嵌入<code>TorchScript</code><a target="_blank" rel="noopener" href="https://pytorch.org/tutorials/advanced/torch_script_custom_ops.html">[1]</a>、用PyTorch的C++拓展接口<a target="_blank" rel="noopener" href="https://pytorch.org/tutorials/advanced/cpp_extension.html">[2]</a>。前者适合导入独立的C++项目，后者需要用PyTorch的API设置编译信息，只适合小型C++项目，更适合于把新算子共享给他人的情况。由于我还没有用过torch的C++接口，这里先用第一种方法写一套独立的算子实现示例，跑通整个流程，再基于同一份代码，用第二种方法实现一次，以全方位地介绍PyTorch自定义算子的方法。</p>
<p><strong>前置准备：</strong></p>
<ul>
<li>装好了CMake</li>
<li>装好了PyTorch</li>
<li>装好了OpenCV</li>
<li>看得懂C++、Python</li>
</ul>
<p><strong>知识点预览：</strong></p>
<ul>
<li>如何配置LibTorch</li>
<li>第一个Torch C++程序</li>
<li>如何自己写简单的CMake</li>
<li>如何用Visual Studio写CMake项目</li>
<li>如何编译使用简单的动态库</li>
<li>如何用两种方法实现PyTorch自定义算子</li>
<li>如何用setuptools自动编译C++源代码</li>
</ul>
<p>（以上是我写这篇文章之前还不会的东西。）</p>
<ul>
<li>如何用PyTest做单元测试</li>
</ul>
<p><strong>参考教程</strong>：</p>
<p>[1] 添加<code>TorchScript</code>拓展 <a target="_blank" rel="noopener" href="https://pytorch.org/tutorials/advanced/torch_script_custom_ops.html">https://pytorch.org/tutorials/advanced/torch_script_custom_ops.html</a></p>
<p>[2] PyTorch的C++拓展 <a target="_blank" rel="noopener" href="https://pytorch.org/tutorials/advanced/cpp_extension.html">https://pytorch.org/tutorials/advanced/cpp_extension.html</a></p>
<p>[3] 安装LibTorch <a target="_blank" rel="noopener" href="https://pytorch.org/cppdocs/installing.html">https://pytorch.org/cppdocs/installing.html</a></p>
<p>[4] VS CMake <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/build/cmake-projects-in-visual-studio?view=msvc-170&amp;viewFallbackFrom=vs-2019">https://docs.microsoft.com/zh-cn/cpp/build/cmake-projects-in-visual-studio?view=msvc-170&amp;viewFallbackFrom=vs-2019</a></p>
<h2 id="配置-LibTorch-开发环境"><a href="#配置-LibTorch-开发环境" class="headerlink" title="配置 LibTorch 开发环境"></a>配置 LibTorch 开发环境</h2><p>我们这个项目是使用CMake开发的，理论上任何平台都能使用。我是在Windows上测试的，理论上Windows上碰到的毛病会多一些，Linux上可能直接用就没问题了。</p>
<p>对于我们这个CMake项目来说，成功添加路径，使得<code>find_package（Torch)</code>（找到Torch的CMake配置）不报错就算配置环境成功。当然，貌似由于Torch依赖于OpenCV，找OpenCV包也得成功才行。</p>
<p>参考教程是<a target="_blank" rel="noopener" href="https://pytorch.org/cppdocs/installing.html">[3]</a>，但对于像我一样什么都不懂的新手来说，由于CMake有些东西要配置，这篇官方教程还不太够用。</p>
<h3 id="下载-LibTorch"><a href="#下载-LibTorch" class="headerlink" title="下载 LibTorch"></a>下载 LibTorch</h3><p>想用PyTorch的C++相关内容的话，要先去下载LibTorch库。</p>
<p>在获取PyTorch的Python版本下载命令处，可以找到LibTorch的安装链接：</p>
<p><img src="/2022/03/18/20220315-custom-op/1.jpg" alt></p>
<p>和装PyTorch Python版的时候类似，选好自己的版本，之后点击某个链接下载就行。第一个链接是Release版，第二个是Debug版。由于我是编程高手，不要调试，所以直接选择了Release版。建议大家去下Debug版方便随时调试。</p>
<h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p>下一步要把LibTorch的动态库所在目录加入环境变量中，以使程序运行时能够找得到依赖的动态库（编译是没问题的）。</p>
<p>把<code>xxxxxxxx\libtorch\lib</code>这个目录添加进环境变量即可。</p>
<p>如果是在Windows上，添加环境变量时有一个细节要注意：</p>
<p><img src="/2022/03/18/20220315-custom-op/2.jpg" alt></p>
<p>相信90%的人装PyTorch前都是把Cuda装好了的。在添加LibTorch的动态库目录时一定要注意，要把这个路径移到Cuda路径的上面。详细原因见<strong>FAQ</strong>。</p>
<h3 id="Hello-LibTorch"><a href="#Hello-LibTorch" class="headerlink" title="Hello LibTorch"></a>Hello LibTorch</h3><p>接下来我们要用一个能调试CMake程序的环境来完成第一个C++ LibTorch程序。</p>
<p>创建一个崭新的文件夹，在里面添加一个<code>CMakeLists.txt</code>:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.1</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(equi_conv)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Torch REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(equi_conv op.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(equi_conv PRIVATE cxx_std_14)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(equi_conv <span class="string">&quot;$&#123;TORCH_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(equi_conv opencv_core opencv_imgproc)</span><br></pre></td></tr></table></figure>
<p>里面的<code>equi_conv</code>可以换成你喜欢的项目名。我使用的项目名是<code>equi_conv</code>，这个名称会在后面多次出现。理论上我显示<code>equi_conv</code>的地方显示的应该是你自己的项目名。</p>
<p><strong>注意！</strong>一般情况下CMake是找不到Torch和OpenCV的，要手动设置CMake Configure附加命令中的<code>Torch_DIR</code>和<code>OpenCV_DIR</code>这两个参数，比如我的附加命令是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D Torch_DIR=&quot;D:/Download/libtorch-win-shared-with-deps-1.11.0+cu113/libtorch/share/cmake/Torch&quot; -D OpenCV_DIR=&quot;D:/OpenCV/opencv/build&quot;</span><br></pre></td></tr></table></figure>
<p>。<code>Torch_DIR</code>是<code>&quot;xxxxxxxx/libtorch/share/cmake/Torch</code>,<code>OpenCV_DIR</code>大约是<code>xxxxxxxx/opencv/build</code>。每个人的具体路径可能不一样，只要记住，这两个路径里都得是包含了<code>.cmake</code>文件的。根据编程环境的不同，设置这两个CMake参数的位置也不同，详见后文。</p>
<p>官方教程[3]给了一种很骚的提供路径的方法：<code>-DCMAKE_PREFIX_PATH=&quot;$(python -c &#39;import torch.utils; print(torch.utils.cmake_prefix_path)&#39;)&quot;</code>。这个命令是调用Python脚本以添加PyTorch默认的CMake搜索目录。但是这个命令有一些问题：1) 当前命令行环境里不一定能正确调用Python及访问torch库（比如PyTorch是用conda装的，而当前环境不是对应的conda环境）；2) 我们下载的libtorch似乎难以对得上PyTorch包里默认的libtorch路径。这行命令似乎仅适用于处于正确Python环境下，把libtorch装到了<code>/libtorch</code>目录下的Linux系统。为了命令的兼容性，我们不用这么骚的操作，老老实实自己设置LibTorch目录和OpenCV目录。</p>
<p>再写一个叫<code>op.cpp</code>的C++源文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;torch/torch.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	torch::Tensor tensor = torch::<span class="built_in">rand</span>(&#123; <span class="number">2</span>, <span class="number">3</span> &#125;);</span><br><span class="line">	std::cout &lt;&lt; tensor &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你是高手，可以不去配环境，直接手敲CMake命令。但为了方便，接下来我们还是准备调试运行这个程序。配置CMake调试环境有很多方法，这里先给一个Windows上Visual Studio的方案<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/build/cmake-projects-in-visual-studio?view=msvc-170&amp;viewFallbackFrom=vs-2019">[4]</a>：</p>
<p>准备好上面那个<code>CMakeLists.txt</code>后，用VS打开这个CMake文件（相信大家的VS都是2017版本以上的，旧版本是没有CMake的功能的~）：</p>
<p><img src="/2022/03/18/20220315-custom-op/3.jpg" alt></p>
<p>如果文件没写错VS会自动配置(Configure)CMake。在工具栏中可以手动中断或开始CMake的配置。</p>
<p><img src="/2022/03/18/20220315-custom-op/4.jpg" alt></p>
<p>还可以点击上面的“{PROJECT_NAME}的CMake设置”来设置CMake命令中要用的参数（比如<code>-D</code>参数）</p>
<p><img src="/2022/03/18/20220315-custom-op/5.jpg" alt></p>
<p>注意，一开始CMake只有Debug版的配置，可以点左上角的加号手动加一个Release版的配置。</p>
<p>同时，如图中所示，<code>xxx_DIR</code>应该卸载CMake命令参数里面。</p>
<p>配置好后去上面的工具栏点击”生成-全部生成”就可以把程序编译好了。接下来按熟悉的F5就可以运行程序了。</p>
<p>再介绍一个VSCode的CMake编程环境，这个基本上是全平台通用的。不过同样，我还是在Windows上测试的，以Windows上的配置为主。</p>
<p>通过搜索”Windows CMake VSCode cl 配置”等关键词，我搜索到了一篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/Nichlson/article/details/113763551">很好的教程</a>，我是照着这篇教程配的环境。如果是Linux的话，换一下编译器应该就能拿过来用了。</p>
<p>为了添加<code>-D</code>等配置参数，可以用<code>ctrl+,</code>打开设置，修改工作区设置里的CMake Configure命令：</p>
<p><img src="/2022/03/18/20220315-custom-op/6.jpg" alt></p>
<p>如果一切正常，程序会输出随机张量的内容。</p>
<p><img src="/2022/03/18/20220315-custom-op/7.jpg" alt></p>
<h2 id="LibTorch-A-B"><a href="#LibTorch-A-B" class="headerlink" title="LibTorch A+B"></a>LibTorch A+B</h2><h3 id="C-侧"><a href="#C-侧" class="headerlink" title="C++ 侧"></a>C++ 侧</h3><p>修改<code>op.cpp</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;torch/torch.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">torch::Tensor <span class="title">my_add</span><span class="params">(torch::Tensor t1, torch::Tensor t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(t1.<span class="built_in">size</span>(<span class="number">0</span>) == t2.<span class="built_in">size</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="built_in">assert</span>(t1.<span class="built_in">size</span>(<span class="number">1</span>) == t2.<span class="built_in">size</span>(<span class="number">1</span>));</span><br><span class="line">	<span class="function">cv::Mat <span class="title">m1</span><span class="params">(t1.size(<span class="number">0</span>), t1.size(<span class="number">1</span>), CV_32FC3, t1.data_ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br><span class="line">	<span class="function">cv::Mat <span class="title">m2</span><span class="params">(t1.size(<span class="number">0</span>), t1.size(<span class="number">1</span>), CV_32FC3, t2.data_ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br><span class="line">	</span><br><span class="line">	cv::Mat res = m1 + m2;</span><br><span class="line"></span><br><span class="line">	torch::Tensor output = torch::<span class="built_in">from_blob</span>(res.ptr&lt;<span class="keyword">float</span>&gt;(), &#123; t1.<span class="built_in">size</span>(<span class="number">0</span>), t1.<span class="built_in">size</span>(<span class="number">1</span>), <span class="number">3</span>&#125;);</span><br><span class="line">	<span class="keyword">return</span> output.<span class="built_in">clone</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TORCH_LIBRARY</span>(my_ops, m)</span><br><span class="line">&#123;</span><br><span class="line">	m.<span class="built_in">def</span>(<span class="string">&quot;my_add&quot;</span>, my_add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们要实现一个新PyTorch算子<code>my_add</code>，该实现函数先把两个PyTorch Tensor转换成OpenCV Mat，用Mat做加法，再把Mat转回Tensor。整个代码非常易懂，哪怕对LibTorch和OpenCV的语法不熟，也基本猜得出每行代码的作用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;torch/torch.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>一开始，先包含LibTorch、OpenCV的头文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">torch::Tensor <span class="title">my_add</span><span class="params">(torch::Tensor t1, torch::Tensor t2)</span></span></span><br></pre></td></tr></table></figure>
<p>我们要实现的是一个PyTorch的加法，因此实现函数中所有的张量类型都是<code>torch::Tensor</code>。加法输入是两个量，输出是一个量，因此最后的函数头要这样写。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(t1.<span class="built_in">size</span>(<span class="number">0</span>) == t2.<span class="built_in">size</span>(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">assert</span>(t1.<span class="built_in">size</span>(<span class="number">1</span>) == t2.<span class="built_in">size</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>做为严谨的程序员，我们要对输入的Tensor做一定的检查（实际上这两个检查还不够，由于我们默认输入图像的通道是3，还应该检查一下通道数。但这样检查下去可能会没完没了了，这里仅仅是提醒大家要养成良好的编程习惯）（其实是我写了两行就懒得写下去了）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">m1</span><span class="params">(t1.size(<span class="number">0</span>), t1.size(<span class="number">1</span>), CV_32FC3, t1.data_ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br><span class="line"><span class="function">cv::Mat <span class="title">m2</span><span class="params">(t1.size(<span class="number">0</span>), t1.size(<span class="number">1</span>), CV_32FC3, t2.data_ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br></pre></td></tr></table></figure>
<p>这两行是用Tensor构造Mat。从这两行代码中，可以学到两点：1）可以通过<code>tensor.data_ptr&lt;float&gt;</code>来获取Tensor存储数据的指针;2）不同框架下的数据结构互转时一般是传指针，再传shape。</p>
<p>OpenCV这里有一点点特殊。OpenCV的Mat是二维的，要维护一个H-W-C（高-宽-通道）的数据，需要传一个基础数据类型<code>CV_32FC3</code>，即3通道浮点数。</p>
<p>从代码中可以猜出来，<code>tensor.size(i)</code>可以获取Tensor第i维的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat res = m1 + m2;</span><br></pre></td></tr></table></figure>
<p>不用猜都知道这是调用了Mat的加法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch::Tensor output = torch::<span class="built_in">from_blob</span>(res.ptr&lt;<span class="keyword">float</span>&gt;(), &#123; t1.<span class="built_in">size</span>(<span class="number">0</span>), t1.<span class="built_in">size</span>(<span class="number">1</span>), <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>这一行是Mat转Tensor，同样是传了数据指针和张量形状。</p>
<p>这里第二个参数是个叫<code>at::IntArrayRef</code>的类型的。这个类型会用在Tensor的shape上。该类型的最简单的初始化方式就是用大括号把值框进去，就像Python里用方括号或圆括号传List和Set一样。</p>
<p>相比生成OpenCV Mat，这里没有传数据类型。原因如前文所述，应该是由于OpenCV的数据类型里包含了维度信息，所以OpenCV的Mat构造时要额外传这个信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> output.<span class="built_in">clone</span>();</span><br></pre></td></tr></table></figure>
<p>最后返回的是<code>tensor.clone()</code>。官方教程里说，用指针创建Tensor时会复用原来的指针，而不会新申请内存。函数结束后，Mat里的资源会释放，等于说这个用Mat创建出的Tensor也失效了。因此要<code>clone()</code>一下，让数据在函数结束后依然存在。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TORCH_LIBRARY</span>(my_ops, m)</span><br><span class="line">&#123;</span><br><span class="line">	m.<span class="built_in">def</span>(<span class="string">&quot;my_add&quot;</span>, my_add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用API把C++函数绑定到Python上，现在可以不用追究这些代码的具体原理，只要知道这样写Python就可以访问到<code>my_add</code>了。</p>
<p>这里可以改动的内容其实有两处：算子的域<code>my_ops</code>，算子名/函数名<code>my_add</code>。前面那个<code>my_ops</code>在PyTorch的某些地方会用到，这里我们先不管，随便取一个名字即可。</p>
<p>现在我们要编译的是一个包含一个函数的动态库，而不是一个包含<code>main</code>的应用程序了。因此，我们要修改一下<code>CMakeLists.txt</code>中的编译选项：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.1</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(equi_conv)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Torch REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(equi_conv SHARED op.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(equi_conv PRIVATE cxx_std_14)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(equi_conv <span class="string">&quot;$&#123;TORCH_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(equi_conv opencv_core opencv_imgproc)</span><br></pre></td></tr></table></figure>
<p>其实就改了一行:<code>add_library(equi_conv SHARED op.cpp)</code>，这样可以把编译目标变成一个动态库。</p>
<p>代码没错的话，重新Configure和Generate后动态库就编译好了。</p>
<h3 id="Python-侧"><a href="#Python-侧" class="headerlink" title="Python 侧"></a>Python 侧</h3><p>我们写一个单元测试Python脚本来测试一下我们的算子能否在PyTorch里成功运行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">lib_path = <span class="string">r&quot;D:\Repo\equi_conv\EquiConv\out\build\x64-Release\equi_conv.dll&quot;</span></span><br><span class="line">torch.ops.load_library(lib_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_add</span>():</span></span><br><span class="line">    a = torch.rand([<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>])</span><br><span class="line">    b = torch.rand([<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>])</span><br><span class="line">    c = torch.ops.my_ops.my_add(a, b)</span><br><span class="line">    d = a + b</span><br><span class="line">    <span class="keyword">assert</span> torch.allclose(c, d)</span><br></pre></td></tr></table></figure>
<p>再一次，为了体现我们编程时的严谨性，我们使用pytest来测试这个脚本。<code>pip install pytest</code>就可以轻松安装好这个Python单元测试工具。但如果你实在太懒了，不想下pytest，就得在后面补一行<code>test_add()</code>手动调用一下这个函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lib_path = <span class="string">r&quot;D:\Repo\equi_conv\EquiConv\out\build\x64-Release\equi_conv.dll&quot;</span></span><br><span class="line">torch.ops.load_library(lib_path)</span><br></pre></td></tr></table></figure>
<p><code>import torch</code>就不说了。这两行代码是调用PyTorch的API来读取我们刚刚编译出来的动态库。我们这里只需要把动态库路径改成自己的就好，别的都不用改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_add</span>():</span></span><br><span class="line">    a = torch.rand([<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>])</span><br><span class="line">    b = torch.rand([<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>])</span><br><span class="line">    c = torch.ops.my_ops.my_add(a, b)</span><br><span class="line">    d = a + b</span><br><span class="line">    <span class="keyword">assert</span> torch.allclose(c, d)</span><br></pre></td></tr></table></figure>
<p>后面这些代码就是实际单元测试的代码里，代码非常简单：生成两个随机tensor，比较一下我们的加法和PyTorch自己的加法是否结果一致。</p>
<p>值得注意的是，用<code>torch.ops.my_ops.my_add</code>可以调用我们刚刚那个C++函数。前面的<code>torch.ops</code>都是写死的，后面的<code>my_add</code>是我们自己定义的函数名。而<code>my_ops</code>，则是我们刚刚调API时填的“算子域”了。算子域在注册Python符号表的时候还会用到，这里不用管那么多，把算子域理解成一个命名空间，一个防止算子命名冲突的东西即可。</p>
<p><code>torch.allclose</code>可以简单地理解为一个要求两个Tensor所有值都<strong>几乎</strong>相等的比较函数。</p>
<p>在该文件夹下运行命令<code>pytest</code>，屏幕上显示绿色的<code>1 passed xxxxxxxxxx</code>即说明单元测试成功运行。</p>
<p>至此，我们算是成功在Python里调用了一个C++写的算子。只需要写上torch.ops.my_ops.my_add`，我们就能够在任何地方（比如模型的forward函数）调用我们的算子。聪明的人看到这里，已经学会随心所欲地在PyTorch里嵌入自己的高效率的C++算子了。</p>
<p>配好环境，搭好框架后，我们自己实现算子倒是非常舒服。问题是，如果我们要把这些算子给别人使用的话，要么是给别人源代码，让别人自己配置LibTorch编译环境；要么是把所有<code>Torch版本数 * Cuda版本数 * 操作系统数</code>这么多个动态库给预编译出来。</p>
<p>要是能抛掉LibTorch，让有PyTorch和Cuda环境的用户自己编译源代码，似乎一个平衡开发者体验和用户体验的选择。所以，这里再介绍之前讲过的第二种添加算子的方法：直接在PyTorch里添加C++拓展。</p>
<h2 id="PyTorch-Extension-A-B"><a href="#PyTorch-Extension-A-B" class="headerlink" title="PyTorch Extension A+B"></a>PyTorch Extension A+B</h2><p>用Python的setuptools也可以编译一些C++项目但，由于其头文件目录、依赖的库目录这些编译选项需要手动设置，setuptools仅适用于编译比较简单的C++项目。</p>
<p>在同文件夹中，编写以下的<code>setup.py</code>文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> cpp_extension</span><br><span class="line"></span><br><span class="line">include_dirs = [<span class="string">r&#x27;D:\OpenCV\opencv\build\include&#x27;</span>]</span><br><span class="line">library_dirs = [<span class="string">r&#x27;D:\OpenCV\opencv\build\x64\vc15\lib&#x27;</span>]</span><br><span class="line">libraries = [<span class="string">r&#x27;opencv_world452&#x27;</span>]</span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">&#x27;my_add&#x27;</span>,</span><br><span class="line">      ext_modules=[</span><br><span class="line">          cpp_extension.CppExtension(<span class="string">&#x27;my_ops&#x27;</span>, [<span class="string">&#x27;op2.cpp&#x27;</span>],</span><br><span class="line">                                     include_dirs=include_dirs,</span><br><span class="line">                                     library_dirs=library_dirs,</span><br><span class="line">                                     libraries=libraries)</span><br><span class="line">      ],</span><br><span class="line">      cmdclass=&#123;<span class="string">&#x27;build_ext&#x27;</span>: cpp_extension.BuildExtension&#125;)</span><br></pre></td></tr></table></figure>
<p>在这个源文件中，要改的就是以下三个路径（代码块中显示的是我的路径）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include_dirs = [<span class="string">r&#x27;D:\OpenCV\opencv\build\include&#x27;</span>]</span><br><span class="line">library_dirs = [<span class="string">r&#x27;D:\OpenCV\opencv\build\x64\vc15\lib&#x27;</span>]</span><br><span class="line">libraries = [<span class="string">r&#x27;opencv_world452&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>这三个路径用于配置OpenCV的编译选项，分别表示OpenCV的包含目录（头文件目录）、静态库目录、静态库名。用Visual Studio导入过第三方库的，肯定对这三个选项不陌生。</p>
<blockquote>
<p>如果是在 Linux 上，前两个路径大概是”/usr/local/include/opencv2”, “/usr/local/lib” 。最后的库名填写<code>opencv_core</code>即可。</p>
</blockquote>
<p>至于PyTorch相关的编译选项，我们不需要手动设置。这是因为我们用了PyTorch封装的添加C++拓展接口，PyTorch有关的路径已经被填好了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setup(name=<span class="string">&#x27;my_add&#x27;</span>,</span><br><span class="line">      ext_modules=[</span><br><span class="line">          cpp_extension.CppExtension(<span class="string">&#x27;my_ops&#x27;</span>, [<span class="string">&#x27;op2.cpp&#x27;</span>],</span><br><span class="line">                                     include_dirs=include_dirs,</span><br><span class="line">                                     library_dirs=library_dirs,</span><br><span class="line">                                     libraries=libraries)</span><br><span class="line">      ],</span><br><span class="line">      cmdclass=&#123;<span class="string">&#x27;build_ext&#x27;</span>: cpp_extension.BuildExtension&#125;)</span><br></pre></td></tr></table></figure>
<p>在调用<code>setup</code>时，<code>name</code>是整个项目的名字，可以随便取。<code>my_ops</code>和刚刚一样，是命名空间的名字，我们还是保持<code>my_ops</code>这个名字。<code>op2.cpp</code>就是要编译的源文件了，这里我们待会再讨论。剩下的参数这些传进去就行了。</p>
<p>我们再在<code>op.cpp</code>的基础上新建一个新的C++源文件<code>op2.cpp</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;torch/torch.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">torch::Tensor <span class="title">my_add</span><span class="params">(torch::Tensor t1, torch::Tensor t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(t1.<span class="built_in">size</span>(<span class="number">0</span>) == t2.<span class="built_in">size</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">assert</span>(t1.<span class="built_in">size</span>(<span class="number">1</span>) == t2.<span class="built_in">size</span>(<span class="number">1</span>));</span><br><span class="line">  <span class="function">cv::Mat <span class="title">m1</span><span class="params">(t1.size(<span class="number">0</span>), t1.size(<span class="number">1</span>), CV_32FC3, t1.data_ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br><span class="line">  <span class="function">cv::Mat <span class="title">m2</span><span class="params">(t1.size(<span class="number">0</span>), t1.size(<span class="number">1</span>), CV_32FC3, t2.data_ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line">  cv::Mat res = m1 + m2;</span><br><span class="line"></span><br><span class="line">  torch::Tensor output = torch::<span class="built_in">from_blob</span>(res.ptr&lt;<span class="keyword">float</span>&gt;(), &#123;t1.<span class="built_in">size</span>(<span class="number">0</span>), t1.<span class="built_in">size</span>(<span class="number">1</span>), <span class="number">3</span>&#125;);</span><br><span class="line">  <span class="keyword">return</span> output.<span class="built_in">clone</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">PYBIND11_MODULE</span>(my_ops, m)</span><br><span class="line">&#123;</span><br><span class="line">  m.<span class="built_in">def</span>(<span class="string">&quot;my_add&quot;</span>, my_add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实修改的就是这一行<code>TORCH_LIBRARY(my_ops, m)-&gt;PYBIND11_MODULE(my_ops, m)</code>，没有调用TorchScript的绑定接口，而是直接用Pybind绑定了C++函数。</p>
<p>接下来，在当前文件夹下运行命令<code>python setup.py install</code>即可编译刚刚的C++源文件了。成功的话大概会有<code>Finished processing dependencies for my-add==0.0.0</code>这样的提示。</p>
<p>编译结束后，我们在原来<code>test_add.py</code>的基础上添加一些单元测试，看看用这种新方法编译完C++拓展后怎么调用C++函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_add2</span>():</span></span><br><span class="line">    <span class="keyword">import</span> my_ops</span><br><span class="line">    a = torch.rand([<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>])</span><br><span class="line">    b = torch.rand([<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>])</span><br><span class="line">    c = my_ops.my_add(a, b)</span><br><span class="line">    d = a + b</span><br><span class="line">    <span class="keyword">assert</span> torch.allclose(c, d)</span><br></pre></td></tr></table></figure>
<p>由于我们刚刚编译了一个命名空间为<code>my_ops</code>的包，我们可以用<code>import my_ops</code>导入这个刚刚编译好的库了。现在调用C++函数的方法变成了<code>my_ops.my_add</code>，其他地方都没有变化。</p>
<p>运行<code>pytest test_add.py::test_add2</code>可以单独测试这一个函数。当然懒的话直接<code>pytest</code>可以把刚刚那个测试和这个测试一起做一遍。单元测试通过就说明我们成功运行了C++拓展。</p>
<p>事实上，这种安装方式还是不够友好。由于我们用到了OpenCV，OpenCV的库路径还是要手动设置。这种安装方式只有在除PyTorch本身外不需要任何第三方库时比较友好。不然的话要么让用户自己手动设置路径，要么在代码库里引用别的开源库，再一个一个重写路径。大型项目还是用CMake等编译系统来编译比较友好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我介绍了两种在PyTorch里调用C++新算子的方法。只要看懂了这篇文章，就算是彻底打通了PyTorch与C++的桥梁，以后写代码可以专注于C++算子的实现及PyTorch对算子的封装，剩下的绑定算子的内容直接套这个模板就行。</p>
<p>两种算子实现方法的区别主要在于编译选项的设置上和用户在编译算子的体验上。应根据项目的实际情况选择一种方案。</p>
<p>这篇文章强行调用OpenCV实现了Tensor加法，看上去是多此一举，实际上这是为了展示如何在添加自定义算子时使用第三方库。但为了简化他人编译的过程，实际实现算子时最好只用原本的PyTorch API。</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="运行LibTorch的示例程序，无法定位程序输入点-xxxxx-于动态链接库-xxxxx"><a href="#运行LibTorch的示例程序，无法定位程序输入点-xxxxx-于动态链接库-xxxxx" class="headerlink" title="运行LibTorch的示例程序，无法定位程序输入点 xxxxx 于动态链接库 xxxxx"></a>运行LibTorch的示例程序，无法定位程序输入点 xxxxx 于动态链接库 xxxxx</h3><p>这个问题找了我老半天，就找到2~3个相关的答案，全是治标不治本的方法。</p>
<p>有人说，是动态库路径的问题。我测试了一下，直接运行编译好的程序会报错，但是<strong>把程序放到LibTorch的动态库目录下就不会报错</strong>。我已经隐隐约约地感觉到，不是动态库找不到，而是<strong>动态库路径的优先顺序</strong>出了问题。</p>
<p>果不其然，最后我在<a target="_blank" rel="noopener" href="https://www.icode9.com/content-3-1005434.html">这篇文章</a>里找到了问题的真正原因：Cuda的动态库和LibTorch的冲突了（PyTorch和Cuda要背大锅）。那篇文章中暴力删掉了Cuda的动态库，但是温柔的我们绝对不要这样做。按照前面章节的内容，调整LibTorch与Cuda的路径优先级即可。</p>
<p><img src="/2022/03/18/20220315-custom-op/bug1.jpg" alt></p>
<p>貌似官方教程提到了类似的错误。这里再提供一种可能的解决问题的思路（反正我没试）。</p>
<h3 id="WinError-126-找不到指定的模块"><a href="#WinError-126-找不到指定的模块" class="headerlink" title="[WinError 126] 找不到指定的模块"></a>[WinError 126] 找不到指定的模块</h3><p>这个问题说明Python的PyTorch库版本和下载的LibTorch C++版本不一致。用<code>pip show torch</code>查看当前的PyTorch版本，去重新下载对应的LibTorch即可。</p>
<h3 id="OSError-xxx-Undefined-symbol-Linux"><a href="#OSError-xxx-Undefined-symbol-Linux" class="headerlink" title="OSError: xxx Undefined symbol (Linux)"></a>OSError: xxx Undefined symbol (Linux)</h3><p>要把 LibTorch 的动态库加入 LD_LIBRARY_PATH 里。</p>
<h1 id="有关博客“学习”分类下子类别的说明"><a href="#有关博客“学习”分类下子类别的说明" class="headerlink" title="有关博客“学习”分类下子类别的说明"></a>有关博客“学习”分类下子类别的说明</h1><p>貌似之前说明过一次，这里再整理一遍。</p>
<ul>
<li>工具用法指南：几乎没有技术含量的，把下载安装过程的踩坑过程原封不动地讲一遍。</li>
<li>知识记录：对现有成体系知识的描述，尤其会写教科书、公开课上的知识，较少我个人的见解。</li>
<li>知识整理：对某一工具、知识、技术的说明，主要以我个人的见解、整理为主。</li>
</ul>
<p>另外，“学习”类别和“记录”类别挺容易混淆的。这里我再做个规定：“记录”以具体的任务为导向，比如先有要写的作业、要看的论文、要做的项目、规划好的旅游计划，再对这些事情进行描述。而“学习”中包含的文章，更多是一种主观的，以学到东西为目的而写的文章。如果我看了一篇论文，只写论文的内容的话，会分到“记录”里；如果我想调研一个主题的文章，会把调研结果放到“学习-笔记”里；如果我看了很多论文，有了原创性非常强的一篇描述知识的文章，会放到“知识分享”（未来的“创作-知识”）里。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2022/03/08/Code-Optimization-Fun/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/Code-Optimization-Fun/" class="post-title-link" itemprop="url">拆掉循环竟然让代码性能大幅提升？ ~ 有趣的高性能计算大作业</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-08 22:29:29" itemprop="dateCreated datePublished" datetime="2022-03-08T22:29:29+08:00">2022-03-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">记录</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%B0%E5%BD%95/%E4%BD%9C%E4%B8%9A-%E7%BB%83%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">作业/练习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由于这个学期没有返校，我变懒了不少。明明有不少可以写的东西，却没有去写。等学期结束了有时间了我会好好补写一些博客。</p>
<p>这几天，我在赶一个高性能计算的大作业。题目要求优化一段代码，使程序的运行时间尽可能短。大作业本来是一个令人烦躁忧虑，头皮发麻的事物，但在deadline的紧逼之下，我仿佛按下了大脑的启动按钮，火力全开地应对起这个大作业来。于是，我的漫长的编程时间就开始了。——看到这里，如何你对编程不是非常了解，可能完全没有读下去的兴致。但我保证我会用外行人也能看懂的方式，来描述我这次有趣的写大作业经历。</p>
<p>再具体地讲一下我的大作业要求。我的大作业题目是代码优化，跑代码花费的时间是评价成绩的唯一指标。当然，代码的正确性不能受到影响，你不能让程序刚进去就关掉。代码跑得越快，分数越高。如果代码速度是原来的2倍，则可以拿到60分及格。如果达到原来的2.5，3，3.5，4倍，则可以分别拿到80，90， 95， 100分。成绩评判标准唯一且清晰。</p>
<p>我是作业截止的最后4天开始看这个大作业的。看完这个评分标准，我心里先是一乐：“哈哈，终于有一个评分透明的大作业了，写论文什么的成绩太容易受老师主观评价影响了。”接着，我又发现事情有些不太对：“既然老师敢给这么高的分数，说明代码想优化到3倍或者4倍是很困难的。我的时间这么少，恐怕只能拿个80分吧。”我也没再想下去，反正代码能优化多少就优化多少，也没有那种先定目标再开始干活的必要。</p>
<p>我的编程任务正式开始了。准确来说，我做的不是编程，是合理而优雅地修改老师给的代码，让这个代码运行速度更快一些，而不改变程序本身的意思。要打比方的话，我是一个拿着手术刀的医生，我需要精准地切掉病变部位，还病人一个更好的身体。比较幸运的是，我的工作可以反复调试，代码出了问题可以重新修改，而不需要担心造成什么破坏性的后果。</p>
<p>代码的功能是计算化学反应的一些参数。这段代码产生的程序不会产生任何花哨的网页、按钮，只会在默默地运行数十秒中后，冷冰冰地在控制台上输出一行数学计算的结果。运行这段代码就好像把一个优等生关进一个房间，让他把数学卷子全做出来再离开一样。只不过程序在输入的参数完全相同的情况下，每次都会执行一模一样的操作，最终得到完全相同，完全正确的结果。</p>
<p>这段代码可谓是又臭又长。丝毫没有注释，一个文件里的代码（代码分布在多个文件中）全是看不懂的化学常量，另一个文件的代码全是看似毫无逻辑的计算步骤。在浏览过代码，手足无措数秒钟后，我迅速转换了思维：“化学反应的代码归根结底就是计算一个很长的公式。我没有必要看懂为什么这么做，我只需要知道哪些加减乘除运算可以被我优化就行了。”我的这种冷静能力与思维跳转能力非常惊人。</p>
<p>在<a href="https://zhouyifan.net/2019/12/23/Software-Engineering-Project/">这个大作业</a>中，我学到了查看代码性能瓶颈的方法。经过检测，代码最耗时的部分竟然是一个<code>exp()</code>自然指数运算。自然指数本身是一个很容易理解的函数，高中数学就讲过这个函数的性质。这个函数在数学上很好表达，在程序中计算起来却非常麻烦。因为这个函数的值往往是一个无限不循环数，而程序只能进行有限的计算。程序只能通过多次的加法、乘法来得到一个十分近似的结果。程序总计进行了3亿次自然指数运算，代码性能瓶颈出现在这确实也情有可原。</p>
<p>程序中的指数运算，需要调用标准库。标准库是高级程序员们反复锤炼，被无数人反复验证的代码。这个自然指数运算对我来说是根本不可能修改的。看到这个情况，我心都凉了半截。</p>
<p>虽然一上来就碰到如此困难的情况，但我再次调整了心态。指数运算耗费了三成的时间，还有七成的运行时间可以被优化。我把目光又放到了其他运算速度较慢的代码上。凭借多年的高级语言（比较抽象、接近自然语言的程序语言）编程经验，我意气风发，大刀阔斧地对代码进行优化。我主要对代码进行了预处理、循环合并这两类优化。预处理就是把一些程序中不会变动的常量提前算好，避免每次重新计算。就好像你提前买一箱抽纸，这样几个月都不用再去买纸一样。循环合并就是把条件一样，需要反复做的事情，再每个“反复”中一起做掉。比如让你去测全校同学的身高体重，量身高和量体重的仪器摆在一起，这里假设两台仪器不能同时工作。你不能让同学挨个测完身高，回教室休息一下，再一个一个回来量体重。每个人量身高体重的时间虽然没变，但来回教室、排队等待的时间浪费了。最好的方法是每个人先量身高，再量体重。如果你懂编程，你或许能理解，这里的来回教室时间就是CPU从内存中读数据的时间，排队时间可以看成循环变量、控制流耗费的时间，在一个循环里做尽可能多的事能减小时间开销。</p>
<p>以上两类优化是非常基础的优化。经过优化后，程序运行时间从26秒到了17秒。很可惜，速度还没有达到2倍，我的成绩连及格也没有。我反复查看了其他部分的代码，绞尽脑汁也没有想出哪里可以优化。于是，我只好把目光再次放到了开始的指数运算上。</p>
<p>经过观察，我发现指数运算是一批一批做的，也就是一次会对多个数据依次执行步骤相同的指数运算，而标准库只能每次对一个数据进行指数运算。这里面有没有可以利用的空间呢？我凭借着十多年与搜索引擎打交道的经验，总算找到了一个比较厉害的数学运算库。里面有一种对批量数据进行指数运算的函数。我满怀期望地用这种”高级“函数替换了原来的函数。结果非常令人惊喜：程序的执行时间从17秒降到了12~13秒，速度整体变成了原来的2倍，我总算及格了。</p>
<p>开心之余，我总感觉自己忘了些什么事。仔细回忆了一下，代码优化不仅要快，原来程序的输出结果还不能被更改。我还没有验证新代码的正确性呢！我赶快把新代码和旧代码的结果进行了比较，发现新代码的输出结果发生了变化！</p>
<p>我改动了那么多处，究竟是哪一步出错了啊？！为了找出代码中的BUG，我采用了古老而有效的控制变量法。我把旧代码粘贴了回去，一段一段地把代码更新成新代码。如果某一次更新后运行结果有问题，就说明这段代码有问题。我顺利地找出了不少的低级错误。可是，我最不想碰到的情况发生了——</p>
<p>我发现指数运算的那整段代码中存在问题。我尝试地把指数运算的那一行改回了旧版本的代码，输出结果就正常了。也就是说，这种优化的指数运算会导致结果不正确。</p>
<p>我又慌了，心想指数运算这道坎可能就是过不去了。但我内心中突然涌现出的自信告诉我，我的新代码没有错误。这个新的指数运算函数是intel公司写的，如果有问题，只可能是他们有问题。代码的运行结果虽然改变了，但是代码不一定有错——这两句话并不是矛盾的。在精度较高的数学计算中，如果小数点后面好多位出现了偏差，只能算是结果有误差，不能说结果错误。况且原来的代码也只是对数学计算结果的一种近似，你怎么能保证原来的代码就离正确的结果更近呢？给你两块手表，两者差了几秒，你能知道哪块手表是正确的时间吗？保证这样的心理，我对新代码输出结果的误差进行了计算。</p>
<p>经检验，新代码和源代码的相对误差在小数点后6位，也就是0.0001%这个数量级。老师可没有强调结果要完全相同，或者误差保持在什么范围内。从道理上来看，只要保证代码整体的正确性就行。在强烈的自我暗示下，我接受了代码输出结果不完全相同，但我却是正确的这一事实。</p>
<p>如前面所述，我已经尽可能地在其他地方优化代码，就目前而言，这份代码对我来说是最优的。第一天天色已晚，我选择偃旗息鼓，明日再战。</p>
<p> 第二天十点，烈日当空，天朗气清。我再次开始着手优化代码。经过缜密的分析，我觉得我缺少部分的知识，我需要从别的角度入手，用一些我不太熟悉的方法优化代码。</p>
<p>程序的运行可以分成串行和并行。串行的概念非常简单，我们人的大脑就是串行的。你不能说我左半边脑子在浏览选项题，右边的大脑跑去想填空题去了。并行就是多个串行，可以理解成多个人合作做一件事。写论文时，你写正文，我写摘要，我们同时开始写，这就是一种并行。显然，N个人干活，必然不能让事情的快N倍。因为人与人之间的交流存在着极大的效率浪费。如若不然，为什么每个企业要设置那么复杂的管理体系呢？并行程序也是如此，在硬件支持的情况下，程序并行可以提高速度，但也有一定的资源损耗。</p>
<p>我学过并行的知识，了解并行的概念，但没有并行编程的经验。于是，我只好以”C++ 并行编程”为搜索词去搜索有关信息。很快，我就搜到了一个满意的答案：有一种叫OpenMP的并行编程API，只需要在程序里加一些代码，就能把串行的程序变成并行的程序。但是，要是只加少量代码的话，只能并行执行循环结构，且只有对重复次数较多的循环起到优化作用。比如搬1000个箱子，让10个人来搬来搬肯定比1个搬快，而且大家只需要在搬完后交换一次信息，确认一下所有箱子都搬完了。想把更复杂的代码并行执行并达到优化效果，就要学更多的知识了。考虑到我所剩的时间不多，我打算只用OpenMP来并行优化循环。</p>
<p>我写了个算加法的循环，并用OpenMP并行优化。经过实验后，这个简单循环的运算确实变快了，优化成功了。看来，并行加速并不是很难啊。现在大作业代码的性能瓶颈还是那个指数运算。指数运算是作用在一个数组上的，目前的实现方式是循环对数组的每一个元素做指数运算。如果能把这个循环并行化，但代码的运算速度肯定能快上很多。于是，我把OpenMP的并行代码运用到了指数运算循环上。</p>
<p>可是，并行化后，代码不仅没有变快，反而变慢了。甚至随着并行线程数（可以理解为同时有多少个人在做同一个工作）增加，代码会运行得越来越慢。</p>
<p>做为一个自信的程序员，碰到问题时，我的第一反应肯定不是觉得我自己写错了，而是这个OpenMP调用得用问题。可能我使用这个工具的方法不太对。既然这样，也没时间去学新的东西了，没有轮子就自己造轮子，我只好自己来写一个多线程的并行程序了。于是，我删掉了OpenMP的代码，手写了创造线程、用线程做指数运算、同步线程的代码。我自己写的代码，肯定没问题了吧？</p>
<p>结果，用我自己的并行代码运行程序后，程序的运行速度也变慢了。做为一个正常的程序员，在代码全是自己写的情况下还发现了运行上的问题，第一反应就是出bug了。于是，我把那段并行的代码拎了出来，单独测试了好久。可是，无论怎么调试，都没有发现问题。第二天就在无聊而令人烦恼的调试中度过了。</p>
<p>晚上，躺在床上，苦恼地思索着代码里的问题。突然，我想到：是不是我的代码一直没有问题，而是并行这个方案有问题？做循环的次数只有10多次，如果用多线程的话，线程之间沟通的时间，就远远多于并行运算本身减少的时间。正所谓“三个和尚没水喝啊”。没办法，第二天就这么浪费了。我及时止损，准备使用新的方法优化程序。</p>
<p>经过昨晚的计划后，第三天，我早早地打开电脑查询一个新的技术。我顺着并行编程这一条线索，想到了另一个并行技术——SIMD（单指令多数据流）。这个技术就好比之前是一个人搬一箱货物，现在这个人可以拿手推车，一次搬几箱货物。在SIMD中，唯一增加的成本，就是货物得提前按组打包，这样才能够一组一组地搬运。这一项成本远远小于之前多线程之间沟通的成本。我去网上查了什么AVX指令集，学会了如何一次对4个数据进行计算。这样，不仅是那个指数运算，还有一些相邻的乘除法运算也可以顺便用并行</p>
<p>这次程序运算时间在8、9秒左右浮动。严格来说，程序并没有优化到三倍。但是，要是精心挑选一组比较看得过去的测试时间的话，应该能在报告里声称我把程序优化了3倍。这下，80分才算勉勉强强拿到。</p>
<p>代码真的就不能再优化了吗？既然老师敢说把速度优化4倍就能拿到满分，说明这份代码肯定还是有优化空间的。我把这份代码从头到尾读了一遍又一遍，在我的知识范围内，能用的优化小伎俩都用上了。但是，程序的运算时间几乎没有减少。我感觉自己已经弹尽粮绝了。</p>
<p>经过多次优化后，指数运算的用时占比已经不算很多了。一些对一个常量数组的遍历、取值、运算的用时占比逐渐高了起来。就好像一个邮递员要挨家挨户上门取件，再把货物送到另一个地方一样。这一部分的时间完全耗费在了跑到每个人家门口，敲门等人开门上，跑腿的时间反倒是可以忽略不计。这部分循环操作数组的代码是不能用之前的并行来优化的。这部分的代码没有什么过多的操作，自然也几乎没有改动的空间。我通读代码，看到这一团改不了的代码时，总会无可奈何地快速跳过。</p>
<p>我对代码优化已经绝望了。走神时，我想起了计算机体系结构课里的知识：现在CPU采用了流水线的设计，跳转指令（比如循环）会导致流水线的断流。为了让代码更快运行，某些时候能不用分支、循环就不要用。</p>
<p>我突然产生了一个奇怪的念头：循环吗……如果我把从常量数组取值的循环全部拆掉如何？这个可以理解成快递员上门取一层楼的货品时，可以用循环表示：取这个房间的货，往前走；去这个房间的货，往前走；……；如果这一层没有住户了，就上一层楼。但是，这是一个常量数组，即我可以提前知道这栋楼有几层，每层有哪几个房间。这样，快递员的指令就变成了：去101取件；去102取件……去606取件这样确切的命令。快递员不用动脑筋去观察什么时候把这层楼走完，可以上一层楼了。抛弃掉回产生跳转指令的循环后，按理说代码能变快很多。</p>
<p>但是，我们初学编程认识循环时，就知道循环是用来简化代码的。现在，我却要反常识地把循环拆掉，把要执行的代码展开来，一行一行写出来。这太反常识了。当然，循环拆掉代码展开后，代码会变得特别长，其中会包含很多重复的代码。与其我手动写，不如写个脚本自动把这些代码生成出来。于是，我写了一段生成代码的Python代码，把原来的循环拆掉了。</p>
<p>我持着怀疑的态度，一边苦笑地看着那些丑陋的代码，一边等待着程序运行结束。没想到，程序的运算时间竟然大幅度变少了！这次运行时间之间减少到了6秒多，程序的速度基本上是最开始的4倍了。我还没来得及烦恼怎么跨过优化3.5倍这道分数砍，程序一下就优化到满分了。</p>
<p>这太有趣了！违反常理地拆掉循环竟然能让代码加速。我关掉了再也不想多看一眼的代码，开开心心地把优化四倍的结果写进实验报告里。然后，我开始着手写这篇文章，记录一下这段过程紧张，结局却是Happy Ending的代码优化之旅。</p>
<p>噢，对了，源代码我是有的，但我一定不会开源。我能想象到，老师肯定会把同一份大作业用好几年。为了让这门课公平一点，我是不会上传代码的。当然了，稍微有一点编程水平的人，看完这篇文章后，都知道了该怎么优化程序了。这篇文章也算是给和我一样初学代码优化的人一些学习上的启发吧。</p>
<blockquote>
<p>这是2020年6月份的文章，我当时写到一半搁笔没写了。趁现在有时间，赶快填一个坑。</p>
<p>现在重温这段经历，当时提笔时的激动已经没了，只剩下了怀念。两年前，我肯定想不到这四天不到的代码优化经历，竟然是我本科期间学代码优化技术学得最多、学习效率最高的一段时间，也想不到几年后的现在的几天后我即将开始新的工作，会把之前学到的这些代码优化技术全部用出来。</p>
<p>对了，最近我在写很多文章。今天不认真的文字写了3000~4000，之前比较认真的写得话一天3000字都不到。我本来以为这个速度很慢，上网一看，这才是正常速度。把写东西单纯当一个爱好也挺不错嘛。虽然既没有编程有趣，也没有编程挣钱就是了。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhou Yifan</p>
  <div class="site-description" itemprop="description">A foresighted strategist with big-picture thinking. 大局观选手。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">77</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Yifan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
